    /*
     * Notice: file generated by MIBMAKE from mibslot.mdf
     * DO NOT EDIT THIS FILE!!!  Edit mibslot.mdf
     */
#line 3 "mibslot.mdf"
/*
 * SCCS ID:     $Id: mibslot.h,v 1.1.1.1 2011/08/17 11:11:56 brwang Exp $
 *
 *      Copyright (c) 1995-1997 UTT Technologies, Inc.
 *      All rights reserved.
 *      Use of copyright notice does not imply publication.
 *
 *
 *                      CONFIDENTIAL INFORMATION
 *                      ------------------------
 *      This Document contains Confidential Information or Trade Secrets,
 *      or both, which are the property of UTT Technologies, Inc.
 *      This document may not be copied, reproduced, reduced to any
 *      electronic medium or machine readable form or otherwise duplicated
 *      and the information herein may not be used, disseminated or
 *      otherwise disclosed, except with the prior written consent of
 *      UTT Technologies, Inc.
 */

#line 25 "mibslot.mdf"

#if ! defined( MIBSLOT_H )
# define MIBSLOT_H

# include "tspubs.h"

# if (MDF_OSPF == FYES)
#  include "mibospf.h"
#  include "mibospfg.h"
# endif /* MDF_OSPF */

# if ( MDF_DNS_FALLBACK_TABLE == FYES )
#  include "mibdnstab.h"
# endif /* MDF_DNS_FALLBACK_TABLE */

# if ( MDF_IP_FAX == FYES )
#  include "mibipfax.h"
# endif /* MDF_IP_FAX */

# if ( MDF_VOIP == FYES )
#  include "mibvoip.h"
# endif /* MDF_VOIP */

# if ( MDF_LMODEM == FYES )
#  include "hardware.h"
# endif
# if ( MDF_SNTP == FYES )
#  include "mibsntp.h"
# endif
# if (( MDF_CLID == FYES) && ( PLATFORM & ( M1800 | M2000 | M4000 | M6000 ) ) )
# include "mibdnistab.h"
# endif
# include "mibtssec.h"
# include "mibtsecm.h"
# include "mibtsmbr.h"
# include "mibtsmtl.h"
# include "mibtscl.h"
# include "mibtstm.h"
# include "mibtsis.h"
# include "mibtspi.h"
# include "mibrip.h"
# include "mibatmp.h"
# include "mibname.h"
# if (( MDF_PPTP == FYES ) || ( MDF_L2TP == FYES ))
#  include "mibl2tunnel.h"
# endif /* ( MDF_PPTP == FYES ) || ( MDF_L2TP == FYES ) */

#if(DOT1X == FYES)
#include "mibdot1x.h"
#endif


# if ( DOT1Q_VLAN == FYES )

# define FIRST_DOT1Q_SLOT_NUMBER 	1
# define LAST_DOT1Q_SLOT_NUMBER		NUM_OF_ETHER_SLOTS
# define NUMBER_OF_DOT1Q_SLOTS		NUM_OF_ETHER_SLOTS

/*
 * add by brwang
 */
#ifndef MAX_CBT_TIMERANGE_NUM
#define  MAX_CBT_TIMERANGE_NUM      3
#endif
typedef struct st_dot1q_cfg {
    char		name[MAX_PROFILE_NAME_LENGTH+1];
    Boolean		enable;
    char		description[MAX_PROFILE_NAME_LENGTH+1];
    Uint16              vLanDot1qType;
    Uint16              vLanDot1qEncapsType;
    Uint16              vlanDot1qIfGroup;
    Uint16              vlanDot1qTagGroup;
    Uint16              vlanDot1qMacGroup;
} dot1qParams;
# endif

# if ( TC_DRR == FYES )
typedef enum ip_RED_DURATION_type {
  RED_DURATION_DISABLED = 0,
  RED_DURATION_15s  = 0x0f,
  RED_DURATION_30s  = 0x1f,
  RED_DURATION_45s  = 0x2f,
  RED_DURATION_60s  = 0x3f,
  RED_DURATION_75s  = 0x4f,
  RED_DURATION_90s  = 0x5f,
  RED_DURATION_105s  = 0x6f,
  RED_DURATION_120s  = 0x7f,
/* about 8 years */
  RED_DURATION_8y  = 0x0fffffff,
  RED_DURATION_MAX
} RED_DURATION_TYPE;

typedef enum ip_DRR_type {
  DRR_DISABLED  = 0,
  DRR_64Kbit    = 1,
  DRR_128Kbit   = 2,
  DRR_256Kbit   = 3,
  DRR_512Kbit   = 4,
  DRR_1Mbit     = 5,
  DRR_2Mbit     = 6,
  DRR_4Mbit     = 7,
  DRR_8Mbit     = 8,
  DRR_16Mbit    = 9,
  DRR_32Mbit    = 10,
  DRR_64Mbit    = 11,
  DRR_128Mbit   = 12,
  DRR_256Mbit   = 13,
  DRR_512Mbit   = 14,
  DRR_1Gbit     = 15,
  DRR_2Gbit     = 16,
  DRR_4Gbit     = 17,
/* must be less than 2**18, right now, since we start from 8192, whichi is 2**13 */
  DRR_CREDIT_MAX
} DRR_CREDIT_TYPE;

typedef enum ip_DRR_limit {
  DRR_QUOTA_0Mb  = 0,
 DRR_QUOTA_8Kb  = 1*8*1024,           /* 64kbit */
  DRR_QUOTA_16Kb  = 2*8*1024,
  DRR_QUOTA_32Kb  = 4*8*1024,
  DRR_QUOTA_64Kb  = 8*8*1024,
  DRR_QUOTA_128Kb  = 16*8*1024,
  DRR_QUOTA_256Kb  = 32*8*1024,
  DRR_QUOTA_512Kb  = 64*8*1024,
 DRR_QUOTA_1Mb  = 1*1024*1024,
  DRR_QUOTA_2Mb  = 2*1024*1024,
  DRR_QUOTA_3Mb  = 3*1024*1024,
  DRR_QUOTA_4Mb  = 4*1024*1024,
  DRR_QUOTA_5Mb  = 5*1024*1024,
  DRR_QUOTA_6Mb  = 6*1024*1024,
  DRR_QUOTA_7Mb  = 7*1024*1024,
  DRR_QUOTA_8Mb  = 8*1024*1024,
  DRR_QUOTA_9Mb  = 9*1024*1024,
 DRR_QUOTA_10Mb  = 10*1024*1024,
  DRR_QUOTA_11Mb  = 11*1024*1024,
  DRR_QUOTA_12Mb  = 12*1024*1024,
  DRR_QUOTA_13Mb  = 13*1024*1024,
  DRR_QUOTA_14Mb  = 14*1024*1024,
  DRR_QUOTA_15Mb  = 15*1024*1024,
  DRR_QUOTA_16Mb  = 16*1024*1024,
  DRR_QUOTA_17Mb  = 17*1024*1024,
  DRR_QUOTA_18Mb  = 18*1024*1024,
  DRR_QUOTA_19Mb  = 19*1024*1024,
 DRR_QUOTA_20Mb  = 20*1024*1024,
  DRR_QUOTA_21Mb  = 21*1024*1024,
  DRR_QUOTA_22Mb  = 22*1024*1024,
  DRR_QUOTA_23Mb  = 23*1024*1024,
  DRR_QUOTA_24Mb  = 24*1024*1024,
  DRR_QUOTA_25Mb  = 25*1024*1024,
  DRR_QUOTA_26Mb  = 26*1024*1024,
  DRR_QUOTA_27Mb  = 27*1024*1024,
  DRR_QUOTA_28Mb  = 28*1024*1024,
  DRR_QUOTA_29Mb  = 29*1024*1024,
 DRR_QUOTA_30Mb  = 30*1024*1024,
  DRR_QUOTA_31Mb  = 31*1024*1024,
  DRR_QUOTA_32Mb  = 32*1024*1024,
  DRR_QUOTA_33Mb  = 33*1024*1024,
  DRR_QUOTA_34Mb  = 34*1024*1024,
  DRR_QUOTA_35Mb  = 35*1024*1024,
  DRR_QUOTA_36Mb  = 36*1024*1024,
  DRR_QUOTA_37Mb  = 37*1024*1024,
  DRR_QUOTA_38Mb  = 38*1024*1024,
  DRR_QUOTA_39Mb  = 39*1024*1024,
 DRR_QUOTA_40Mb  = 40*1024*1024,
  DRR_QUOTA_41Mb  = 41*1024*1024,
  DRR_QUOTA_42Mb  = 42*1024*1024,
  DRR_QUOTA_43Mb  = 43*1024*1024,
  DRR_QUOTA_44Mb  = 44*1024*1024,
  DRR_QUOTA_45Mb  = 45*1024*1024,
  DRR_QUOTA_46Mb  = 46*1024*1024,
  DRR_QUOTA_47Mb  = 47*1024*1024,
  DRR_QUOTA_48Mb  = 48*1024*1024,
  DRR_QUOTA_49Mb  = 49*1024*1024,
 DRR_QUOTA_50Mb = 50*1024*1024,
  DRR_QUOTA_51Mb  = 51*1024*1024,
  DRR_QUOTA_52Mb  = 52*1024*1024,
  DRR_QUOTA_53Mb  = 53*1024*1024,
  DRR_QUOTA_54Mb  = 54*1024*1024,
  DRR_QUOTA_55Mb  = 55*1024*1024,
  DRR_QUOTA_56Mb  = 56*1024*1024,
  DRR_QUOTA_57Mb  = 57*1024*1024,
  DRR_QUOTA_58Mb  = 58*1024*1024,
  DRR_QUOTA_59Mb  = 59*1024*1024,
 DRR_QUOTA_60Mb  = 60*1024*1024,
  DRR_QUOTA_61Mb  = 61*1024*1024,
  DRR_QUOTA_62Mb  = 62*1024*1024,
  DRR_QUOTA_63Mb  = 63*1024*1024,
  DRR_QUOTA_64Mb  = 64*1024*1024,
  DRR_QUOTA_65Mb  = 65*1024*1024,
  DRR_QUOTA_66Mb  = 66*1024*1024,
  DRR_QUOTA_67Mb  = 67*1024*1024,
  DRR_QUOTA_68Mb  = 68*1024*1024,
  DRR_QUOTA_69Mb  = 69*1024*1024,
 DRR_QUOTA_70Mb  = 70*1024*1024,
  DRR_QUOTA_71Mb  = 71*1024*1024,
  DRR_QUOTA_72Mb  = 72*1024*1024,
  DRR_QUOTA_73Mb  = 73*1024*1024,
  DRR_QUOTA_74Mb  = 74*1024*1024,
  DRR_QUOTA_75Mb  = 75*1024*1024,
  DRR_QUOTA_76Mb  = 76*1024*1024,
  DRR_QUOTA_77Mb  = 77*1024*1024,
  DRR_QUOTA_78Mb  = 78*1024*1024,
  DRR_QUOTA_79Mb  = 79*1024*1024,
 DRR_QUOTA_80Mb  = 80*1024*1024,
  DRR_QUOTA_81Mb  = 81*1024*1024,
  DRR_QUOTA_82Mb  = 82*1024*1024,
  DRR_QUOTA_83Mb  = 83*1024*1024,
  DRR_QUOTA_84Mb  = 84*1024*1024,
  DRR_QUOTA_85Mb  = 85*1024*1024,
  DRR_QUOTA_86Mb  = 86*1024*1024,
  DRR_QUOTA_87Mb  = 87*1024*1024,
  DRR_QUOTA_88Mb  = 88*1024*1024,
  DRR_QUOTA_89Mb  = 89*1024*1024,
 DRR_QUOTA_90Mb  = 90*1024*1024,
  DRR_QUOTA_91Mb  = 91*1024*1024,
  DRR_QUOTA_92Mb  = 92*1024*1024,
  DRR_QUOTA_93Mb  = 93*1024*1024,
  DRR_QUOTA_94Mb  = 94*1024*1024,
  DRR_QUOTA_95Mb  = 95*1024*1024,
  DRR_QUOTA_96Mb  = 96*1024*1024,
  DRR_QUOTA_97Mb  = 97*1024*1024,
  DRR_QUOTA_98Mb  = 98*1024*1024,
  DRR_QUOTA_99Mb  = 99*1024*1024,
 DRR_QUOTA_100Mb  = 100*1024*1024,
  DRR_QUOTA_MAX
} DRR_QUOTA_LIMIT;


# endif /* ( TC_DRR == FYES ) */

# if ( XUANLIN_ALG == FYES )
struct xuanlin_prof{
	char								name[MAX_PROFILE_NAME_LENGTH+1];
	Boolean								enable;
	char								hostName[MAX_HOST_NAME_LENGTH+1];
	char								clientName[12+1];
	char								adminName[MAX_HOST_NAME_LENGTH+1];
	char								adminPasswd[MAX_HOST_NAME_LENGTH+1];
	Word								port;
	Word								mode;
	Word								level;
}; 

# endif
typedef enum ddns_tzone_type {
  DDNS_TZ_NONE      = 0,
  DDNS_TZ_GUAN      = 1,
  DDNS_TZ_MAX       = (24),
} DDNS_TZONE_TYPE;

# define MAX_DDNS_KEY_LEN	63

struct ddns_prof{
	char								name[MAX_PROFILE_NAME_LENGTH+1];
	Boolean								Enable;
	char								serverName[MAX_DOMAIN_NAME_LENGTH + 1];
	IpAddress							Server1;
	Word								Port1;
	IpAddress							Server2;
	Word								Port2;
	char								Hostname[MAX_HOST_NAME_LENGTH+1];
	Word								Updateretry;
	Word								Updatetimeout;
	Uint32								UpdateInterval;
	char								Keyname[MAX_HOST_NAME_LENGTH+1];
	char								Key[MAX_DDNS_KEY_LEN+1];
	char								enKey[MAX_DDNS_KEY_LEN+1];
	char								Profile[MAX_PROFILE_NAME_LENGTH+1];
	char								secProfile[MAX_PROFILE_NAME_LENGTH+1];
	char								LastUpdateTime[MAX_DDNS_KEY_LEN+1];
	DDNS_TZONE_TYPE							offset;
	char								interface[MAX_PROFILE_NAME_LENGTH + 1];
}; 

struct vrrp_prof{
	char								name[MAX_PROFILE_NAME_LENGTH+1];
	Boolean								Enable;
	char								interface[MAX_PROFILE_NAME_LENGTH + 1];
	unsigned char							vrid;	
	Boolean								Preempt;
	unsigned char							priority;
	unsigned char							interval;
	IpAddress							vrip;
	IpAddress							vrip2;
	char								Profile[MAX_PROFILE_NAME_LENGTH + 1];
};
/* zhz@20020906, pkt tape feature */
struct ptape_prof {
	Boolean								Enable;
	Uint32								Flags;
	Uint32								Method;
	Uint32								Level;
	Uint32								Options;};

typedef enum {
    ARP_CACHE_ANY = 		0x0,
    ARP_CACHE_DYNAMIC = 	0x1,
    ARP_CACHE_STATIC_ONLY = 	0x2,
    ARP_CACHE_SPOOF = 		0x4,
    ARP_CACHE_FORCE_BIND = 	0x8,
    ARP_CACHE_MODE_MAX
} ArpCacheMode;

typedef enum {
    HBEAT_MODE_L2_ARP	=	0x1,
    HBEAT_MODE_L2_LQM	=       0x2,
    HBEAT_MODE_L3_ICMP  =       0x4,
    HBEAT_MODE_L4_DNS   =       0x8,
    HBEAT_MODE_L4_HTTP  =      0x10,
    HBEAT_MODE_L4_SMTP  =      0x20,
    HBEAT_MODE_L4_POP3  =      0x40,
    HBEAT_MODE_L4_FTP   =      0x60,
    HBEAT_MODE_L4_TELNET  =    0x80
} HeartBeatMode;

typedef enum _icmp_pkt_send_method {
        ICMP_IP_SEND         = 0x1,  /* depend on ip route */
        ICMP_IF_OUTPUT       = 0x2   /* bypass ip routing table */
} HbeatIcmpSendMode;

typedef enum _macREDType {
	RED_RXBPS 	= 0x1,
	RED_TXBPS	= 0x2,
	RED_RXPPS	= 0x4,
	RED_TXPPS	= 0x8
} MAC_RED_TYPE;

typedef struct hbeat_prof {
  HeartBeatMode		hbeatMode;
  HbeatIcmpSendMode	hbeatIcmp;
} HbeatProfile;

    /* This file contains the internal representation of the slot profile
     * (MIB_PROF_SLOT). The name of this profile is stored in the global
     * variable mibProfSlot.
     */

extern const char* const		mibProfSlot;


# if ( MDF_ETHERNET == FYES )
extern const MibFieldEnumParams		etherIFParams;
extern const MibFieldEnumParams		ipxFrameTypeParams;

extern const MibFieldComplexParams	EtherSlotxProfileParams;


#  if ( MDF_IP == FYES )
extern const MibFieldEnumParams		proxyModeParams;
extern const MibFieldEnumParams		ripPolicyParams;
#  endif /* ( MDF_IP == FYES ) */
# endif /* ( MDF_ETHERNET == FYES ) */


# if ( (MDF_IPX_ROUTE == FYES) && (PLATFORM & (P25 | P50 | PDSL) ))
    /* Maximum number of SAP proxy servers supported.
     */
#  define MAX_SAP_PROXY_NETS              3
# endif

# define IP_RD_TC_COND	(( MDF_IP == FYES ) &&				\
			( MDF_RADIUS == FYES || MDF_TACACS == FYES ||   \
			  MDF_SECURID == FYES || MDF_DEFENDER == FYES ))

# define IP_RD_TC_C_COND	(( MDF_IP == FYES ) &&				 \
			( MDF_RADIUS == FYES || MDF_TACACS == FYES ||    \
			  MDF_SECURID == FYES || MDF_DEFENDER == FYES ) && \
			( MDF_CLID == FYES ))

# define RADIUS_COND	(( MDF_IP == FYES ) &&				 \
			( MDF_RADIUS == FYES || MDF_TACACS == FYES ||	 \
			  MDF_SECURID == FYES || MDF_DEFENDER == FYES ) && \
			( RADIUS_ACCT == FYES ))

# define TERMSVR_COND	(( MDF_IP == FYES ) &&	   \
			( MDF_TERMSRV == FYES ) && \
			( MDF_ASYNC == FYES ))

# define CALL_LOG_COND	(( MDF_IP == FYES ) &&				 \
			( MDF_RADIUS == FYES ) && ( RADIUS_ACCT == FYES ) && \
                        ( RADIUS_ACCT_CALL_LOG == FYES ))

# if ( ( MDF_ETHERNET == FYES ) || ( MDF_IMODEM == FYES ) )
    /*
     * The maximum size of an answer number in an ethernet profile
     */
#  define MAX_ETHER_ANS_NUMBER	MAX_PHONE_NUMBER_LENGTH

    /* maximum number of NVRAM based assign address pools */
#  if ( MDF_MIBMGR == FYES )
#   define MAX_NVRAM_ASSIGN_POOL	128
#  else
#   define MAX_NVRAM_ASSIGN_POOL	10
#  endif
# endif

# if (( MDF_SNMP == FYES ) && ( MDF_ETHERNET == FYES ))
    /*
     * Maximum number of hosts that are allowed SNMP access.
     *
     */
#  define MAX_SNMP_ACCESS_HOST		5

# endif

# if ( MDF_ARAP == FYES || MDF_APPLE_ROUTE == FYES )
    /*
     * Maximum length of the default zone Name.
     */
#  define MAX_ZONE_NAME_LENGTH            32

    /*
     * Maximum number of Zone Names this router can seed.
     */
#  if ( PLATFORM & ( MPORT | M200 ))
#   if ( PLATFORM & P220 )
#    define MAX_SEED_ZONE_NAMES		10
#   else
#    define MAX_SEED_ZONE_NAMES		32
#   endif /* P220 */
#  else
#   define MAX_SEED_ZONE_NAMES		10
#  endif /* PLATFORM */
# endif /* ARAP */

# if ( MDF_STACKING == FYES )
    /*
     * Maximum length of the Stack Name.
     */
#  define MAX_STACK_NAME_LENGTH            16
# endif /* STACKING */


      /*
       * This constant defines the number of line number to NT server
       * assignments we support.  It's currently set to 4 since our box
       * supports up to 4 lines max.
       */
# if ( PLATFORM & M800 )
#  define MAX_PPTP_SERVERS		8
# else
#  define MAX_PPTP_SERVERS		4
# endif

      /*
       * This constant defines the number of line number to LNS's
       * assignments we support.  It's currently set to 4 since our box
       * supports up to 4 lines max.
       */
# if ( PLATFORM & M800 )
#  define MAX_L2TP_SERVERS		8
# else
#  define MAX_L2TP_SERVERS		4
# endif


# if ( MDF_BOOTP_RELAY == FYES )
    	/*
	 * This constant is the number of BOOTP servers we can
	 * support in BOOTP Relay Mode.
	 */
#  define MAX_BOOTP_SERVERS		2
# endif


# if PLATFORM & ( M200 )
    /*
     * Maximum length of the manufacturers modem name in a PC CARD modem
     */
#  define MAX_MODEM_NAME		31

    /*
     * Maximum length of a modem strings to send to a PC CARD modem
     */
#  define MAX_MODEM_INIT_STRING	63
#  define MAX_MODEM_SPKR_STRING	15
#  define MAX_MODEM_DIAL_STRING	31
#  if (LMODEM_TSDIALOUT == FYES)
#   define MAX_MODEM_DIALOUT_INIT	31
#  endif
# endif	/* PLATFORM & M200 */

#if ( RADIUS == FYES )
        /*
         * Enumeration of the types of refresh that might be selected.
         * Note that some of them are conditionalized.  Usually,
         * conditionalizing an enum is a poor practice since it causes
         * the same number to mean different things on different loads.
         * In this case, we do it so that the numeric menu items, which
         * have no significance outside the displayed menu, will be
         * numbered consecutively on all loads.
         */
typedef enum en_radius_load_config {
    RAD_REFRESH_NONE = 		0x0,
    RAD_REFRESH_ROUTES =	0x1,
    RAD_REFRESH_POOLS =		0x2,
    RAD_REFRESH_NAILED =	0x4,
# if ( ASYNC == FYES )
    RAD_REFRESH_TERMSRV =	0x8,
# endif
# if ( SOURCE_AUTH == FYES )
    RAD_REFRESH_SOURCE =	0x10,
# endif
    RAD_REFRESH_BRIDGE =	0x20,
    RAD_REFRESH_ANS =		0x40,
    RAD_REFRESH_ALL = 		0x0FFFFFFFL,
    RAD_REFRESH_MAX = 		0xFFFFFFFFL
} radiusRefreshType;
# endif

# if ( MDF_RADIUS_SERV == FYES )
#  define MAX_RAD_CLIENTS		9
# endif

    /*
     * SlotProfileHeader:
     *
     * All slot profiles use this structure as header.
     *
     *  name
     *
     *  slotCardType
     */
typedef struct SlotProfileHeader {
#line 250 "mibslot.mdf"
//  Byte                                name[ MAX_NAME_LEN + 1 ];
    char				name[MAX_PROFILE_NAME_LENGTH+1];
    Boolean				active;
#line 253 "mibslot.mdf"
    SlotCardType                        slotCardType;
}
#if ( USERIF & CLI )
__PACK__
#endif
SlotProfileHeader;

    /*
     * GenericSlotProfile:
     *
     * This is the generic slot profile; just the header.
     *
     *  header The name and type of profile.
     */
typedef struct GenericSlotProfile {
#line 295 "mibslot.mdf"
    SlotProfileHeader                   header;
}
#if ( USERIF & CLI )
__PACK__
#endif
GenericSlotProfile;

    /*
     * DualPortMode:
     *
     * Ports may be combined for dual port use. This is a compatibility mode
     * for dialing TAs or other non-inverse muxes. Dual mode settings vary
     * depending upon the type of unit, two port or four port. The options are:
     *
     *  DUAL_NONE All ports are independent.
     *
     *  DUAL_1_2 Ports 1 and 2 make up a dual port pair. This is only allowed
     *                                  on two port units. This is also the
     *                                  value allowed on MPORT dual cards.
     *
     *  DUAL_1_3 Ports 1 and 3 make up a dual port pair.
     *
     *  DUAL_2_4 Ports 2 and 4 make up a dual port pair.
     *
     *  DUAL_DUAL Ports 1 and 3 make up one pair, ports 2 and 4 another pair.
     *
     *  DUAL_3_4 Ports 3 and 4 make up a dual port pair.
     *
     *  NUMBER_OF_DUAL_MODES
     */
typedef enum DualPortMode {
#line 331 "mibslot.mdf"
    DUAL_NONE,
#line 334 "mibslot.mdf"
    DUAL_1_2,
#line 338 "mibslot.mdf"
    DUAL_1_3,
#line 341 "mibslot.mdf"
    DUAL_2_4,
#line 344 "mibslot.mdf"
    DUAL_DUAL,
#line 347 "mibslot.mdf"
    DUAL_3_4,
#line 350 "mibslot.mdf"
    NUMBER_OF_DUAL_MODES
} DualPortMode;


static __inline__ Bool
validDualPortMode (int x)
{
    switch (x) {
#line 331 "mibslot.mdf"
    case DUAL_NONE:
#line 334 "mibslot.mdf"
    case DUAL_1_2:
#line 338 "mibslot.mdf"
    case DUAL_1_3:
#line 341 "mibslot.mdf"
    case DUAL_2_4:
#line 344 "mibslot.mdf"
    case DUAL_DUAL:
#line 347 "mibslot.mdf"
    case DUAL_3_4:
#line 350 "mibslot.mdf"
    case NUMBER_OF_DUAL_MODES:
        return TRUE;
    default:
        return FALSE;
    }
}

    /*
     * DualAIMSlotProfile:
     *
     * On multiport systems, some of the information contained in the system
     * profile on smaller systems is contained in the slot profile for the
     * MPORT. NOTE THAT THIS PROFILE IS FOR DUAL-AIM SLOT CARDS. DIFFERENT
     * PROFILES ARE STORED FOR DIFFERENT TYPES OF CARDS IN THE SYSTEM. The slot
     * profile contains the following information:
     *
     *  header The name and type of profile.
     *
     *  dualPortMode Specifies whether the ports on a dual-port slot-card are
     *                                  paired or not.
     *
     *  portSpecificPalmtop This boolean is TRUE if the palmtop on the
     *                                  interface is associated with the
     *                                  relative port specified in the next
     *                                  field.
     *
     *  userPort The relative port number of the host port assigned to the
     *                                  palmtop. Ignored when
     *                                  portSpecificPalmtop is FALSE.
     *
     *  menus The type of user interface for this port. USER_MIF is not
     *                                  allowed.
     */
typedef struct dualAIMSlotProfile {
#line 380 "mibslot.mdf"
    SlotProfileHeader                   header;
#line 384 "mibslot.mdf"
    DualPortMode                        dualPortMode;
#line 389 "mibslot.mdf"
    Boolean                             portSpecificPalmtop;
#line 394 "mibslot.mdf"
    RelativePortNumber                  userPort;
#line 399 "mibslot.mdf"
    MenuType                            menus;
}
#if ( USERIF & CLI )
__PACK__
#endif
DualAIMSlotProfile;

    /*
     * AIM6SlotProfile:
     *
     * The slot profile for the AIMSLOT/6 is just whether each pair of ports is
     * actually paired. If so, the boolean is TRUE; otherwise it is FALSE. Note
     * that there is no palmtop, so that does not have to be considered.
     *
     *  header The name and type of profile.
     *
     *  port1And2Dual
     *
     *  port3And4Dual
     *
     *  port5And6Dual
     */
typedef struct aim6SlotProfile {
#line 433 "mibslot.mdf"
    SlotProfileHeader                   header;
#line 437 "mibslot.mdf"
    Boolean                             port1And2Dual;
#line 440 "mibslot.mdf"
    Boolean                             port3And4Dual;
#line 443 "mibslot.mdf"
    Boolean                             port5And6Dual;
}
#if ( USERIF & CLI )
__PACK__
#endif
AIM6SlotProfile;

    /*
     * SwanActivation:
     *
     * This enumeration indicates which style of activation should be used.
     *
     *  SWAN_ACT_STATIC
     *
     *  SWAN_ACT_DSR
     *
     *  SWAN_ACT_DSR_RI
     *
     *  SWAN_ACT_DSR_CD
     */

#if ( MDF_SERIAL_WAN == FYES )

typedef enum SwanActivation {
#line 475 "mibslot.mdf"
    SWAN_ACT_STATIC,
#line 476 "mibslot.mdf"
    SWAN_ACT_DSR,
#line 477 "mibslot.mdf"
    SWAN_ACT_DSR_RI,
#line 478 "mibslot.mdf"
    SWAN_ACT_DSR_CD
} SwanActivation;

#endif /* ( MDF_SERIAL_WAN == FYES ) */

#if ( MDF_SERIAL_WAN == FYES )



static __inline__ Bool
validSwanActivation (int x)
{
    switch (x) {
#line 475 "mibslot.mdf"
    case SWAN_ACT_STATIC:
#line 476 "mibslot.mdf"
    case SWAN_ACT_DSR:
#line 477 "mibslot.mdf"
    case SWAN_ACT_DSR_RI:
#line 478 "mibslot.mdf"
    case SWAN_ACT_DSR_CD:
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* ( MDF_SERIAL_WAN == FYES ) */

    /*
     * SwanDataMode:
     *
     * This enumeration indicates which type of data transmission should be
     * used.
     *
     *  SWAN_DATA_MODE
     *
     *  SWAN_VOICE_MODE
     */

#if ( MDF_SERIAL_WAN == FYES )

typedef enum SwanDataMode {
#line 508 "mibslot.mdf"
    SWAN_DATA_MODE,
#line 509 "mibslot.mdf"
    SWAN_VOICE_MODE
} SwanDataMode;

#endif /* ( MDF_SERIAL_WAN == FYES ) */

#if ( MDF_SERIAL_WAN == FYES )



static __inline__ Bool
validSwanDataMode (int x)
{
    switch (x) {
#line 508 "mibslot.mdf"
    case SWAN_DATA_MODE:
#line 509 "mibslot.mdf"
    case SWAN_VOICE_MODE:
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* ( MDF_SERIAL_WAN == FYES ) */

    /*
     * SwanLineTermination:
     *
     * This enumeration indicates how the hardware should be terminated.
     *
     *  SWAN_V35_TERM
     *
     *  SWAN_RS449_TERM
     *
     *  SWAN_X21_TERM
     */

#if ( MDF_SERIAL_WAN == FYES ) && ( MDF_SWAN_LINE_TERMINATION == FYES )

typedef enum SwanLineTermination {
#line 539 "mibslot.mdf"
    SWAN_V35_TERM,
#line 540 "mibslot.mdf"
    SWAN_RS449_TERM,
#line 541 "mibslot.mdf"
    SWAN_X21_TERM
} SwanLineTermination;

#endif /* ( MDF_SERIAL_WAN == FYES ) && ( MDF_SWAN_LINE_TERMINATION == FYES ) */

#if ( MDF_SERIAL_WAN == FYES ) && ( MDF_SWAN_LINE_TERMINATION == FYES )



static __inline__ Bool
validSwanLineTermination (int x)
{
    switch (x) {
#line 539 "mibslot.mdf"
    case SWAN_V35_TERM:
#line 540 "mibslot.mdf"
    case SWAN_RS449_TERM:
#line 541 "mibslot.mdf"
    case SWAN_X21_TERM:
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* ( MDF_SERIAL_WAN == FYES ) && ( MDF_SWAN_LINE_TERMINATION == FYES ) */

    /*
     * SwanLocationMode:
     *
     * This enumeration indicates if NSV unit is PBX side or remote
     *
     *  SWAN_REMOTE_MODE
     *
     *  SWAN_SWITCH_MODE
     */

#if ( MDF_SERIAL_WAN == FYES )

typedef enum SwanLocationMode {
#line 572 "mibslot.mdf"
    SWAN_REMOTE_MODE,
#line 573 "mibslot.mdf"
    SWAN_SWITCH_MODE
} SwanLocationMode;

#endif /* ( MDF_SERIAL_WAN == FYES ) */

#if ( MDF_SERIAL_WAN == FYES )



static __inline__ Bool
validSwanLocationMode (int x)
{
    switch (x) {
#line 572 "mibslot.mdf"
    case SWAN_REMOTE_MODE:
#line 573 "mibslot.mdf"
    case SWAN_SWITCH_MODE:
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* ( MDF_SERIAL_WAN == FYES ) */

    /*
     * SerialWanSlotProfile:
     *
     * The slot profile for the serial WAN slot card is not defined at this
     * point.
     *
     *  header The name and type of profile.
     *
     *  nailedUpGroup
     *
     *  activation
     *
     *  dataMode
     *
     *  phoneNumber The phone number dialed for a NORTEL Voice Call.
     *
     *  callTimeOut
     *
     *  locationMode
     *
     *  lineTermination
     *
     *  externalClockSpeed
     */

#if ( MDF_SERIAL_WAN == FYES )

typedef struct serialWanSlotProfile {
#line 604 "mibslot.mdf"
    SlotProfileHeader                   header;
#line 608 "mibslot.mdf"
    Uint16                              nailedUpGroup;
#line 611 "mibslot.mdf"
    SwanActivation                      activation;
#line 614 "mibslot.mdf"
    SwanDataMode                        dataMode;
#line 617 "mibslot.mdf"
    char                                phoneNumber[ MAX_PHONE_NUMBER_LENGTH+2 ];
#line 621 "mibslot.mdf"
    Word                                callTimeOut;
#line 624 "mibslot.mdf"
    SwanLocationMode                    locationMode;
#line 627 "mibslot.mdf"
#if ( MDF_SWAN_LINE_TERMINATION == FYES )
    SwanLineTermination                 lineTermination;
#endif /* ( MDF_SWAN_LINE_TERMINATION == FYES ) */
#line 631 "mibslot.mdf"
    Uint16                              externalClockSpeed;
}
#if ( USERIF & CLI )
__PACK__
#endif
SerialWanSlotProfile;

#endif /* ( MDF_SERIAL_WAN == FYES ) */

    /*
     * V35Activation:
     *
     * This enumeration indicates which style of activation should be used.
     *
     *  V35_ACT_STATIC
     *
     *  V35_ACT_DPR
     *
     *  V35_ACT_CRQ
     *
     *  V35_ACT_RTS
     *
     *  V35_ACT_CRQ_RTS
     *
     *  V35_ACT_DPR_CRQ_RTS
     *
     *  V35_ACT_DISABLED
     */

#if ( MDF_V35 == FYES )

typedef enum V35Activation {
#line 673 "mibslot.mdf"
    V35_ACT_STATIC,
#line 674 "mibslot.mdf"
    V35_ACT_DPR,
#line 675 "mibslot.mdf"
    V35_ACT_CRQ,
#line 676 "mibslot.mdf"
    V35_ACT_RTS,
#line 677 "mibslot.mdf"
    V35_ACT_CRQ_RTS,
#line 678 "mibslot.mdf"
    V35_ACT_DPR_CRQ_RTS,
#line 679 "mibslot.mdf"
    V35_ACT_DISABLED
} V35Activation;

#endif /* ( MDF_V35 == FYES ) */

#if ( MDF_V35 == FYES )



static __inline__ Bool
validV35Activation (int x)
{
    switch (x) {
#line 673 "mibslot.mdf"
    case V35_ACT_STATIC:
#line 674 "mibslot.mdf"
    case V35_ACT_DPR:
#line 675 "mibslot.mdf"
    case V35_ACT_CRQ:
#line 676 "mibslot.mdf"
    case V35_ACT_RTS:
#line 677 "mibslot.mdf"
    case V35_ACT_CRQ_RTS:
#line 678 "mibslot.mdf"
    case V35_ACT_DPR_CRQ_RTS:
#line 679 "mibslot.mdf"
    case V35_ACT_DISABLED:
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* ( MDF_V35 == FYES ) */

    /*
     * V35SlotProfile:
     *
     * The slot profile for the V35 slot.
     *
     *  header The name and type of profile.
     *
     *  nailedUpGroup
     *
     *  activation
     */

#if ( MDF_V35 == FYES )

typedef struct v35SlotProfile {
#line 707 "mibslot.mdf"
    SlotProfileHeader                   header;
#line 711 "mibslot.mdf"
    Uint16                              nailedUpGroup;
#line 714 "mibslot.mdf"
    V35Activation                       activation;
}
#if ( USERIF & CLI )
__PACK__
#endif
V35SlotProfile;

#endif /* ( MDF_V35 == FYES ) */

    /*
     * Nailed56Activation:
     *
     * The enable mode for the primary nailed 56 slot.
     *
     *  N56_ACT_ENABLED
     *
     *  N56_ACT_DISABLED
     */

#if ( MDF_PRIMARY_NAILED_56 == FYES )

typedef enum Nailed56Activation {
#line 755 "mibslot.mdf"
    N56_ACT_ENABLED,
#line 756 "mibslot.mdf"
    N56_ACT_DISABLED
} Nailed56Activation;

#endif /* ( MDF_PRIMARY_NAILED_56 == FYES ) */

#if ( MDF_PRIMARY_NAILED_56 == FYES )



static __inline__ Bool
validNailed56Activation (int x)
{
    switch (x) {
#line 755 "mibslot.mdf"
    case N56_ACT_ENABLED:
#line 756 "mibslot.mdf"
    case N56_ACT_DISABLED:
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* ( MDF_PRIMARY_NAILED_56 == FYES ) */

    /*
     * Nailed56LoopMode:
     *
     * The enable for loop back for the primary nailed 56 slot.
     *
     *  N56_RELAY_CLOSED
     *
     *  N56_RELAY_OPEN
     */

#if ( MDF_PRIMARY_NAILED_56 == FYES )

typedef enum Nailed56LoopMode {
#line 783 "mibslot.mdf"
    N56_RELAY_CLOSED,
#line 784 "mibslot.mdf"
    N56_RELAY_OPEN
} Nailed56LoopMode;

#endif /* ( MDF_PRIMARY_NAILED_56 == FYES ) */

#if ( MDF_PRIMARY_NAILED_56 == FYES )



static __inline__ Bool
validNailed56LoopMode (int x)
{
    switch (x) {
#line 783 "mibslot.mdf"
    case N56_RELAY_CLOSED:
#line 784 "mibslot.mdf"
    case N56_RELAY_OPEN:
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* ( MDF_PRIMARY_NAILED_56 == FYES ) */

    /*
     * Nailed56SlotProfile:
     *
     * The slot profile for the primary nailed 56 slot.
     *
     *  header The name and type of profile.
     *
     *  nailedUpGroup
     *
     *  activation
     *
     *  loopMode
     */

#if ( MDF_PRIMARY_NAILED_56 == FYES )

typedef struct nailed56SlotProfile {
#line 813 "mibslot.mdf"
    SlotProfileHeader                   header;
#line 817 "mibslot.mdf"
    Uint16                              nailedUpGroup;
#line 820 "mibslot.mdf"
    Nailed56Activation                  activation;
#line 823 "mibslot.mdf"
    Nailed56LoopMode                    loopMode;
}
#if ( USERIF & CLI )
__PACK__
#endif
Nailed56SlotProfile;

#endif /* ( MDF_PRIMARY_NAILED_56 == FYES ) */

    /*
     * NailedT1Activation:
     *
     * The enable mode for the primary nailed T1 slot.
     *
     *  NT1_ACT_ENABLED
     *
     *  NT1_ACT_DISABLED
     */

#if ( MDF_PRIMARY_NAILED_T1 == FYES )

typedef enum NailedT1Activation {
#line 858 "mibslot.mdf"
    NT1_ACT_ENABLED,
#line 859 "mibslot.mdf"
    NT1_ACT_DISABLED
} NailedT1Activation;

#endif /* ( MDF_PRIMARY_NAILED_T1 == FYES ) */

#if ( MDF_PRIMARY_NAILED_T1 == FYES )



static __inline__ Bool
validNailedT1Activation (int x)
{
    switch (x) {
#line 858 "mibslot.mdf"
    case NT1_ACT_ENABLED:
#line 859 "mibslot.mdf"
    case NT1_ACT_DISABLED:
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* ( MDF_PRIMARY_NAILED_T1 == FYES ) */

    /*
     * NailedT1LineType:
     *
     * The enable mode for the primary nailed T1 slot.
     *
     *  NT1_ESF_ENABLED
     *
     *  NT1_DS4_ENABLED
     */

#if ( MDF_PRIMARY_NAILED_T1 == FYES )

typedef enum NailedT1LineType {
#line 895 "mibslot.mdf"
    NT1_ESF_ENABLED,
#line 896 "mibslot.mdf"
    NT1_DS4_ENABLED
} NailedT1LineType;

#endif /* ( MDF_PRIMARY_NAILED_T1 == FYES ) */

#if ( MDF_PRIMARY_NAILED_T1 == FYES )



static __inline__ Bool
validNailedT1LineType (int x)
{
    switch (x) {
#line 895 "mibslot.mdf"
    case NT1_ESF_ENABLED:
#line 896 "mibslot.mdf"
    case NT1_DS4_ENABLED:
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* ( MDF_PRIMARY_NAILED_T1 == FYES ) */

    /*
     * NailedT1EncodeType:
     *
     * The enable mode for the primary nailed T1 slot.
     *
     *  NT1_AMI_ENABLED
     *
     *  NT1_B8ZS_ENABLED
     */

#if ( MDF_PRIMARY_NAILED_T1 == FYES )

typedef enum NailedT1EncodeType {
#line 923 "mibslot.mdf"
    NT1_AMI_ENABLED,
#line 924 "mibslot.mdf"
    NT1_B8ZS_ENABLED
} NailedT1EncodeType;

#endif /* ( MDF_PRIMARY_NAILED_T1 == FYES ) */

#if ( MDF_PRIMARY_NAILED_T1 == FYES )



static __inline__ Bool
validNailedT1EncodeType (int x)
{
    switch (x) {
#line 923 "mibslot.mdf"
    case NT1_AMI_ENABLED:
#line 924 "mibslot.mdf"
    case NT1_B8ZS_ENABLED:
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* ( MDF_PRIMARY_NAILED_T1 == FYES ) */

    /*
     * NailedT1FdlType:
     *
     * The mode for the primary nailed T1 slot FDL .
     *
     *  NT1_FDL_NONE
     *
     *  NT1_FDL_ATT
     *
     *  NT1_FDL_ANSI
     *
     *  NT1_FDL_SPRINT
     */

#if ( MDF_PRIMARY_NAILED_T1 == FYES )

typedef enum NailedT1FdlType {
#line 953 "mibslot.mdf"
    NT1_FDL_NONE,
#line 954 "mibslot.mdf"
    NT1_FDL_ATT,
#line 955 "mibslot.mdf"
    NT1_FDL_ANSI,
#line 956 "mibslot.mdf"
    NT1_FDL_SPRINT
} NailedT1FdlType;

#endif /* ( MDF_PRIMARY_NAILED_T1 == FYES ) */

#if ( MDF_PRIMARY_NAILED_T1 == FYES )



static __inline__ Bool
validNailedT1FdlType (int x)
{
    switch (x) {
#line 953 "mibslot.mdf"
    case NT1_FDL_NONE:
#line 954 "mibslot.mdf"
    case NT1_FDL_ATT:
#line 955 "mibslot.mdf"
    case NT1_FDL_ANSI:
#line 956 "mibslot.mdf"
    case NT1_FDL_SPRINT:
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* ( MDF_PRIMARY_NAILED_T1 == FYES ) */

    /*
     * NailedT1BuildOut:
     *
     * The build out parameters for the primary nailed T1 slot.
     *
     *  NT1_LBO_0_DB
     *
     *  NT1_LBO_7_5_DB
     *
     *  NT1_LBO_15_0_DB
     *
     *  NT1_LBO_22_5_DB
     */

#if ( MDF_PRIMARY_NAILED_T1 == FYES )

typedef enum NailedT1BuildOut {
#line 984 "mibslot.mdf"
    NT1_LBO_0_DB,
#line 985 "mibslot.mdf"
    NT1_LBO_7_5_DB,
#line 986 "mibslot.mdf"
    NT1_LBO_15_0_DB,
#line 987 "mibslot.mdf"
    NT1_LBO_22_5_DB
} NailedT1BuildOut;

#endif /* ( MDF_PRIMARY_NAILED_T1 == FYES ) */

#if ( MDF_PRIMARY_NAILED_T1 == FYES )



static __inline__ Bool
validNailedT1BuildOut (int x)
{
    switch (x) {
#line 984 "mibslot.mdf"
    case NT1_LBO_0_DB:
#line 985 "mibslot.mdf"
    case NT1_LBO_7_5_DB:
#line 986 "mibslot.mdf"
    case NT1_LBO_15_0_DB:
#line 987 "mibslot.mdf"
    case NT1_LBO_22_5_DB:
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* ( MDF_PRIMARY_NAILED_T1 == FYES ) */

    /*
     * NailedT1LoopMode:
     *
     * The enable for loop back for the primary nailed T1 slot.
     *
     *  NT1_LOOP_NORMAL
     *
     *  NT1_RELAY_LOOP
     *
     *  NT1_LINE_LOOP
     *
     *  NT1_DATA_LOOP
     */

#if ( MDF_PRIMARY_NAILED_T1 == FYES )

typedef enum NailedT1LoopMode {
#line 1014 "mibslot.mdf"
    NT1_LOOP_NORMAL,
#line 1015 "mibslot.mdf"
    NT1_RELAY_LOOP,
#line 1016 "mibslot.mdf"
    NT1_LINE_LOOP,
#line 1017 "mibslot.mdf"
    NT1_DATA_LOOP
} NailedT1LoopMode;

#endif /* ( MDF_PRIMARY_NAILED_T1 == FYES ) */

#if ( MDF_PRIMARY_NAILED_T1 == FYES )



static __inline__ Bool
validNailedT1LoopMode (int x)
{
    switch (x) {
#line 1014 "mibslot.mdf"
    case NT1_LOOP_NORMAL:
#line 1015 "mibslot.mdf"
    case NT1_RELAY_LOOP:
#line 1016 "mibslot.mdf"
    case NT1_LINE_LOOP:
#line 1017 "mibslot.mdf"
    case NT1_DATA_LOOP:
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* ( MDF_PRIMARY_NAILED_T1 == FYES ) */

    /*
     * NailedT1ClockMode:
     *
     * The filed for local/network TX clock for primary nailed T1 slot.
     *
     *  NT1_CLOCK_LOCAL
     *
     *  NT1_CLOCK_NETWORK
     */

#if ( MDF_PRIMARY_NAILED_T1 == FYES )

typedef enum NailedT1ClockMode {
#line 1044 "mibslot.mdf"
    NT1_CLOCK_LOCAL,
#line 1045 "mibslot.mdf"
    NT1_CLOCK_NETWORK
} NailedT1ClockMode;

#endif /* ( MDF_PRIMARY_NAILED_T1 == FYES ) */

#if ( MDF_PRIMARY_NAILED_T1 == FYES )



static __inline__ Bool
validNailedT1ClockMode (int x)
{
    switch (x) {
#line 1044 "mibslot.mdf"
    case NT1_CLOCK_LOCAL:
#line 1045 "mibslot.mdf"
    case NT1_CLOCK_NETWORK:
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* ( MDF_PRIMARY_NAILED_T1 == FYES ) */

    /*
     * NailedT1SlotProfile:
     *
     * The slot profile for the primary nailed T1 slot.
     *
     *  header The name and type of profile.
     *
     *  nailedUpGroup
     *
     *  nailedFirstChannel
     *
     *  nailedLastChannel
     *
     *  activation
     *
     *  nailedLineType
     *
     *  nailedEncodeType
     *
     *  nailedBuildOut
     *
     *  loopMode
     *
     *  nailedFdlType
     *
     *  clockMode
     */

#if ( MDF_PRIMARY_NAILED_T1 == FYES )

typedef struct nailedT1SlotProfile {
#line 1075 "mibslot.mdf"
    SlotProfileHeader                   header;
#line 1079 "mibslot.mdf"
    Uint16                              nailedUpGroup;
#line 1082 "mibslot.mdf"
    Word                                nailedFirstChannel;
#line 1085 "mibslot.mdf"
    Word                                nailedLastChannel;
#line 1088 "mibslot.mdf"
    NailedT1Activation                  activation;
#line 1091 "mibslot.mdf"
    NailedT1LineType                    nailedLineType;
#line 1094 "mibslot.mdf"
    NailedT1EncodeType                  nailedEncodeType;
#line 1097 "mibslot.mdf"
    NailedT1BuildOut                    nailedBuildOut;
#line 1100 "mibslot.mdf"
    NailedT1LoopMode                    loopMode;
#line 1103 "mibslot.mdf"
    NailedT1FdlType                     nailedFdlType;
#line 1106 "mibslot.mdf"
    NailedT1ClockMode                   clockMode;
}
#if ( USERIF & CLI )
__PACK__
#endif
NailedT1SlotProfile;

#endif /* ( MDF_PRIMARY_NAILED_T1 == FYES ) */

    /*
     * SerialE1DSX_T1SignalingType:
     *
     * The various types of signaling (i.e. in-band and out of band) are
     * enumerated below. Note that array _signalingMode in lcdnet.c must be
     * changed when this enumeration is changed.
     *
     *  SE1DSX_T1_INBAND_SIGNALING Inband, robbed bit signaling. The actual
     *                                  signaling mode used can be found in the
     *                                  robbed bit mode signaling field.
     *
     *  SE1DSX_T1_PRI_SIGNALING ISDN signaling, with local D-channel.
     *
     *  SE1DSX_T1_PRI_NFAS_SIGNALING ISDN signaling, with multiple physical
     *                                  lines sharing a D-channel.
     *
     *  SE1DSX_T1_PBX_SIGNALING Note: ;;; this should be set up as a cond = (
     *                                  MDF_NET_2_NET_PBX == FYES ) but the
     *                                  value is referenced in code that is not
     *                                  conditionalized yet and I need to
     *                                  change this NOW and the files that need
     *                                  to be changed are locked by others who
     *                                  are probably not working this weekend.
     *                                  Thus, I am penalized by our code
     *                                  management system for trying to get
     *                                  something done. SCCS sucks. Since I
     *                                  can't fix it right I'll tell the TNT
     *                                  code that it is an internal value so it
     *                                  won't be displayed.
     *
     *  SE1DSX_E1_R2_SIGNALING
     *
     *  SE1DSX_E1_KOREAN_SIGNALING
     *
     *  SE1DSX_E1_P7_SIGNALING
     *
     *  SE1DSX_E1_CHINESE_SIGNALING
     *
     *  SE1DSX_E1_METERED_SIGNALING
     *
     *  SE1DSX_E1_NO_SIGNALING
     *
     *  SE1DSX_E1_DPNSS_SIGNALING
     *
     *  SE1DSX_NUMBER_OF_SIGNALLING_TYPES
     */

#if (( PLATFORM & P220 ) && ( NETIF & E1 ))

typedef enum SerialE1DSX_T1SignalingType {
#line 1142 "mibslot.mdf"
    SE1DSX_T1_INBAND_SIGNALING,
#line 1146 "mibslot.mdf"
    SE1DSX_T1_PRI_SIGNALING,
#line 1149 "mibslot.mdf"
    SE1DSX_T1_PRI_NFAS_SIGNALING,
#line 1153 "mibslot.mdf"
    SE1DSX_T1_PBX_SIGNALING,
#line 1165 "mibslot.mdf"
    SE1DSX_E1_R2_SIGNALING,
#line 1167 "mibslot.mdf"
    SE1DSX_E1_KOREAN_SIGNALING,
#line 1169 "mibslot.mdf"
    SE1DSX_E1_P7_SIGNALING,
#line 1171 "mibslot.mdf"
    SE1DSX_E1_CHINESE_SIGNALING,
#line 1173 "mibslot.mdf"
    SE1DSX_E1_METERED_SIGNALING,
#line 1175 "mibslot.mdf"
    SE1DSX_E1_NO_SIGNALING,
#line 1177 "mibslot.mdf"
    SE1DSX_E1_DPNSS_SIGNALING,
#line 1179 "mibslot.mdf"
    SE1DSX_NUMBER_OF_SIGNALLING_TYPES
} SerialE1DSX_T1SignalingType;

#endif /* (( PLATFORM & P220 ) && ( NETIF & E1 )) */

#if (( PLATFORM & P220 ) && ( NETIF & E1 ))



static __inline__ Bool
validSerialE1DSX_T1SignalingType (int x)
{
    switch (x) {
#line 1142 "mibslot.mdf"
    case SE1DSX_T1_INBAND_SIGNALING:
#line 1146 "mibslot.mdf"
    case SE1DSX_T1_PRI_SIGNALING:
#line 1149 "mibslot.mdf"
    case SE1DSX_T1_PRI_NFAS_SIGNALING:
#line 1153 "mibslot.mdf"
    case SE1DSX_T1_PBX_SIGNALING:
#line 1165 "mibslot.mdf"
    case SE1DSX_E1_R2_SIGNALING:
#line 1167 "mibslot.mdf"
    case SE1DSX_E1_KOREAN_SIGNALING:
#line 1169 "mibslot.mdf"
    case SE1DSX_E1_P7_SIGNALING:
#line 1171 "mibslot.mdf"
    case SE1DSX_E1_CHINESE_SIGNALING:
#line 1173 "mibslot.mdf"
    case SE1DSX_E1_METERED_SIGNALING:
#line 1175 "mibslot.mdf"
    case SE1DSX_E1_NO_SIGNALING:
#line 1177 "mibslot.mdf"
    case SE1DSX_E1_DPNSS_SIGNALING:
#line 1179 "mibslot.mdf"
    case SE1DSX_NUMBER_OF_SIGNALLING_TYPES:
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* (( PLATFORM & P220 ) && ( NETIF & E1 )) */

    /*
     * SerialT1CSU_Activation:
     *
     * The enable mode for the serial T1 CSU slot.
     *
     *  ST1CSU_ACT_ENABLED
     *
     *  ST1CSU_ACT_DISABLED
     */

#if ( PLATFORM & ( M2000 | P220 ) )

typedef enum SerialT1CSU_Activation {
#line 1190 "mibslot.mdf"
    ST1CSU_ACT_ENABLED,
#line 1191 "mibslot.mdf"
    ST1CSU_ACT_DISABLED
} SerialT1CSU_Activation;

#endif /* ( PLATFORM & ( M2000 | P220 ) ) */

#if ( PLATFORM & ( M2000 | P220 ) )



static __inline__ Bool
validSerialT1CSU_Activation (int x)
{
    switch (x) {
#line 1190 "mibslot.mdf"
    case ST1CSU_ACT_ENABLED:
#line 1191 "mibslot.mdf"
    case ST1CSU_ACT_DISABLED:
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* ( PLATFORM & ( M2000 | P220 ) ) */

    /*
     * SerialT1CSU_LineType:
     *
     * The enable mode for the serial T1 CSU slot.
     *
     *  ST1CSU_ESF_ENABLED
     *
     *  ST1CSU_DS4_ENABLED
     */

#if ( PLATFORM & ( M2000 | P220 ) )

typedef enum SerialT1CSU_LineType {
#line 1218 "mibslot.mdf"
    ST1CSU_ESF_ENABLED,
#line 1219 "mibslot.mdf"
    ST1CSU_DS4_ENABLED
} SerialT1CSU_LineType;

#endif /* ( PLATFORM & ( M2000 | P220 ) ) */

#if ( PLATFORM & ( M2000 | P220 ) )



static __inline__ Bool
validSerialT1CSU_LineType (int x)
{
    switch (x) {
#line 1218 "mibslot.mdf"
    case ST1CSU_ESF_ENABLED:
#line 1219 "mibslot.mdf"
    case ST1CSU_DS4_ENABLED:
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* ( PLATFORM & ( M2000 | P220 ) ) */

    /*
     * SerialT1CSU_EncodeType:
     *
     * The enable mode for the serial T1 CSU slot.
     *
     *  ST1CSU_AMI_ENABLED
     *
     *  ST1CSU_B8ZS_ENABLED
     */

#if ( PLATFORM & ( M2000 | P220 ) )

typedef enum SerialT1CSU_EncodeType {
#line 1246 "mibslot.mdf"
    ST1CSU_AMI_ENABLED,
#line 1247 "mibslot.mdf"
    ST1CSU_B8ZS_ENABLED
} SerialT1CSU_EncodeType;

#endif /* ( PLATFORM & ( M2000 | P220 ) ) */

#if ( PLATFORM & ( M2000 | P220 ) )



static __inline__ Bool
validSerialT1CSU_EncodeType (int x)
{
    switch (x) {
#line 1246 "mibslot.mdf"
    case ST1CSU_AMI_ENABLED:
#line 1247 "mibslot.mdf"
    case ST1CSU_B8ZS_ENABLED:
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* ( PLATFORM & ( M2000 | P220 ) ) */

    /*
     * SerialT1CSU_BuildOut:
     *
     * The build out parameters for the serial T1 CSU slot.
     *
     *  ST1CSU_LBO_0_DB
     *
     *  ST1CSU_LBO_0_6_DB
     *
     *  ST1CSU_LBO_1_2_DB
     *
     *  ST1CSU_LBO_1_8_DB
     *
     *  ST1CSU_LBO_2_4_DB
     *
     *  ST1CSU_LBO_3_0_DB
     *
     *  ST1CSU_LBO_7_5_DB
     *
     *  ST1CSU_LBO_15_0_DB
     *
     *  ST1CSU_LBO_22_5_DB
     */

#if ( PLATFORM & ( M2000 | P220 ) )

typedef enum SerialT1CSU_BuildOut {
#line 1276 "mibslot.mdf"
    ST1CSU_LBO_0_DB,
#line 1277 "mibslot.mdf"
    ST1CSU_LBO_0_6_DB,
#line 1278 "mibslot.mdf"
    ST1CSU_LBO_1_2_DB,
#line 1279 "mibslot.mdf"
    ST1CSU_LBO_1_8_DB,
#line 1280 "mibslot.mdf"
    ST1CSU_LBO_2_4_DB,
#line 1281 "mibslot.mdf"
    ST1CSU_LBO_3_0_DB,
#line 1282 "mibslot.mdf"
    ST1CSU_LBO_7_5_DB,
#line 1283 "mibslot.mdf"
    ST1CSU_LBO_15_0_DB,
#line 1284 "mibslot.mdf"
    ST1CSU_LBO_22_5_DB
} SerialT1CSU_BuildOut;

#endif /* ( PLATFORM & ( M2000 | P220 ) ) */

#if ( PLATFORM & ( M2000 | P220 ) )



static __inline__ Bool
validSerialT1CSU_BuildOut (int x)
{
    switch (x) {
#line 1276 "mibslot.mdf"
    case ST1CSU_LBO_0_DB:
#line 1277 "mibslot.mdf"
    case ST1CSU_LBO_0_6_DB:
#line 1278 "mibslot.mdf"
    case ST1CSU_LBO_1_2_DB:
#line 1279 "mibslot.mdf"
    case ST1CSU_LBO_1_8_DB:
#line 1280 "mibslot.mdf"
    case ST1CSU_LBO_2_4_DB:
#line 1281 "mibslot.mdf"
    case ST1CSU_LBO_3_0_DB:
#line 1282 "mibslot.mdf"
    case ST1CSU_LBO_7_5_DB:
#line 1283 "mibslot.mdf"
    case ST1CSU_LBO_15_0_DB:
#line 1284 "mibslot.mdf"
    case ST1CSU_LBO_22_5_DB:
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* ( PLATFORM & ( M2000 | P220 ) ) */

    /*
     * SerialT1CSU_FDLType:
     *
     * FDLs come in several types. They are enumerated here.
     *
     *  ST1CSU_FDL_NONE
     *
     *  ST1CSU_FDL_ATT
     *
     *  ST1CSU_FDL_ANSI
     *
     *  ST1CSU_FDL_SPRINT
     */

#if ( PLATFORM & P220 )

typedef enum SerialT1CSU_FDLType {
#line 1309 "mibslot.mdf"
    ST1CSU_FDL_NONE,
#line 1310 "mibslot.mdf"
    ST1CSU_FDL_ATT,
#line 1311 "mibslot.mdf"
    ST1CSU_FDL_ANSI,
#line 1312 "mibslot.mdf"
    ST1CSU_FDL_SPRINT
} SerialT1CSU_FDLType;

#endif /* ( PLATFORM & P220 ) */

#if ( PLATFORM & P220 )



static __inline__ Bool
validSerialT1CSU_FDLType (int x)
{
    switch (x) {
#line 1309 "mibslot.mdf"
    case ST1CSU_FDL_NONE:
#line 1310 "mibslot.mdf"
    case ST1CSU_FDL_ATT:
#line 1311 "mibslot.mdf"
    case ST1CSU_FDL_ANSI:
#line 1312 "mibslot.mdf"
    case ST1CSU_FDL_SPRINT:
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* ( PLATFORM & P220 ) */

    /*
     * SerialT1CSU_SlotProfile:
     *
     * The slot profile for the serial T1 CSU slot.
     *
     *  header The name and type of profile.
     *
     *  serialT1CSU_UpGroup
     *
     *  serialT1CSU_StartChannel
     *
     *  serialT1CSU_EndChannel
     *
     *  activation
     *
     *  serialT1CSU_LineType
     *
     *  serialT1CSU_EncodeType
     *
     *  serialT1CSU_BuildOut
     *
     *  t1ClockSource
     *
     *  serialT1CSU_FDLType Who's FDL are we using.
     *
     *  serialE1DSX_SignalingType Inband, ISDN, ISDN_NFAS, or PBX signaling.
     *
     *  serialE1DSX_SwitchType The network switch type, needed for ISDN/NFAS
     *                                  signaling.
     *
     *  serialE1DSX_useChan16 Should channel 16 (signaling channel) be nailed?
     */

#if ( PLATFORM & ( M2000 | P220 ) )

typedef struct serialT1CSU_SlotProfile {
#line 1343 "mibslot.mdf"
    SlotProfileHeader                   header;
#line 1347 "mibslot.mdf"
    Word                                serialT1CSU_UpGroup;
#line 1350 "mibslot.mdf"
    Word                                serialT1CSU_StartChannel;
#line 1353 "mibslot.mdf"
    Word                                serialT1CSU_EndChannel;
#line 1356 "mibslot.mdf"
    SerialT1CSU_Activation              activation;
#line 1359 "mibslot.mdf"
    SerialT1CSU_LineType                serialT1CSU_LineType;
#line 1362 "mibslot.mdf"
#if ( ( PLATFORM & M2000 ) || ( ( PLATFORM & P220 ) && ( NETIF & T1 ) ) )
    SerialT1CSU_EncodeType              serialT1CSU_EncodeType;
#endif /* ( ( PLATFORM & M2000 ) || ( ( PLATFORM & P220 ) && ( NETIF & T1 ) ) ) */
#line 1366 "mibslot.mdf"
#if ( ( PLATFORM & M2000 ) || ( ( PLATFORM & P220 ) && ( NETIF & T1 ) ) )
    SerialT1CSU_BuildOut                serialT1CSU_BuildOut;
#endif /* ( ( PLATFORM & M2000 ) || ( ( PLATFORM & P220 ) && ( NETIF & T1 ) ) ) */
#line 1370 "mibslot.mdf"
    T1ClockSource                       t1ClockSource;
#line 1373 "mibslot.mdf"
#if ( ( PLATFORM & P220 ) && ( NETIF & T1 ) && ( MDF_FDL == FYES ) )
    SerialT1CSU_FDLType                 serialT1CSU_FDLType;
#endif /* ( ( PLATFORM & P220 ) && ( NETIF & T1 ) && ( MDF_FDL == FYES ) ) */
#line 1378 "mibslot.mdf"
#if (( PLATFORM & P220 ) && ( NETIF & E1 ) && 0 )
    SerialE1DSX_T1SignalingType         serialE1DSX_SignalingType;
#endif /* (( PLATFORM & P220 ) && ( NETIF & E1 ) && 0 ) */
#line 1383 "mibslot.mdf"
#if (( PLATFORM & P220 ) && ( NETIF & E1 ) && 0 )
    NetworkSwitchType                   serialE1DSX_SwitchType;
#endif /* (( PLATFORM & P220 ) && ( NETIF & E1 ) && 0 ) */
#line 1388 "mibslot.mdf"
#if (( PLATFORM & P220 ) && ( NETIF & E1 ))
    Boolean                             serialE1DSX_useChan16;
#endif /* (( PLATFORM & P220 ) && ( NETIF & E1 )) */
}
#if ( USERIF & CLI )
__PACK__
#endif
SerialT1CSU_SlotProfile;

#endif /* ( PLATFORM & ( M2000 | P220 ) ) */

    /*
     * DualHostSlotProfile:
     *
     * On PLUS systems we fake the system out by treating the host interface as
     * being a slot card, too. A pseudo slot card. There are two types defined,
     * DualHostSlotProfile and QuadHostSlotProfile. Both have a dual port mode,
     * although the values that can be applied are different. The
     * QuadHostSlotProfile has 3 palmtop use booleans. 1 for the main palmtop,
     * and 2 for the palmtop ports on the host port daughter card.
     *
     *  header The name and type of profile.
     *
     *  dualPortMode
     *
     *  portSpecificPalmtop
     *
     *  userPort
     *
     *  menus
     */
typedef struct dualHostSlotProfile {
#line 1430 "mibslot.mdf"
    SlotProfileHeader                   header;
#line 1434 "mibslot.mdf"
    DualPortMode                        dualPortMode;
#line 1437 "mibslot.mdf"
    Boolean                             portSpecificPalmtop;
#line 1440 "mibslot.mdf"
    RelativePortNumber                  userPort;
#line 1443 "mibslot.mdf"
    MenuType                            menus;
}
#if ( USERIF & CLI )
__PACK__
#endif
DualHostSlotProfile;

    /*
     * QuadHostSlotProfile:
     *
     * On PLUS systems we fake the system out by treating the host interface as
     * being a slot card, too. A pseudo slot card. There are two types defined,
     * DualHostSlotProfile and QuadHostSlotProfile. Both have a dual port mode,
     * although the values that can be applied are different. The
     * QuadHostSlotProfile has 3 palmtop use booleans. 1 for the main palmtop,
     * and 2 for the palmtop ports on the host port daughter card.
     *
     *  header The name and type of profile.
     *
     *  dualPortMode
     *
     *  palmtop0
     *
     *  userPort0
     *
     *  menus0
     *
     *  palmtop1
     *
     *  userPort1
     *
     *  menus1
     *
     *  palmtop2
     *
     *  userPort2
     *
     *  menus2
     */
typedef struct quadHostSlotProfile {
#line 1480 "mibslot.mdf"
    SlotProfileHeader                   header;
#line 1484 "mibslot.mdf"
    DualPortMode                        dualPortMode;
#line 1487 "mibslot.mdf"
    Boolean                             palmtop0;
#line 1490 "mibslot.mdf"
    RelativePortNumber                  userPort0;
#line 1493 "mibslot.mdf"
    MenuType                            menus0;
#line 1496 "mibslot.mdf"
    Boolean                             palmtop1;
#line 1499 "mibslot.mdf"
    RelativePortNumber                  userPort1;
#line 1502 "mibslot.mdf"
    MenuType                            menus1;
#line 1505 "mibslot.mdf"
    Boolean                             palmtop2;
#line 1508 "mibslot.mdf"
    RelativePortNumber                  userPort2;
#line 1511 "mibslot.mdf"
    MenuType                            menus2;
}
#if ( USERIF & CLI )
__PACK__
#endif
QuadHostSlotProfile;

    /*
     * AuthType:
     *
     * Authentication types supported by the Pipeline:
     *
     *  AUTH_NONE
     *
     *  AUTH_TACACS
     *
     *  AUTH_RADIUS
     *
     *  AUTH_RADIUS_LOGOUT
     *
     *  AUTH_SECURID
     *
     *  AUTH_TACACS_PLUS
     *
     *  AUTH_DEFENDER
     */

#if (( MDF_ETHERNET == FYES ) && ( MDF_IP == FYES ))

typedef enum AuthType {
#line 1543 "mibslot.mdf"
    AUTH_NONE = 0,
#line 1544 "mibslot.mdf"
#if (MDF_TACACS == FYES)
    AUTH_TACACS = 1,
#endif /* (MDF_TACACS == FYES) */
#line 1546 "mibslot.mdf"
#if (MDF_RADIUS == FYES)
    AUTH_RADIUS = 2,
#endif /* (MDF_RADIUS == FYES) */
#line 1548 "mibslot.mdf"
#if (MDF_RADIUS == FYES)
    AUTH_RADIUS_LOGOUT = 3,
#endif /* (MDF_RADIUS == FYES) */
#line 1550 "mibslot.mdf"
#if (MDF_SECURID == FYES)
    AUTH_SECURID = 4,
#endif /* (MDF_SECURID == FYES) */
#line 1552 "mibslot.mdf"
#if (MDF_TACACSPLUS == FYES)
    AUTH_TACACS_PLUS = 5,
#endif /* (MDF_TACACSPLUS == FYES) */
#line 1554 "mibslot.mdf"
#if (MDF_DEFENDER == FYES)
    AUTH_DEFENDER = 6
#endif /* (MDF_DEFENDER == FYES) */
} AuthType;

#endif /* (( MDF_ETHERNET == FYES ) && ( MDF_IP == FYES )) */

#if (( MDF_ETHERNET == FYES ) && ( MDF_IP == FYES ))



static __inline__ Bool
validAuthType (int x)
{
    switch (x) {
#line 1543 "mibslot.mdf"
    case AUTH_NONE:
#line 1544 "mibslot.mdf"
#if (MDF_TACACS == FYES)
    case AUTH_TACACS:
#endif /* (MDF_TACACS == FYES) */
#line 1546 "mibslot.mdf"
#if (MDF_RADIUS == FYES)
    case AUTH_RADIUS:
#endif /* (MDF_RADIUS == FYES) */
#line 1548 "mibslot.mdf"
#if (MDF_RADIUS == FYES)
    case AUTH_RADIUS_LOGOUT:
#endif /* (MDF_RADIUS == FYES) */
#line 1550 "mibslot.mdf"
#if (MDF_SECURID == FYES)
    case AUTH_SECURID:
#endif /* (MDF_SECURID == FYES) */
#line 1552 "mibslot.mdf"
#if (MDF_TACACSPLUS == FYES)
    case AUTH_TACACS_PLUS:
#endif /* (MDF_TACACSPLUS == FYES) */
#line 1554 "mibslot.mdf"
#if (MDF_DEFENDER == FYES)
    case AUTH_DEFENDER:
#endif /* (MDF_DEFENDER == FYES) */
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* (( MDF_ETHERNET == FYES ) && ( MDF_IP == FYES )) */

    /*
     * RadIdSpace:
     *
     * The Radius id field is a sequence number which identifies a particular
     * packet; this field is common to both Authentication and Accounting
     * packets. This enumeration controls whether the sequence number spaces
     * are the same for both authentication and accounting, or separate.
     *
     *  RAD_UNIFIED_ID_SPACE Radius auth and acct packets share the same id
     *                                  sequence space and so a total of 256
     *                                  auth/acct packets may be sent before
     *                                  the id sequence rolls over. This is the
     *                                  default behaviour.
     *
     *  RAD_DISTINCT_ID_SPACE Radius auth and acct packets do not share the
     *                                  same id sequence space and so a total
     *                                  of 256 auth packets may be sent before
     *                                  the auth id sequence rolls over, and,
     *                                  completely separate from the auth id
     *                                  sequence roll-over, 256 acct packets
     *                                  may be sent before the acct id sequence
     *                                  rolls over. If this option is selected
     *                                  then the Radius server must be careful
     *                                  to discriminate on either the Radius
     *                                  code field, or the destination port, or
     *                                  both, to determine if Radius packet
     *                                  collision has occurred.
     */

#if ( !Q_TNT && ( MDF_RADIUS == FYES ) )

typedef enum RadIdSpace {
#line 1568 "mibslot.mdf"
    RAD_UNIFIED_ID_SPACE = 0,
#line 1574 "mibslot.mdf"
    RAD_DISTINCT_ID_SPACE = 1
} RadIdSpace;

#endif /* ( !Q_TNT && ( MDF_RADIUS == FYES ) ) */

#if ( !Q_TNT && ( MDF_RADIUS == FYES ) )



static __inline__ Bool
validRadIdSpace (int x)
{
    switch (x) {
#line 1568 "mibslot.mdf"
    case RAD_UNIFIED_ID_SPACE:
#line 1574 "mibslot.mdf"
    case RAD_DISTINCT_ID_SPACE:
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* ( !Q_TNT && ( MDF_RADIUS == FYES ) ) */

    /*
     * AuthLpfType:
     *
     * LocalProfileFirst types supported by the MAX:
     *
     *  AUTH_LPF_NO
     *
     *  AUTH_LPF_YES
     *
     *  AUTH_LPF_RNO
     */
typedef enum AuthLpfType {
#line 1591 "mibslot.mdf"
    AUTH_LPF_NO,
#line 1592 "mibslot.mdf"
    AUTH_LPF_YES,
#line 1593 "mibslot.mdf"
    AUTH_LPF_RNO
} AuthLpfType;


static __inline__ Bool
validAuthLpfType (int x)
{
    switch (x) {
#line 1591 "mibslot.mdf"
    case AUTH_LPF_NO:
#line 1592 "mibslot.mdf"
    case AUTH_LPF_YES:
#line 1593 "mibslot.mdf"
    case AUTH_LPF_RNO:
        return TRUE;
    default:
        return FALSE;
    }
}
#line 1595 "mibslot.mdf"

# if ( USERIF & CLI )

    /*
     * Enumerated values for the AuthType field.
     */
extern const MibFieldEnumParams	authTypeParams;
extern const MibFieldEnumParams	authLpfTypeParams;

# endif /* USERIF & CLI */

#line 1609 "mibslot.mdf"

# if ( USERIF & CLI )

    /*
     * Enumerated values for the AcctBaseType field.
     */
extern const MibFieldEnumParams	acctBaseTypeParams;

# endif /* USERIF & CLI */


    /*
     * AcctType:
     *
     * Accounting types supported by the Pipeline:
     *
     *  ACCT_NONE
     *
     *  ACCT_RADIUS
     *
     *  ACCT_TACACSPLUS
     */

#if (( MDF_ETHERNET == FYES ) && ( MDF_IP == FYES ))

typedef enum AcctType {
#line 1655 "mibslot.mdf"
    ACCT_NONE,
#line 1657 "mibslot.mdf"
    ACCT_RADIUS,
#line 1659 "mibslot.mdf"
#if (MDF_TACACSPLUS_ACCT == FYES)
    ACCT_TACACSPLUS
#endif /* (MDF_TACACSPLUS_ACCT == FYES) */
} AcctType;

#endif /* (( MDF_ETHERNET == FYES ) && ( MDF_IP == FYES )) */

#if (( MDF_ETHERNET == FYES ) && ( MDF_IP == FYES ))



static __inline__ Bool
validAcctType (int x)
{
    switch (x) {
#line 1655 "mibslot.mdf"
    case ACCT_NONE:
#line 1657 "mibslot.mdf"
    case ACCT_RADIUS:
#line 1659 "mibslot.mdf"
#if (MDF_TACACSPLUS_ACCT == FYES)
    case ACCT_TACACSPLUS:
#endif /* (MDF_TACACSPLUS_ACCT == FYES) */
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* (( MDF_ETHERNET == FYES ) && ( MDF_IP == FYES )) */
#line 1664 "mibslot.mdf"

# if ( USERIF & CLI )

    /*
     * Enumerated values for the AcctType field.
     */
extern const MibFieldEnumParams	acctTypeParams;

# endif /* USERIF & CLI */


    /*
     * AcctBaseType:
     *
     * Base Type to be used for reporting accounting ID
     *
     *  ACCT_BASE_10
     *
     *  ACCT_BASE_16
     */

#if (( MDF_ETHERNET == FYES ) && ( MDF_IP == FYES ))

typedef enum AcctBaseType {
#line 1700 "mibslot.mdf"
    ACCT_BASE_10,
#line 1701 "mibslot.mdf"
    ACCT_BASE_16
} AcctBaseType;

#endif /* (( MDF_ETHERNET == FYES ) && ( MDF_IP == FYES )) */

#if (( MDF_ETHERNET == FYES ) && ( MDF_IP == FYES ))



static __inline__ Bool
validAcctBaseType (int x)
{
    switch (x) {
#line 1700 "mibslot.mdf"
    case ACCT_BASE_10:
#line 1701 "mibslot.mdf"
    case ACCT_BASE_16:
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* (( MDF_ETHERNET == FYES ) && ( MDF_IP == FYES )) */

    /*
     * RipPolicy:
     *
     * How RIP sends routes back to their interface of origin.
     *
     *  RIP_POLICY_SPLIT_HORIZON Don't send them.
     *
     *  RIP_POLICY_POISON_REVERSE Send them as dead routes.
     */

#if (( MDF_ETHERNET == FYES ) && ( MDF_IP == FYES ))

typedef enum RipPolicy {
#line 1728 "mibslot.mdf"
    RIP_POLICY_SPLIT_HORIZON,
#line 1731 "mibslot.mdf"
    RIP_POLICY_POISON_REVERSE
} RipPolicy;

#endif /* (( MDF_ETHERNET == FYES ) && ( MDF_IP == FYES )) */

#if (( MDF_ETHERNET == FYES ) && ( MDF_IP == FYES ))



static __inline__ Bool
validRipPolicy (int x)
{
    switch (x) {
#line 1728 "mibslot.mdf"
    case RIP_POLICY_SPLIT_HORIZON:
#line 1731 "mibslot.mdf"
    case RIP_POLICY_POISON_REVERSE:
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* (( MDF_ETHERNET == FYES ) && ( MDF_IP == FYES )) */

    /*
     * ProxyMode:
     *
     * Proxy ARP may be supported in various ways, so define an enumeration for
     * the various modes.
     *
     *  PROXY_OFF Do not proxy any address.
     *
     *  PROXY_CALL_ACTIVE Only proxy for active connections.
     *
     *  PROXY_CALL_INACTIVE Only proxy for inactive connections.
     *
     *  PROXY_ALWAYS Alway proxy all addresses.
     *
     *  PROXY_NAT Only proxy nat static routes.
     */

#if (( MDF_ETHERNET == FYES ) && ( MDF_IP == FYES ))

typedef enum ProxyMode {
#line 1761 "mibslot.mdf"
    PROXY_OFF,
#line 1764 "mibslot.mdf"
    PROXY_CALL_ACTIVE,
#line 1767 "mibslot.mdf"
    PROXY_CALL_INACTIVE,
#line 1770 "mibslot.mdf"
    PROXY_ALWAYS,
    PROXY_NAT
} ProxyMode;

#endif /* (( MDF_ETHERNET == FYES ) && ( MDF_IP == FYES )) */

#if (( MDF_ETHERNET == FYES ) && ( MDF_IP == FYES ))



static __inline__ Bool
validProxyMode (int x)
{
    switch (x) {
#line 1761 "mibslot.mdf"
    case PROXY_OFF:
#line 1764 "mibslot.mdf"
    case PROXY_CALL_ACTIVE:
#line 1767 "mibslot.mdf"
    case PROXY_CALL_INACTIVE:
#line 1770 "mibslot.mdf"
    case PROXY_ALWAYS:
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* (( MDF_ETHERNET == FYES ) && ( MDF_IP == FYES )) */

    /*
     * EtherIF:
     *
     * Ethernet interface types. Determines which physical interface is used.
     *
     *  AUI
     *
     *  COAX
     *
     *  UTP
     */

#if ( MDF_ETHERNET == FYES )

typedef enum EtherIF {
#line 1800 "mibslot.mdf"
    AUI,
#line 1801 "mibslot.mdf"
    COAX,
#line 1802 "mibslot.mdf"
    UTP
} EtherIF;

#endif /* ( MDF_ETHERNET == FYES ) */

#if ( MDF_ETHERNET == FYES )



static __inline__ Bool
validEtherIF (int x)
{
    switch (x) {
#line 1800 "mibslot.mdf"
    case AUI:
#line 1801 "mibslot.mdf"
    case COAX:
#line 1802 "mibslot.mdf"
    case UTP:
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* ( MDF_ETHERNET == FYES ) */

    /*
     * IpxFrameType:
     *
     * IPX encapsulation types:
     *
     *  IPX_FRAME_NONE Not an IPX packet or no IPX support.
     *
     *  IPX_FRAME_802_3 802.3 'Raw' implementation. The LLC header is missing.
     *
     *  IPX_FRAME_802_2 802.3 LLC Type 1 encapsulation.
     *
     *  IPX_FRAME_SNAP SNAP header encapsulation.
     *
     *  IPX_FRAME_ENET2 Good 'ol Ethernet II type field.
     */

#if ( ( MDF_ETHERNET == FYES ) || ( MDF_IMODEM == FYES ) )

typedef enum IpxFrameType {
#line 1829 "mibslot.mdf"
    IPX_FRAME_NONE = 0,
#line 1832 "mibslot.mdf"
    IPX_FRAME_802_3,
#line 1835 "mibslot.mdf"
    IPX_FRAME_802_2,
#line 1838 "mibslot.mdf"
    IPX_FRAME_SNAP,
#line 1841 "mibslot.mdf"
    IPX_FRAME_ENET2
} IpxFrameType;

#endif /* ( ( MDF_ETHERNET == FYES ) || ( MDF_IMODEM == FYES ) ) */

#if ( ( MDF_ETHERNET == FYES ) || ( MDF_IMODEM == FYES ) )



static __inline__ Bool
validIpxFrameType (int x)
{
    switch (x) {
#line 1829 "mibslot.mdf"
    case IPX_FRAME_NONE:
#line 1832 "mibslot.mdf"
    case IPX_FRAME_802_3:
#line 1835 "mibslot.mdf"
    case IPX_FRAME_802_2:
#line 1838 "mibslot.mdf"
    case IPX_FRAME_SNAP:
#line 1841 "mibslot.mdf"
    case IPX_FRAME_ENET2:
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* ( ( MDF_ETHERNET == FYES ) || ( MDF_IMODEM == FYES ) ) */

    /*
     * PhoneUsage:
     *
     * The various combinations for phone number/SPID associations with a
     * physical POTS interface on a POTS slot. This can be expanded if more
     * than three SPIDs/phone numbers need to be supported per DSL...
     *
     *  SPID_NONE
     *
     *  SPID_A
     *
     *  SPID_B
     *
     *  SPID_C
     *
     *  SPID_A_AND_B
     *
     *  SPID_A_AND_C
     *
     *  SPID_B_AND_C
     *
     *  SPID_A_31K_AUDIO
     *
     *  SPID_B_31K_AUDIO
     */

#if (( MDF_POTS == FYES ))

typedef enum PhoneUsage {
#line 1880 "mibslot.mdf"
    SPID_NONE,
#line 1881 "mibslot.mdf"
    SPID_A,
#line 1882 "mibslot.mdf"
    SPID_B,
#line 1883 "mibslot.mdf"
    SPID_C,
#line 1884 "mibslot.mdf"
    SPID_A_AND_B,
#line 1885 "mibslot.mdf"
    SPID_A_AND_C,
#line 1886 "mibslot.mdf"
    SPID_B_AND_C,
#line 1887 "mibslot.mdf"
    SPID_A_31K_AUDIO,
#line 1888 "mibslot.mdf"
    SPID_B_31K_AUDIO
} PhoneUsage;

#endif /* (( MDF_POTS == FYES )) */

#if (( MDF_POTS == FYES ))



static __inline__ Bool
validPhoneUsage (int x)
{
    switch (x) {
#line 1880 "mibslot.mdf"
    case SPID_NONE:
#line 1881 "mibslot.mdf"
    case SPID_A:
#line 1882 "mibslot.mdf"
    case SPID_B:
#line 1883 "mibslot.mdf"
    case SPID_C:
#line 1884 "mibslot.mdf"
    case SPID_A_AND_B:
#line 1885 "mibslot.mdf"
    case SPID_A_AND_C:
#line 1886 "mibslot.mdf"
    case SPID_B_AND_C:
#line 1887 "mibslot.mdf"
    case SPID_A_31K_AUDIO:
#line 1888 "mibslot.mdf"
    case SPID_B_31K_AUDIO:
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* (( MDF_POTS == FYES )) */

    /*
     * InfoXferCapability:
     *
     * Phone Information Transfer Capability type associated with a physical
     * POTS interface on a POTS slot.
     *
     *  INFO_XFER_CAP_SPEECH the device connected to a physical POTS interface
     *                                  is a telephone and should use Speech
     *                                  bearer capablility
     *
     *  INFO_XFER_CAP_AUDIO the device connected to p hysical POTS interface is
     *                                  not a telephone and should use 3.1K
     *                                  audio bearer capability
     */

#if (( MDF_POTS == FYES ))

typedef enum InfoXferCapability {
#line 1900 "mibslot.mdf"
    INFO_XFER_CAP_SPEECH,
#line 1903 "mibslot.mdf"
    INFO_XFER_CAP_AUDIO
} InfoXferCapability;

#endif /* (( MDF_POTS == FYES )) */

#if (( MDF_POTS == FYES ))



static __inline__ Bool
validInfoXferCapability (int x)
{
    switch (x) {
#line 1900 "mibslot.mdf"
    case INFO_XFER_CAP_SPEECH:
#line 1903 "mibslot.mdf"
    case INFO_XFER_CAP_AUDIO:
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* (( MDF_POTS == FYES )) */

    /*
     * NatLan:
     *
     * The NAT Lan parameter. This is only relevant if NAT is enable for both
     * NAT_LAN and NAPT_LAN
     *
     *  NATLAN_SINGLE_IP NAT Lan is configure as single IP address NAT.
     *
     *  NATLAN_MULTI_IP NAT Lan is configure as multi IP address NAT.
     */

#if ( MDF_ETHERNET == FYES )

typedef enum NatLan {
#line 1933 "mibslot.mdf"
    NATLAN_SINGLE_IP = 0,
#line 1936 "mibslot.mdf"
    NATLAN_MULTI_IP
} NatLan;

#endif /* ( MDF_ETHERNET == FYES ) */

#if ( MDF_ETHERNET == FYES )



static __inline__ Bool
validNatLan (int x)
{
    switch (x) {
#line 1933 "mibslot.mdf"
    case NATLAN_SINGLE_IP:
#line 1936 "mibslot.mdf"
    case NATLAN_MULTI_IP:
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* ( MDF_ETHERNET == FYES ) */

    /*
     * VtpAgentMode:
     *
     * VTP Modes:
     *
     *  VTP_DISABLED Don't support VTP protocol.
     *
     *  VTP_HOME_AGENT This box is configured to be a home agent.
     *
     *  VTP_FOREIGN_AGENT This box is configured to be a foreign agent.
     *
     *  VTP_HOME_AND_FOREIGN_AGENT This box is configured to be both a home
     *                                  agent and a foreign agent and a tunnel
     *                                  by tunnel basis.
     */

#if (( MDF_ETHERNET == FYES ) && ( MDF_VTP == FYES ))

typedef enum VtpAgentMode {
#line 1965 "mibslot.mdf"
    VTP_DISABLED = 0,
#line 1968 "mibslot.mdf"
    VTP_HOME_AGENT,
#line 1971 "mibslot.mdf"
    VTP_FOREIGN_AGENT,
#line 1974 "mibslot.mdf"
    VTP_HOME_AND_FOREIGN_AGENT
} VtpAgentMode;

#endif /* (( MDF_ETHERNET == FYES ) && ( MDF_VTP == FYES )) */

#if (( MDF_ETHERNET == FYES ) && ( MDF_VTP == FYES ))



static __inline__ Bool
validVtpAgentMode (int x)
{
    switch (x) {
#line 1965 "mibslot.mdf"
    case VTP_DISABLED:
#line 1968 "mibslot.mdf"
    case VTP_HOME_AGENT:
#line 1971 "mibslot.mdf"
    case VTP_FOREIGN_AGENT:
#line 1974 "mibslot.mdf"
    case VTP_HOME_AND_FOREIGN_AGENT:
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* (( MDF_ETHERNET == FYES ) && ( MDF_VTP == FYES )) */

    /*
     * VtpHomeAgentType:
     *
     * The VTP Home Agent Type. This is only relavent if the agent is configued
     * to be a Home Agent.
     *
     *  VTP_HOME_AGENT_ROUTER This Home agent is a router.
     *
     *  VTP_HOME_AGENT_GATEWAY This Home Agent delivers tunneled data to other
     *                                  networks without routing anything.
     */

#if (( MDF_ETHERNET == FYES ) && ( MDF_VTP == FYES ))

typedef enum VtpHomeAgentType {
#line 1987 "mibslot.mdf"
    VTP_HOME_AGENT_ROUTER = 0,
#line 1990 "mibslot.mdf"
    VTP_HOME_AGENT_GATEWAY
} VtpHomeAgentType;

#endif /* (( MDF_ETHERNET == FYES ) && ( MDF_VTP == FYES )) */

#if (( MDF_ETHERNET == FYES ) && ( MDF_VTP == FYES ))



static __inline__ Bool
validVtpHomeAgentType (int x)
{
    switch (x) {
#line 1987 "mibslot.mdf"
    case VTP_HOME_AGENT_ROUTER:
#line 1990 "mibslot.mdf"
    case VTP_HOME_AGENT_GATEWAY:
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* (( MDF_ETHERNET == FYES ) && ( MDF_VTP == FYES )) */

    /*
     * RadServAttrType:
     *
     * This enumeration indicates how a session is searched for.
     *
     *  RADIUS_SERV_ATTRIBUTE_ANY First RADIUS Attribute is the matching.
     *
     *  RADIUS_SERV_ATTRIBUTE_KEY Search for session by session key.
     *
     *  RADIUS_SERV_ATTRIBUTE_ALL All Attributes must be satisified for a
     *                                  match.
     */

#if ( MDF_RADIUS_SERV == FYES )

typedef enum RadServAttrType {
#line 2024 "mibslot.mdf"
    RADIUS_SERV_ATTRIBUTE_ANY,
#line 2027 "mibslot.mdf"
    RADIUS_SERV_ATTRIBUTE_KEY,
#line 2030 "mibslot.mdf"
    RADIUS_SERV_ATTRIBUTE_ALL
} RadServAttrType;

#endif /* ( MDF_RADIUS_SERV == FYES ) */

#if ( MDF_RADIUS_SERV == FYES )



static __inline__ Bool
validRadServAttrType (int x)
{
    switch (x) {
#line 2024 "mibslot.mdf"
    case RADIUS_SERV_ATTRIBUTE_ANY:
#line 2027 "mibslot.mdf"
    case RADIUS_SERV_ATTRIBUTE_KEY:
#line 2030 "mibslot.mdf"
    case RADIUS_SERV_ATTRIBUTE_ALL:
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* ( MDF_RADIUS_SERV == FYES ) */

    /*
     * AtlkRouteType:
     *
     * AppleTalk Router modes:
     *
     *  ATALK_ROUTER_OFF AppleTalk routing is disabled.
     *
     *  ATALK_ROUTER_SEED AppleTalk routing is seed mode.
     *
     *  ATALK_ROUTER_NON_SEED AppleTalk routing is non-seed mode.
     */

#if ( MDF_APPLE_ROUTE == FYES )

typedef enum AtlkRouteType {
#line 2042 "mibslot.mdf"
    ATALK_ROUTER_OFF,
#line 2045 "mibslot.mdf"
    ATALK_ROUTER_SEED,
#line 2048 "mibslot.mdf"
    ATALK_ROUTER_NON_SEED
} AtlkRouteType;

#endif /* ( MDF_APPLE_ROUTE == FYES ) */

#if ( MDF_APPLE_ROUTE == FYES )



static __inline__ Bool
validAtlkRouteType (int x)
{
    switch (x) {
#line 2042 "mibslot.mdf"
    case ATALK_ROUTER_OFF:
#line 2045 "mibslot.mdf"
    case ATALK_ROUTER_SEED:
#line 2048 "mibslot.mdf"
    case ATALK_ROUTER_NON_SEED:
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* ( MDF_APPLE_ROUTE == FYES ) */
#line 2052 "mibslot.mdf"

# if ( MDF_ARAP == FYES || MDF_APPLE_ROUTE == FYES )

    /*
     * Type to contain an AppleTalk zone name.
     */
typedef	char	ZoneNameType[MAX_ZONE_NAME_LENGTH + 1];


# endif

# if ( MDF_APPLE_ROUTE == FYES )
#  if ( USERIF & CLI )
    /*
     * Enumerated values for the Apple Router
     */

extern const MibFieldEnumParams atlkRouterTypeParams;
#  endif /* USERIF & CLI */

# endif /* MDF_APPLE_ROUTE */

#line 2094 "mibslot.mdf"

# if ( USERIF & CLI )

    /*
     * Enumerated values for the RADIUS Server Attribute type.
     */
extern const MibFieldEnumParams	radServAttrParams;

# endif /* USERIF & CLI */

# define POOL_NAME_LEN 10

# if ( MDF_SECURID == FYES )

/* NOTE: This size *MUST* be the same size as the Security Dynamics
 * node_secret key, a set of octets established by the Security Dynamics
 * server.  the current revision of the Security Dynamics code is
 * recorded here so we can have an "automatic check" of revision
 * compatibility.
 */
#  define SECURID_SECRETSIZE	16
#  define SECURID_REV		3

# endif


    /*
     * dialOutSecurityType:
     *
     * Defines the security mechanism used for modem outdial.
     *
     *  TSDIALOUT_SECURITY_NONE No security in place; any user can place
     *                                  outgoing calls.
     *
     *  TSDIALOUT_SECURITY_GLOBAL A single global password is used.
     *
     *  TSDIALOUT_SECURITY_USER Users can be individually given the right to
     *                                  place calls.
     */

#if ((MDF_LMODEM_TSDIALOUT == FYES) && (!(USERIF & CLI)))

typedef enum dialOutSecurityType {
#line 2147 "mibslot.mdf"
    TSDIALOUT_SECURITY_NONE,
#line 2150 "mibslot.mdf"
    TSDIALOUT_SECURITY_GLOBAL,
#line 2153 "mibslot.mdf"
    TSDIALOUT_SECURITY_USER
} dialOutSecurityType;

#endif /* ((MDF_LMODEM_TSDIALOUT == FYES) && (!(USERIF & CLI))) */

#if ((MDF_LMODEM_TSDIALOUT == FYES) && (!(USERIF & CLI)))



static __inline__ Bool
validdialOutSecurityType (int x)
{
    switch (x) {
#line 2147 "mibslot.mdf"
    case TSDIALOUT_SECURITY_NONE:
#line 2150 "mibslot.mdf"
    case TSDIALOUT_SECURITY_GLOBAL:
#line 2153 "mibslot.mdf"
    case TSDIALOUT_SECURITY_USER:
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* ((MDF_LMODEM_TSDIALOUT == FYES) && (!(USERIF & CLI))) */

    /*
     * LogCallInfo:
     *
     *
     *  LOG_CALLINFO_NONE No call info will be displayed.
     *
     *  LOG_CALLINFO_ENDOFCALL Call info will be displayed at the end of the
     *                                  call.
     */
typedef enum LogCallInfo {
#line 2159 "mibslot.mdf"
    LOG_CALLINFO_NONE,
#line 2162 "mibslot.mdf"
    LOG_CALLINFO_ENDOFCALL,
    LOG_NAT_OUT,
    LOG_NAT_IN,
    LOG_NAT_BOTH
} LogCallInfo;


static __inline__ Bool
validLogCallInfo (int x)
{
    switch (x) {
#line 2159 "mibslot.mdf"
    case LOG_CALLINFO_NONE:
#line 2162 "mibslot.mdf"
    case LOG_CALLINFO_ENDOFCALL:
    case LOG_NAT_OUT:
    case LOG_NAT_IN:
    case LOG_NAT_BOTH:
        return TRUE;
    default:
        return FALSE;
    }
}

    /*
     * L2TunnelType:
     *
     * This enumeration indicates the Layer 2 tunnel protocol to be used when
     * communicating with the tunnel server. -- Currently, it is only used here
     * in mibslot.mdf (MAX/Pipe). -- All other occurrances are translated into
     * 'TunnelingProtocol'. *** DO NOT USE THIS ENUMERATION! Use
     * 'TunnelingProtocol' instead! ***
     *
     *  L2_TUNNEL_NONE Disabled.
     *
     *  L2_TUNNEL_PPTP Use PPTP (Point-to-Point Tunneling Protocol).
     *
     *  L2_TUNNEL_L2TP Use L2TP (Layer 2 Tunneling Protocol).
     */
typedef enum L2TunnelType {
#line 2186 "mibslot.mdf"
    L2_TUNNEL_NONE = 0x0,
#line 2189 "mibslot.mdf"

#if ( MDF_PPTP == FYES )
    L2_TUNNEL_PPTP = 0x1,
#endif /* ( MDF_PPTP == FYES ) */

#line 2193 "mibslot.mdf"

#if ( MDF_L2TP == FYES )
    L2_TUNNEL_L2TP = 0x2,
#endif /* ( MDF_L2TP == FYES ) */

#if (( MDF_L2TP == FYES ) && ( MDF_PPTP == FYES ))
    L2_TUNNEL_ANY = (L2_TUNNEL_PPTP|L2_TUNNEL_L2TP),
#endif /* ( MDF_L2TP == FYES ) */
//  L2_TUNNEL_ANY = L2_TUNNEL_L2TP,
// #error "both l2tp & pptp must be enabled"
} L2TunnelType;


static __inline__ Bool
validL2TunnelType (int x)
{
    switch (x) {
#line 2186 "mibslot.mdf"
    case L2_TUNNEL_NONE:
#line 2189 "mibslot.mdf"
#if ( MDF_PPTP == FYES )
    case L2_TUNNEL_PPTP:
#endif /* ( MDF_PPTP == FYES ) */
#line 2193 "mibslot.mdf"
#if ( MDF_L2TP == FYES )
    case L2_TUNNEL_L2TP:
#endif /* ( MDF_L2TP == FYES ) */
#if (( MDF_L2TP == FYES ) && ( MDF_PPTP == FYES ))
    case L2_TUNNEL_ANY:
        return TRUE;
# endif
    default:
        return FALSE;
    }
}

    /*
     * TelnetSecurity:
     *
     * Telnet security levels:
     *
     *  TELNET_SECURITY_NONE Disable telnet security.
     *
     *  TELNET_SECURITY_GLOBAL Only require password, use default security
     *                                  profile.
     *
     *  TELNET_SECURITY_PROFILE Require name and password.
     */
typedef enum TelnetSecurity {
#line 2219 "mibslot.mdf"
    TELNET_SECURITY_NONE,
#line 2222 "mibslot.mdf"
    TELNET_SECURITY_GLOBAL,
#line 2225 "mibslot.mdf"
    TELNET_SECURITY_PROFILE
} TelnetSecurity;


static __inline__ Bool
validTelnetSecurity (int x)
{
    switch (x) {
#line 2219 "mibslot.mdf"
    case TELNET_SECURITY_NONE:
#line 2222 "mibslot.mdf"
    case TELNET_SECURITY_GLOBAL:
#line 2225 "mibslot.mdf"
    case TELNET_SECURITY_PROFILE:
        return TRUE;
    default:
        return FALSE;
    }
}

    /*
     * RadiusCompatType:
     *
     * RADIUS compatibility modes:
     *
     *  RAD_COMPAT_OLD
     *
     *  RAD_COMPAT_VSA
     */

#if (( MDF_ETHERNET == FYES ) && ( MDF_IP == FYES ))

typedef enum RadiusCompatType {
#line 2253 "mibslot.mdf"
    RAD_COMPAT_OLD = 0,
#line 2255 "mibslot.mdf"
    RAD_COMPAT_VSA = 1
} RadiusCompatType;

#endif /* (( MDF_ETHERNET == FYES ) && ( MDF_IP == FYES )) */

#if (( MDF_ETHERNET == FYES ) && ( MDF_IP == FYES ))



static __inline__ Bool
validRadiusCompatType (int x)
{
    switch (x) {
#line 2253 "mibslot.mdf"
    case RAD_COMPAT_OLD:
#line 2255 "mibslot.mdf"
    case RAD_COMPAT_VSA:
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* (( MDF_ETHERNET == FYES ) && ( MDF_IP == FYES )) */
#line 2259 "mibslot.mdf"

# if ( USERIF & CLI )

    /*
     * Enumerated values for the RadiusCompatType field.
     */
extern const MibFieldEnumParams radCompatEnum;

# endif /* USERIF & CLI */


    /*
     * RadiusKeepUserNameType:
     *
     * RADIUS Keep User Name:
     *
     *  RAD_CHANGE_NAME change name to user-name attribute in access-accept
     *
     *  RAD_KEEP_NAME do not change name to user-name attribute in
     *                                  access-accept
     *
     *  RAD_KEEP_REALM_NAME do not change name to user-name attribute in
     *                                  access-accept if name in realm
     */

#if ( MDF_RADIUS == FYES )

typedef enum RadiusKeepUserNameType {
#line 2295 "mibslot.mdf"
    RAD_CHANGE_NAME = 0,
#line 2298 "mibslot.mdf"
    RAD_KEEP_NAME = 1,
#line 2301 "mibslot.mdf"
    RAD_KEEP_REALM_NAME = 2
} RadiusKeepUserNameType;

#endif /* ( MDF_RADIUS == FYES ) */

#if ( MDF_RADIUS == FYES )



static __inline__ Bool
validRadiusKeepUserNameType (int x)
{
    switch (x) {
#line 2295 "mibslot.mdf"
    case RAD_CHANGE_NAME:
#line 2298 "mibslot.mdf"
    case RAD_KEEP_NAME:
#line 2301 "mibslot.mdf"
    case RAD_KEEP_REALM_NAME:
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* ( MDF_RADIUS == FYES ) */
#line 2307 "mibslot.mdf"

# if ( USERIF & CLI )

    /*
     * Enumerated values for the RadiusKeepUserNameType field.
     */
extern const MibFieldEnumParams radKeepUserNameEnum;

# endif /* USERIF & CLI */


    /*
     * EtherSlotxProfile:
     *
     * Ethernet slot extension profile. Contains:
     *
     *  validateIP If TRUE, we will validate the address.
     *
     *  maxNoReplyWait How long to wait for reply to our ICMP echo request.
     *
     *  groupOneCount Number of IP addresses in this group.
     *
     *  ipGroupTwo Begining IP address in this group.
     *
     *  groupTwoCount Number of IP addresses in this group.
     *
     *  ipGroupTwoNetmask Netmask for this group of IP addresses.
     *
     *  hostOneIp A specific IP address for a specific host.
     *
     *  hostOneNetmask Netmask for the specific host address.
     *
     *  hostOneAddress Ethernet address (MAC) for host with above IP address.
     *
     *  hostTwoIp A specific IP address for a specific host.
     *
     *  hostTwoNetmask Netmask for the specific host address.
     *
     *  hostTwoAddress Ethernet address (MAC) for host with above IP address.
     *
     *  hostThreeIp A specific IP address for a specific host.
     *
     *  hostThreeNetmask Netmask for the specific host address.
     *
     *  hostThreeAddress Ethernet address (MAC) for host with above IP address.
     *
     *  fingerEnable Enable Finger support.
     *
     *  logPort The remote syslogd port for messages logged from this box.
     *
     *  authResetTime The timer to reset to the primary server after it has
     *                                  failed.
     *
     *  acctResetTime The timer to reset to the primary server after it has
     *                                  failed.
     *
     *  callInfo Specifies when call status changes are logged.
     *
     *  callLogEnable Enable call log support.
     *
     *  callLogHost1 The IP address of the first (RADIUS_ACCT) call log host.
     *
     *  callLogHost2 The IP address of the second (RADIUS_ACCT) call log host.
     *
     *  callLogHost3 The IP address of the third (RADIUS_ACCT) call log host.
     *
     *  callLogPort The UDP port to use for (RADIUS_ACCT) call log accounting.
     *
     *  callLogKey The (RADIUS_ACCT) call log accounting key.
     *
     *  callLogTimeout Number of seconds to wait for a response to previous
     *                                  call log accounting request.
     *
     *  callLogIDBase The Base to use in reporting Account ID.
     *
     *  callLogResetTime The timer to reset to the primary server after it has
     *                                  failed.
     *
     *  readWriteCommunityEnable Enable read/write community string.
     *
     *  l2tpMode Configured the Layer 2 Tunneling Protocol mode.
     *
     *  l2tpPassword The password needed to bring up a L2TP Control Channel
     *                                  with this box.
     *
     *  l2TunnelType Determines whether incoming calls on the given line should
     *                                  be tunneled to a L2TP or PPTP server.
     *
     *  ipfax User config settings for IP-Fax
     *
     *  queueDepth The maximum number of SNMP packets waiting to be serviced.
     *                                  Additional packets will be dropped.
     *                                  When setting this value, you're trading
     *                                  memory resources versus SNMP retries
     *                                  (only when the box is busy and gets
     *                                  behind on servicing the SNMP packets).
     *                                  Zero indicates there is no limit.
     *
     *  ripQueueDepth The maximum number of RIP packets waiting to be serviced.
     *                                  Additional packets will be dropped.
     *                                  When setting this value, you're trading
     *                                  memory resources versus losing RIP
     *                                  updates (only when the box is busy and
     *                                  gets behind on servicing the RIP
     *                                  packets). Zero indicates there is no
     *                                  limit.
     *
     *  hostFourIp A specific IP address for a specific host.
     *
     *  hostFourNetmask Netmask for the specific host address.
     *
     *  hostFourAddress Ethernet address (MAC) for host with above IP address.
     *
     *  hostFiveIp A specific IP address for a specific host.
     *
     *  hostFiveNetmask Netmask for the specific host address.
     *
     *  hostFiveAddress Ethernet address (MAC) for host with above IP address.
     *
     *  hostSixIp A specific IP address for a specific host.
     *
     *  hostSixNetmask Netmask for the specific host address.
     *
     *  hostSixAddress Ethernet address (MAC) for host with above IP address.
     *
     *  acctCheckpoint Interval at which to send checkpoint packets to the
     *                                  daemon.
     *
     *  acctStopOnly Send to RADIUS Accounting Stop packets that have
     *                                  username=0. These are caused by
     *                                  connections that are dropped before
     *                                  authentication is done.
     *
     *  acctRetryLimit Number of retries before removing RADIUS Acct packet. 0
     *                                  means leave on retry list until maximum
     *                                  retry entries are exceeded.
     *
     *  atlkRouterB The type of AppleTalk Router to enable.
     *
     *  atlkNetStartB The start of the AppleTalk Net number range.
     *
     *  atlkNetEndB The end of the AppleTalk Net number range.
     *
     *  atlkDefaultZoneB The default zone for the AppleTalk router.
     *
     *  atlkZoneListB The Zone List for an AppleTalk seed router.
     *
     *  hintNetLoB A hint for the Appletalk low net number
     *
     *  hintNetHiB A hint for the Appletalk hi net number
     *
     *  hintNetNodeB A hint for the Appletalk node number
     *
     *  hintZoneB The default zone that the MAX will come up in.
     *
     *  callLogStopOnly Send call log Stop packets that have username=0. These
     *                                  are caused by connections that are
     *                                  dropped before authentication is done.
     *
     *  callLogRetryLimit Number of retries before removing call log packet. 0
     *                                  means leave on retry list until maximum
     *                                  retry entries are exceeded.
     *
     *  multicastGroupLeaveDelay Multicast group leave delay for IGMP version 2
     *
     *  tsCSlipAutoDetectEnabled TRUE if auto detecting of SLIP compression is
     *                                  to be enabled. This feature will try to
     *                                  auto-detect if the caller is using Van
     *                                  Jacobson header compression, and if so,
     *                                  the box will automatically switch to
     *                                  CSLIP mode.
     *
     *  greMtu The maximum IP packet size that can be transmitted to a remote
     *                                  agent without performing
     *                                  pre-fragmentation. The value 0 disables
     *                                  this feature.
     *
     *  forceFragmentation When set to NO, an ICMP message will be sent if a
     *                                  frame needs fragmentation and the DF
     *                                  bit is set. This is the standard
     *                                  behavior. When set to YES, it forces
     *                                  pre-fragmentation of large IP frames
     *                                  before they are sent to the remote
     *                                  agent, even if the frame has the DF bit
     *                                  set. This behavior is not standard and
     *                                  prevents MTU discovery mechanisms.
     *
     *  atmpIdleLimit The number of minutes of no activity before an ATMP Home
     *                                  Agent will drop a tunnel. The value 0
     *                                  disables the idle timer.
     *
     *  tsAraEnabled TRUE if terminal server users are allowed to intiate async
     *                                  ARA sessions.
     *
     *  icmpReplyDirectedBcast yes: if we want to reply directed broadcast
     *                                  ping. no: if we do not want to reply
     *                                  directed broadcast ping.
     *
     *  allowDirectedBcast yes: if we allow to forward directed broadcast
     *                                  traffic no: if we do not allow to
     *                                  foward directed broadcast traffic.
     *
     *  authIdMaxRetryTime Maximum time limit to spend retrying RADIUS servers
     *                                  when in id authentication, a value of 0
     *                                  sets the limit to the internal default
     *                                  value.
     *
     *  voip User config settings for VOIP
     *
     *  vpnMode VPN support.
     *
     *  packetAudioMode Pkt Audio Mode
     *
     *  l2tpRxWindow This value is the advertised L2TP receive windows size for
     *                                  the data channel. A value of zero
     *                                  indicate that this box is asking for no
     *                                  flow control for inbound L2TP payloads.
     *
     *  l2tpAuthEnabled Seting this value to yes will enable L2TP tunnel
     *                                  authentication.
     *
     *  localDnsTable The DNS Fallback Table.
     *
     *  noAttr6UseTermsrv Using terminal server if attribute 6 is missing from
     *                                  RADIUS authentication.
     *
     *  ripTrigger When set to TRUE (its default value) it causes RIP to send
     *                                  triggered (incremental) updates.
     *                                  Otherwise full table updates are sent
     *                                  when a change in the routing table is
     *                                  noticed.
     *
     *  tftpHostName The TFTP host name used for obtaining config data.
     *
     *  bootFilePath Complete file path to where configuration file may be
     *                                  found.
     *
     *  audioFramesPerPacket Voice Frames Per RTP Packet
     *
     *  suppressHostRoute When set to TRUE, host routes are suppressed in
     *                                  routing updates. The default value is
     *                                  FALSE, which advertise host routes as
     *                                  usual.
     *
     *  dnisEnabled Is Dnis selection enabled ?
     *
     *  dnisTab The DNIS table.
     *
     *  ospfB The user configurable settings for OSPF on the second ethernet
     *                                  interface.
     *
     *  tsRloginMaxPort An upper limit of the port number used by rlogin. For
     *                                  BSD's rlogin, the client source port
     *                                  range is 512 to 1023.
     *
     *  tsRloginMinPort An lower limit of the port number used by rlogin. For
     *                                  BSD's rlogin, the client source port
     *                                  range is 512 to 1023.
     *
     *  telnetSecurity Level of security used to authenticate telnet sessions.
     *
     *  dhcpClientEnabled	enable get ip address via dhcp server
     *
     *  dhcpClientPnpEnabled    enable microsoft dhcp pnp 
     *  dhcpClientIpAddress	saved dhcpclient address for renewing
     *  dhcpClientNetmask	saved dhcpclient netmask for renewing
     *
     *  authRadCompat Authentication RADIUS compatibility mode.
     *
     *  acctRadCompat Accounting RADIUS compatibility mode.
     *
     *  radServRadCompat RADIUS server RADIUS compatibility mode.
     *
     *  callLogRadCompat Call Logging RADIUS compatibility mode.
     *
     *  atmpSnmpTrapEnabled When set to No, do not send ATMP SNMP traps. If
     *                                  Yes, send traps. The default is No.
     *
     *  authRadKeepUserName Action if Access-Accept packet from Radius server
     *                                  contains a User-Name attribute.
     *
     *  authRadRealmDelimiters Characters that delimit a realm from user name
     *                                  for use by auth-radius-keep-user-name.
     *                                  Default is defined in mibfld.h 
     *
     *  idAuthPrefix A short text string prepended to the username portion of a
     *                                  CLID or DNIS authentication request.
     *
     *  cbq cbq parameters
     *
     *  
     *  macAddress  macAddress for this slot
     *
     */

#if ( MDF_ETHERNET == FYES )

#if (DHCP_PLUS == FYES)
typedef enum 
{    
	DHCPC_BOARDCAST = 	0x0,    
	DHCPC_UNICAST = 	0x1
} DhcpCastEnum;
#endif //(DHCP_PLUS == FYES)


#if (FC == FYES)
#if (RED == FYES)
typedef struct st_fcRedParams {
    Uint32	    redQthMinDiv;
    Uint32	    redQthMaxDiv;
    Byte	    redQAccuracy;
    Byte	    redMaxProb;
    Byte	    redQweight;
    Uint32	    redTransTime;
} fcRedParams;
#endif

typedef struct st_rlTokenBucket {
    Int		    tbInterval;
    Int		    tbDepth;
} tbParams;

typedef struct st_rlFlex {
    Int		    hosts;
    Int		    lowLevel;
    Int		    midLevel;
    Int		    highLevel;
} rlFlex;


typedef struct {
    Boolean	    enable;
    Boolean	    share;
    Uint32	    rx;
    Uint32	    tx;
    char	    exceptionIpGroupName[MAX_IPGROUP_NAME_LENGTH + 1];
} rlP2p;


#if (FC_PRIORITY == FYES)
typedef struct {
    Boolean	    enable;
    Boolean	    icmp;
    Boolean	    web;
    Boolean	    vpn;
    Boolean	    ack;
    Boolean	    game;
    Boolean	    voip;
    Boolean	    mail;
} rlNoLimit;
#endif




typedef struct st_fcRateLimitParams {
    Boolean	    enable;
    Boolean	    account;
#if (APP_TRAFFIC == FYES)
    Boolean	    l7Account;
#endif
    Boolean	    calHeader;
    Boolean	    ipOnly;
    char	    baseIf[MAX_PROFILE_NAME_LENGTH + 1];
    tbParams	    tb;
    rlFlex	    flex;
    rlP2p	    p2p;
#if (FC_PRIORITY == FYES)
    rlNoLimit	    nolimit;
#endif
} fcRateLimitParams;


#endif

typedef struct dNSResolveSwitchProfile {
    Boolean	enable;
}
#if ( USERIF & CLI )
__PACK__
#endif
DNSResolveSwitchProfile;

#if (HOTEL == FYES)

typedef struct hotelSwitchProfile {
    Boolean	enable;
}
#if ( USERIF & CLI )
__PACK__
#endif
HotelSwitchProfile;

#endif



typedef struct etherSlotxProfile {
#line 2343 "mibslot.mdf"
#if ( DHCP_SPOOF_TINY_SERVER == FYES )
    Boolean                             validateIP;
#endif /* ( DHCP_SPOOF_TINY_SERVER == FYES ) */
#line 2348 "mibslot.mdf"
#if ( DHCP_SPOOF_TINY_SERVER == FYES )
    Word                                maxNoReplyWait;
#endif /* ( DHCP_SPOOF_TINY_SERVER == FYES ) */
#line 2353 "mibslot.mdf"
#if ( DHCP_SPOOF_TINY_SERVER == FYES )
    Word                                groupOneCount;
#endif /* ( DHCP_SPOOF_TINY_SERVER == FYES ) */
#line 2358 "mibslot.mdf"
#if ( DHCP_SPOOF_TINY_SERVER == FYES )
    IpAddress                           ipGroupTwo;
#endif /* ( DHCP_SPOOF_TINY_SERVER == FYES ) */
#line 2363 "mibslot.mdf"
#if ( DHCP_SPOOF_TINY_SERVER == FYES )
    Word                                groupTwoCount;
#endif /* ( DHCP_SPOOF_TINY_SERVER == FYES ) */
#line 2368 "mibslot.mdf"
#if ( DHCP_SPOOF_TINY_SERVER == FYES )
    IpAddress                           ipGroupTwoNetmask;
#endif /* ( DHCP_SPOOF_TINY_SERVER == FYES ) */
#line 2373 "mibslot.mdf"
#if ( DHCP_SPOOF_TINY_SERVER == FYES )
    IpAddress                           hostOneIp;
#endif /* ( DHCP_SPOOF_TINY_SERVER == FYES ) */
#line 2378 "mibslot.mdf"
#if ( DHCP_SPOOF_TINY_SERVER == FYES )
    IpAddress                           hostOneNetmask;
#endif /* ( DHCP_SPOOF_TINY_SERVER == FYES ) */
#line 2383 "mibslot.mdf"
#if ( DHCP_SPOOF_TINY_SERVER == FYES )
    EtherAddress                        hostOneAddress;
#endif /* ( DHCP_SPOOF_TINY_SERVER == FYES ) */
#line 2388 "mibslot.mdf"
#if ( DHCP_SPOOF_TINY_SERVER == FYES )
    IpAddress                           hostTwoIp;
#endif /* ( DHCP_SPOOF_TINY_SERVER == FYES ) */
#line 2393 "mibslot.mdf"
#if ( DHCP_SPOOF_TINY_SERVER == FYES )
    IpAddress                           hostTwoNetmask;
#endif /* ( DHCP_SPOOF_TINY_SERVER == FYES ) */
#line 2398 "mibslot.mdf"
#if ( DHCP_SPOOF_TINY_SERVER == FYES )
    EtherAddress                        hostTwoAddress;
#endif /* ( DHCP_SPOOF_TINY_SERVER == FYES ) */
#line 2403 "mibslot.mdf"
#if ( DHCP_SPOOF_TINY_SERVER == FYES )
    IpAddress                           hostThreeIp;
#endif /* ( DHCP_SPOOF_TINY_SERVER == FYES ) */
#line 2408 "mibslot.mdf"
#if ( DHCP_SPOOF_TINY_SERVER == FYES )
    IpAddress                           hostThreeNetmask;
#endif /* ( DHCP_SPOOF_TINY_SERVER == FYES ) */
#line 2413 "mibslot.mdf"
#if ( DHCP_SPOOF_TINY_SERVER == FYES )
    EtherAddress                        hostThreeAddress;
#endif /* ( DHCP_SPOOF_TINY_SERVER == FYES ) */
#line 2418 "mibslot.mdf"
#if ( MDF_FINGER == FYES)
    Boolean                             fingerEnable;
#endif /* ( MDF_FINGER == FYES) */
#line 2423 "mibslot.mdf"
#if ( ( MDF_IP_ROUTE == FYES ) && ( MDF_LOGPROF == FNO ) )
    Word                                logPort;
#endif /* ( ( MDF_IP_ROUTE == FYES ) && ( MDF_LOGPROF == FNO ) ) */
#line 2428 "mibslot.mdf"
#if RADIUS_COND
    Uint32                              authResetTime;
#endif /* RADIUS_COND */
#line 2433 "mibslot.mdf"
#if RADIUS_COND
    Uint32                              acctResetTime;
#endif /* RADIUS_COND */
#line 2438 "mibslot.mdf"
#if ( (MDF_IP_ROUTE==FYES) && (MDF_RADIUS==FYES) && (MDF_RADIUS_ACCT==FYES) )
    LogCallInfo                         callInfo;
#endif /* ( (MDF_IP_ROUTE==FYES) && (MDF_RADIUS==FYES) && (MDF_RADIUS_ACCT==FYES) ) */
#line 2443 "mibslot.mdf"
#if CALL_LOG_COND
    Boolean                             callLogEnable;
#endif /* CALL_LOG_COND */
#line 2448 "mibslot.mdf"
#if CALL_LOG_COND
    IpAddress                           callLogHost1;
#endif /* CALL_LOG_COND */
#line 2453 "mibslot.mdf"
#if CALL_LOG_COND
    IpAddress                           callLogHost2;
#endif /* CALL_LOG_COND */
#line 2458 "mibslot.mdf"
#if CALL_LOG_COND
    IpAddress                           callLogHost3;
#endif /* CALL_LOG_COND */
#line 2463 "mibslot.mdf"
#if CALL_LOG_COND
    Word                                callLogPort;
#endif /* CALL_LOG_COND */
#line 2468 "mibslot.mdf"
#if CALL_LOG_COND
    char                                callLogKey[ MAX_PASSWORD_LENGTH + 2 ];
#endif /* CALL_LOG_COND */
#line 2473 "mibslot.mdf"
#if CALL_LOG_COND
    Word                                callLogTimeout;
#endif /* CALL_LOG_COND */
#line 2479 "mibslot.mdf"
#if CALL_LOG_COND
    AcctBaseType                        callLogIDBase;
#endif /* CALL_LOG_COND */
#line 2484 "mibslot.mdf"
#if CALL_LOG_COND
    Uint32                              callLogResetTime;
#endif /* CALL_LOG_COND */
#line 2489 "mibslot.mdf"
#if ( MDF_SNMP == FYES )
    Boolean                             readWriteCommunityEnable;
#endif /* ( MDF_SNMP == FYES ) */
#line 2494 "mibslot.mdf"
#if ( MDF_L2TP == FYES )
    L2tpMode                            l2tpMode;
#endif /* ( MDF_L2TP == FYES ) */
#line 2499 "mibslot.mdf"
#if ( 0 )
    char                                l2tpPassword[ MAX_PASSWORD_LENGTH + 2 ];
#endif /* ( 0 ) */
#line 2505 "mibslot.mdf"
#if ( MDF_PPTP == FYES ) && ( MDF_L2TP == FYES )
    L2TunnelType                        l2TunnelType[ MAX_L2TP_SERVERS ];
#endif /* ( MDF_PPTP == FYES ) && ( MDF_L2TP == FYES ) */
#line 2511 "mibslot.mdf"
#if (( MDF_IP_FAX == FYES ) && !Q_TNT)
    IpFaxProfile                        ipfax;
#endif /* (( MDF_IP_FAX == FYES ) && !Q_TNT) */
#line 2516 "mibslot.mdf"
#if ( MDF_SNMP == FYES )
    Uint16                              queueDepth;
#endif /* ( MDF_SNMP == FYES ) */
#line 2525 "mibslot.mdf"
    Uint16                              ripQueueDepth;
#line 2533 "mibslot.mdf"
#if (( DHCP_SPOOF_TINY_SERVER == FYES ) && ( DHCP_SPOOF_TINY_SERVER_EXTRA == FYES ))
    IpAddress                           hostFourIp;
#endif /* (( DHCP_SPOOF_TINY_SERVER == FYES ) && ( DHCP_SPOOF_TINY_SERVER_EXTRA == FYES )) */
#line 2538 "mibslot.mdf"
#if (( DHCP_SPOOF_TINY_SERVER == FYES ) && ( DHCP_SPOOF_TINY_SERVER_EXTRA == FYES ))
    IpAddress                           hostFourNetmask;
#endif /* (( DHCP_SPOOF_TINY_SERVER == FYES ) && ( DHCP_SPOOF_TINY_SERVER_EXTRA == FYES )) */
#line 2543 "mibslot.mdf"
#if (( DHCP_SPOOF_TINY_SERVER == FYES ) && ( DHCP_SPOOF_TINY_SERVER_EXTRA == FYES ))
    EtherAddress                        hostFourAddress;
#endif /* (( DHCP_SPOOF_TINY_SERVER == FYES ) && ( DHCP_SPOOF_TINY_SERVER_EXTRA == FYES )) */
#line 2548 "mibslot.mdf"
#if (( DHCP_SPOOF_TINY_SERVER == FYES ) && ( DHCP_SPOOF_TINY_SERVER_EXTRA == FYES ))
    IpAddress                           hostFiveIp;
#endif /* (( DHCP_SPOOF_TINY_SERVER == FYES ) && ( DHCP_SPOOF_TINY_SERVER_EXTRA == FYES )) */
#line 2553 "mibslot.mdf"
#if (( DHCP_SPOOF_TINY_SERVER == FYES ) && ( DHCP_SPOOF_TINY_SERVER_EXTRA == FYES ))
    IpAddress                           hostFiveNetmask;
#endif /* (( DHCP_SPOOF_TINY_SERVER == FYES ) && ( DHCP_SPOOF_TINY_SERVER_EXTRA == FYES )) */
#line 2558 "mibslot.mdf"
#if (( DHCP_SPOOF_TINY_SERVER == FYES ) && ( DHCP_SPOOF_TINY_SERVER_EXTRA == FYES ))
    EtherAddress                        hostFiveAddress;
#endif /* (( DHCP_SPOOF_TINY_SERVER == FYES ) && ( DHCP_SPOOF_TINY_SERVER_EXTRA == FYES )) */
#line 2563 "mibslot.mdf"
#if (( DHCP_SPOOF_TINY_SERVER == FYES ) && ( DHCP_SPOOF_TINY_SERVER_EXTRA == FYES ))
    IpAddress                           hostSixIp;
#endif /* (( DHCP_SPOOF_TINY_SERVER == FYES ) && ( DHCP_SPOOF_TINY_SERVER_EXTRA == FYES )) */
#line 2568 "mibslot.mdf"
#if (( DHCP_SPOOF_TINY_SERVER == FYES ) && ( DHCP_SPOOF_TINY_SERVER_EXTRA == FYES ))
    IpAddress                           hostSixNetmask;
#endif /* (( DHCP_SPOOF_TINY_SERVER == FYES ) && ( DHCP_SPOOF_TINY_SERVER_EXTRA == FYES )) */
#line 2573 "mibslot.mdf"
#if (( DHCP_SPOOF_TINY_SERVER == FYES ) && ( DHCP_SPOOF_TINY_SERVER_EXTRA == FYES ))
    EtherAddress                        hostSixAddress;
#endif /* (( DHCP_SPOOF_TINY_SERVER == FYES ) && ( DHCP_SPOOF_TINY_SERVER_EXTRA == FYES )) */
#line 2578 "mibslot.mdf"
#if RADIUS_COND
    Uint32                              acctCheckpoint;
#endif /* RADIUS_COND */
#line 2583 "mibslot.mdf"
#if RADIUS_COND
    Bool8                               acctStopOnly;
#endif /* RADIUS_COND */
#line 2590 "mibslot.mdf"
#if RADIUS_COND
    Word                                acctRetryLimit;
#endif /* RADIUS_COND */
#line 2596 "mibslot.mdf"
#if ( MDF_APPLE_ROUTE == FYES ) && ( MDF_TWO_ETHERNET == FYES)
    AtlkRouteType                       atlkRouterB;
#endif /* ( MDF_APPLE_ROUTE == FYES ) && ( MDF_TWO_ETHERNET == FYES) */
#line 2601 "mibslot.mdf"
#if ( MDF_APPLE_ROUTE == FYES ) && ( MDF_TWO_ETHERNET == FYES)
    Word                                atlkNetStartB;
#endif /* ( MDF_APPLE_ROUTE == FYES ) && ( MDF_TWO_ETHERNET == FYES) */
#line 2606 "mibslot.mdf"
#if ( MDF_APPLE_ROUTE == FYES ) && ( MDF_TWO_ETHERNET == FYES)
    Word                                atlkNetEndB;
#endif /* ( MDF_APPLE_ROUTE == FYES ) && ( MDF_TWO_ETHERNET == FYES) */
#line 2611 "mibslot.mdf"
#if ( MDF_APPLE_ROUTE == FYES ) && ( MDF_TWO_ETHERNET == FYES)
    ZoneNameType                        atlkDefaultZoneB;
#endif /* ( MDF_APPLE_ROUTE == FYES ) && ( MDF_TWO_ETHERNET == FYES) */
#line 2616 "mibslot.mdf"
#if ( MDF_APPLE_ROUTE == FYES ) && ( MDF_TWO_ETHERNET == FYES)
    ZoneNameType                        atlkZoneListB[ MAX_SEED_ZONE_NAMES ];
#endif /* ( MDF_APPLE_ROUTE == FYES ) && ( MDF_TWO_ETHERNET == FYES) */
#line 2621 "mibslot.mdf"
#if (MDF_ARAP == FYES || MDF_APPLE_ROUTE == FYES) && ( MDF_TWO_ETHERNET == FYES)
    Word                                hintNetLoB;
#endif /* (MDF_ARAP == FYES || MDF_APPLE_ROUTE == FYES) && ( MDF_TWO_ETHERNET == FYES) */
#line 2626 "mibslot.mdf"
#if (MDF_ARAP == FYES || MDF_APPLE_ROUTE == FYES) && ( MDF_TWO_ETHERNET == FYES)
    Word                                hintNetHiB;
#endif /* (MDF_ARAP == FYES || MDF_APPLE_ROUTE == FYES) && ( MDF_TWO_ETHERNET == FYES) */
#line 2631 "mibslot.mdf"
#if (MDF_ARAP == FYES || MDF_APPLE_ROUTE == FYES) && ( MDF_TWO_ETHERNET == FYES)
    LongWord                            hintNetNodeB;
#endif /* (MDF_ARAP == FYES || MDF_APPLE_ROUTE == FYES) && ( MDF_TWO_ETHERNET == FYES) */
#line 2636 "mibslot.mdf"
#if (MDF_ARAP == FYES || MDF_APPLE_ROUTE == FYES) && ( MDF_TWO_ETHERNET == FYES)
    ZoneNameType                        hintZoneB;
#endif /* (MDF_ARAP == FYES || MDF_APPLE_ROUTE == FYES) && ( MDF_TWO_ETHERNET == FYES) */
#line 2641 "mibslot.mdf"
#if CALL_LOG_COND
    Bool8                               callLogStopOnly;
#endif /* CALL_LOG_COND */
#line 2648 "mibslot.mdf"
#if CALL_LOG_COND
    Word                                callLogRetryLimit;
#endif /* CALL_LOG_COND */
#line 2654 "mibslot.mdf"
#if ((MDF_MROUTING == FYES) && (MDF_IGMP == FYES))
    Uint16                              multicastGroupLeaveDelay;
#endif /* ((MDF_MROUTING == FYES) && (MDF_IGMP == FYES)) */
#line 2660 "mibslot.mdf"
#if (( MDF_IP == FYES ) && ( MDF_TERMSRV == FYES ))
    Boolean                             tsCSlipAutoDetectEnabled;
#endif /* (( MDF_IP == FYES ) && ( MDF_TERMSRV == FYES )) */
#line 2668 "mibslot.mdf"
#if ( MDF_ATMP == FYES )
    Uint16                              greMtu;
#endif /* ( MDF_ATMP == FYES ) */
#line 2675 "mibslot.mdf"
#if ( MDF_ATMP == FYES )
    Boolean                             forceFragmentation;
#endif /* ( MDF_ATMP == FYES ) */
#line 2685 "mibslot.mdf"
#if ( MDF_ATMP == FYES )
    Uint16                              atmpIdleLimit;
#endif /* ( MDF_ATMP == FYES ) */
#line 2692 "mibslot.mdf"
#if ( MDF_ARAP == FYES )
    Boolean                             tsAraEnabled;
#endif /* ( MDF_ARAP == FYES ) */
#line 2698 "mibslot.mdf"
#if ( MDF_IP_ROUTE == FYES )
    Boolean                             icmpReplyDirectedBcast;
#endif /* ( MDF_IP_ROUTE == FYES ) */
#line 2704 "mibslot.mdf"
#if ( MDF_IP_ROUTE == FYES )
    Boolean                             allowDirectedBcast;
#endif /* ( MDF_IP_ROUTE == FYES ) */
#line 2710 "mibslot.mdf"
#if ( ( RADIUS_COND ) && ( MDF_CLID == FYES ) )
    Uint16                              authIdMaxRetryTime;
#endif /* ( ( RADIUS_COND ) && ( MDF_CLID == FYES ) ) */
#line 2717 "mibslot.mdf"
#if (( MDF_VOIP == FYES ) && ( PLATFORM & MPORT ))
    VoipProfile                         voip;
#endif /* (( MDF_VOIP == FYES ) && ( PLATFORM & MPORT )) */
#line 2723 "mibslot.mdf"
#if ( 0 )
    Boolean                             vpnMode;
#endif /* ( 0 ) */
#line 2728 "mibslot.mdf"
#if ( 0 )
    PacketAudioMode                     packetAudioMode;
#endif /* ( 0 ) */
#line 2733 "mibslot.mdf"
#if ( MDF_L2TP == FYES )
    Uint16                              l2tpRxWindow;
#endif /* ( MDF_L2TP == FYES ) */
#line 2740 "mibslot.mdf"
#if ( MDF_L2TP == FYES )
    Boolean                             l2tpAuthEnabled;
#endif /* ( MDF_L2TP == FYES ) */
#line 2745 "mibslot.mdf"
#if (MDF_DNS_FALLBACK_TABLE == FYES)
    MibProfDnsFallbackTab               localDnsTable[ MAX_DNS_LOCAL_TAB ];
#endif /* (MDF_DNS_FALLBACK_TABLE == FYES) */
#line 2750 "mibslot.mdf"
#if ( MDF_RADIUS == FYES )
    Boolean                             noAttr6UseTermsrv;
#endif /* ( MDF_RADIUS == FYES ) */
#line 2756 "mibslot.mdf"
#if ( MDF_IP == FYES )
    Boolean                             ripTrigger;
#endif /* ( MDF_IP == FYES ) */
#line 2763 "mibslot.mdf"
#if ( DHCP_SPOOF_TINY_SERVER == FYES )
    char                                tftpHostName[ MAX_TFTP_HOST_NAME_LEN + 1 ];
#endif /* ( DHCP_SPOOF_TINY_SERVER == FYES ) */
#line 2768 "mibslot.mdf"
#if ( DHCP_SPOOF_TINY_SERVER == FYES )
    char                                bootFilePath[ MAX_BOOT_FILE_PATH_LEN + 1 ];
#endif /* ( DHCP_SPOOF_TINY_SERVER == FYES ) */
#line 2773 "mibslot.mdf"
#if ( 0 )
    Uint16                              audioFramesPerPacket;
#endif /* ( 0 ) */
#line 2778 "mibslot.mdf"
#if (( MDF_IP == FYES ) && ( PLATFORM & MPORT ))
    Boolean                             suppressHostRoute;
#endif /* (( MDF_IP == FYES ) && ( PLATFORM & MPORT )) */
#line 2785 "mibslot.mdf"
#if (( MDF_CLID == FYES) && ( PLATFORM & ( M1800 | M2000 | M4000 | M6000 ) ) )
    Boolean                             dnisEnabled;
#endif /* (( MDF_CLID == FYES) && ( PLATFORM & ( M1800 | M2000 | M4000 | M6000 ) ) ) */
#line 2790 "mibslot.mdf"
#if (( MDF_CLID == FYES) && ( PLATFORM & ( M1800 | M2000 | M4000 | M6000 ) ) )
    DNISProfileTab                      dnisTab[ DNIS_MAX_NUMBER ];
#endif /* (( MDF_CLID == FYES) && ( PLATFORM & ( M1800 | M2000 | M4000 | M6000 ) ) ) */
#line 2795 "mibslot.mdf"
#if (( MDF_OSPF == FYES ) && ( MDF_TWO_ETHERNET == FYES ))
    MibProfOspf                         ospfB;
#endif /* (( MDF_OSPF == FYES ) && ( MDF_TWO_ETHERNET == FYES )) */
#line 2800 "mibslot.mdf"
#if (( MDF_IP == FYES ) && ( MDF_TERMSRV == FYES ))
    Uint16                              tsRloginMaxPort;
#endif /* (( MDF_IP == FYES ) && ( MDF_TERMSRV == FYES )) */
#line 2806 "mibslot.mdf"
#if (( MDF_IP == FYES ) && ( MDF_TERMSRV == FYES ))
    Uint16                              tsRloginMinPort;
#endif /* (( MDF_IP == FYES ) && ( MDF_TERMSRV == FYES )) */
#line 2812 "mibslot.mdf"
#if ( MDF_TELNET_SECURITY == FYES )
    TelnetSecurity                      telnetSecurity;
#endif /* ( MDF_TELNET_SECURITY == FYES ) */
#line 2817 "mibslot.mdf"
#if ( MDF_DHCP_CLIENT_IMPL == FYES )
    Boolean                             dhcpClientEnabled;
    Boolean                             dhcpClientPnpEnabled;
    IpAddress				dhcpClientIpAddress;
//  IpAddress				dhcpClientNetmask;
#endif /* ( MDF_DHCP_CLIENT_IMPL == FYES ) */

#if (DHCP_PLUS == FYES)
	//DHCP Server
	Boolean   dhcpSvrOn; //DHCP Server	
	Uint	  pingNum; //IPping	
	Uint	  pingTimeout;//ping

	Boolean   dhcpSrvDetect;

	//DHCP Client
	Boolean             	dhcpClientOn; 	
	Boolean             	dhcpClientPnpOn; 
	Boolean             	KeepAutoIP;	
	DhcpCastEnum	    	dhcprequest;	
	DhcpCastEnum		dhcpflags;	
	char			identifier[MAX_CLIENTID_LEN];	
	Boolean			overIPSec;	
	IpAddress		cachedIP; //user invisible	
	IpAddress		cachednetmask;//user invisible

	//DHCP Relay
	Boolean		dhcpRelayOn;
	IpAddress	dhcpRelayPriSvr;
	IpAddress	dhcpRelaySecSvr;
	IpAddress	dhcpRelayThrSvr;
	RELAY_OPTION 	dhcpRelayOption;
	RELAY_POLICY	dhcpRelayPolicy;
	Uint32		dhcpRelayLen;
	char		dhcpRelayCirId[MAX_CIRCUITID_LEN];
	OVERLOAD_FLAGS	dhcpRelayFlags;
	
#endif //#if (DHCP_PLUS == FYES)
	/*added by jfgu@090626*/
	Boolean   newautobind;//dhcpserver
	Boolean   delautobind;//dhcpserver
	

#line 2822 "mibslot.mdf"
#if ( MDF_RADIUS == FYES )
    RadiusCompatType                    authRadCompat;
#endif /* ( MDF_RADIUS == FYES ) */
#line 2828 "mibslot.mdf"
#if ( MDF_RADIUS_ACCT == FYES )
    RadiusCompatType                    acctRadCompat;
#endif /* ( MDF_RADIUS_ACCT == FYES ) */
#line 2834 "mibslot.mdf"
#if ( MDF_RADIUS_SERV == FYES )
    RadiusCompatType                    radServRadCompat;
#endif /* ( MDF_RADIUS_SERV == FYES ) */
#line 2840 "mibslot.mdf"
#if CALL_LOG_COND
    RadiusCompatType                    callLogRadCompat;
#endif /* CALL_LOG_COND */
#line 2846 "mibslot.mdf"
#if ( MDF_SNMP == FYES )
    Bool                                atmpSnmpTrapEnabled;
#endif /* ( MDF_SNMP == FYES ) */
#line 2853 "mibslot.mdf"
#if ( MDF_RADIUS == FYES )
    RadiusKeepUserNameType              authRadKeepUserName;
#endif /* ( MDF_RADIUS == FYES ) */
#line 2860 "mibslot.mdf"
#if ( MDF_RADIUS == FYES )
    char                                authRadRealmDelimiters[ MAX_REALM_CHARS_LEN+1 ];
#endif /* ( MDF_RADIUS == FYES ) */
#line 2867 "mibslot.mdf"
#if ( IP_RD_TC_C_COND && ( T_ONLINE == FYES ) )
    char                                idAuthPrefix[ MAX_NAME_LEN + 1 ];
#endif /* ( IP_RD_TC_C_COND && ( T_ONLINE == FYES ) ) */
    
# if (CBQ == FYES)
    CbqDevQdisc				cbq;
# endif
# if (IP_SEC == FYES)
    Uint16				nat_t_port;
# endif

# if (UPNP == FYES)
    Uint16                              upnp_port;
# endif

	/* string mode mac address */
    char				macAddress[ ETHER_ADDR_LEN*2 + 1 ];
//add by guan for ddns
    struct ddns_prof			ddns;
    
# if ( XUANLIN_ALG == FYES )
    struct xuanlin_prof			xuanlin;
# endif

//end by guan
    int					wanport;
    struct vrrp_prof                  	vrrp;
    struct ptape_prof		      	ptape;
/* moved from offset 30 of banner:Ast@20020909 */
    Boolean				natWan;
    Boolean				natDmz;
/* zhz@20020909, README please: 
 * 
 * if you added a new param, pls added it before temp[], and reduce the size of
 * temp[]. we need not NVRAM rebuild when new param added.
 * the size of temp is 1024, pls do not exceed.
 * pls keep temp[] is the last element too.
 
*/ 
/* add:Ast@20030110 further definitions would be put here! */
# if (( MDF_PPTP == FYES ) || ( MDF_L2TP == FYES ))
// added zhz@20030604, tunnel pmtud support ( rfc1109with l2 tunnel l2tp/pptp)
    Uint16			        tunnelPMTUD;
    Uint16			        tunnelAdjustTcpMSS;
    Uint16			        tunnelSetDFbit;
    Uint16			        tunnelTearDown;
// added zhz@20020828, avoid ip fragment with l2 tunnel (l2tp/pptp)
    Uint16			        tunnelmtu;
// added zhz@20051112, avoid ip sport chged by NAT (l2tp/pptp)
    L2tpTransportMode			l2tpTransMode;
    Word                                l2tpSrvPort;
    Uint16                              l2tpQueueDepth;
    Word                                pptpSrvPort;
# endif /* ( MDF_PPTP == FYES ) || ( MDF_L2TP == FYES ) */
// zhz@20030603, added for TroupGroup support in ethernet, same in BRI/SWAN */
    int					trunkGroup;
// zhz@20030803, added for per user default_gw support same as inet prof */
    IpAddress				clientDefNextHop;
// zhz@20030603, added for rx/tx bandwidth */
    Uint32				rxBandwidth;
    Uint32				txBandwidth;
// zhz@20030603, added for routingPolicy support multipath routing */
    Uint32			        routingPolicy;
// zhz@20030603, added for arp timeout control */
    Uint32			        arpCacheAge;
// zhz@20030603, added for descriptions */
    char				description[MAX_PROFILE_NAME_LENGTH+1];
// zhz@20030603, added for macAccounting */
    Boolean				macAccounting;
// zhz@20030603, added for ip config control */
    Boolean				icmpReplyNetmask;
    Boolean				icmpRequestNetmask;
    Boolean				icmpSendUnreachable;
    Boolean				icmpSendRedirect;
    Boolean				icmpPingReply;
// zhz@20030603, added for systemRouting or interface based routing 
    Uint32				systemRouting;
// zhz@20030829, added for string filter-id; 
    Char                            	inFilterGroup[MAX_PROFILE_NAME_LENGTH+1];
    Char                            	outFilterGroup[MAX_PROFILE_NAME_LENGTH+1];
    Char                            	inFilterBGroup[MAX_PROFILE_NAME_LENGTH+1];
    Char                            	outFilterBGroup[MAX_PROFILE_NAME_LENGTH+1];
//
// zhz@20030909, added for ethernet 802.1q, 802.1x support;
// options can be ethernet(1514), 802.1q(1518)
//
    Uint32				etherEncaps;
// zhz@20031224, added for arp static_binding control */
    ArpCacheMode			arpCacheMode;
// zhz@20040305, added for arp keepalive control */
    Uint32			        arpKeepalive;
    //add by brwang
    Char                                noLimitGroup[MAX_CBT_TIMERANGE_NUM][MAX_PROFILE_NAME_LENGTH+1];
// zhz@20040305, added for arp ingress control */
    Uint32			        ingressPPS;
// zhz@20040305, added for arp ingress control */
    NPW_SPEED			        ingressBPS[MAX_CBT_TIMERANGE_NUM];
// zhz@20040305, added for arp egress control */
    Uint32			        egressPPS;
// zhz@20040305, added for arp egress control */
    NPW_SPEED			        egressBPS[MAX_CBT_TIMERANGE_NUM];
// ast@040317, vlan port group. wireSpeed moved here also
#if (LANPORT5 == FYES)
    Byte                                vlanPortGroup[5];
#else
    Byte                                vlanPortGroup[4]; 
#endif
    Byte                                wireSpeed;
// zhz@20040413, added for DOS/DDOS rate limit control */
    Uint32			        icmpEchoReqPPS;
    Uint32			        icmpEchoRepPPS;
    Uint32			        udpPPS;
    Uint32			        tcpPPS;
    Uint32			        tcpSynPPS;
    Uint32			        broadcastPPS;
    Uint32			        multicastPPS;
// keep slient for specific time 
    Uint32			        blockDuration;
// against NAT spoofing 
    Boolean				checkIpSrc;
    Boolean				checkIpDst;
// zhz@20031227, added for hbeat method control */
    HbeatProfile			hbeatConf;
    Byte                                rxFlowCtrl;
    Byte                                txFlowCtrl;
#if (FC == FYES)
#if (RED == FYES)
    fcRedParams				fcRed;
#endif
    fcRateLimitParams			fcRateLimit;
#endif

    /* add for allowing exceptive qq to connect internet*/
    Boolean				qqAllow;


    DNSResolveSwitchProfile		dnsResolveSwitch;

#if (HOTEL == FYES)
    HotelSwitchProfile			hotelSwitch;
#endif
# if ( TC_DRR == FYES)
// zhz@20050616, added for ipCredit DRR(Deficit Round Robbin) */
    Int32				ipMacRate;
    Uint32			        ipCreditDRR[MAX_CBT_TIMERANGE_NUM];
    Uint32			        ipCreditDRR2[MAX_CBT_TIMERANGE_NUM]; // added by jschen@070528 // for the sake of tx // 
    Uint32			        ipCreditDRRbase; // added by jschen@070528 // for the sake of debug. e.g. in cli, sh cbt/mDRRbase // more to say: the base of tc control is 64Kbps=8000Bytes. but we can adjust it slightly, e.g. 10000 // more to say: this base if for global settings of TC. if you want to allow user/group-level flexiblility, the file correponding to this file is include/mib/mibname.h
    Uint32			        ipCreditDefault;
    Uint32			        ipCreditOverflow; 
    Uint32			        ipCreditOverflowTx; // jschen: for the sake of Tx
    Int32			        ipCreditUnderflow;
    Uint32			        ipRedDuration;
# endif /* ( TC_DRR == FYES ) */


//
// zhz@20050916, 802.3u pause frame flowc ctrl interval;
//
    Uint32				flowCtrlInterval;
//
// zhz@20050916, 802.1q vlan tag;
//
# if ( DOT1Q_VLAN == FYES )
    Uint16                              vLanTag;
    Uint16                              vLanGroup;
    Uint16                              vLanType;
    dot1qParams                         vlanDot1qParams[NUM_OF_ETHER_SLOTS];
//  Uint16              		vlanDot1qPortGroup[NUM_OF_ETHER_SLOTS];
//  Uint16              		vlanDot1qTagGroup[NUM_OF_ETHER_SLOTS];
# endif
#if ( IPTOS == FYES )
    MibProfIpTos                        tosOpt;
#endif /* ( IPTOS == FYES ) */
#line 301 "mibinip.mdf"
#if ( MDF_IPTOS_CLI == FYES )
    char                                tosFilter[ MAX_FILTER_NAME_LENGTH + 1 ];
#endif /* ( MDF_IPTOS_CLI == FYES ) */
#line 307 "mibinip.mdf"
#if ( MDF_IPTOS_LCD == FYES )
    Uint16                              itosFilter;
#endif /* ( MDF_IPTOS_LCD == FYES ) */

# if ( IP_IDP == FYES )
/* ip idp cfg */
	int ipIcmpRate;
	int ipUdpRate;
	int ipTcpsynRate;
	int ipBcastRate;
	int ipArpRate;
	int ipTxRate;
	int ipRxRate;
	int ipNatRate;
	int ipBcaststormProtect;
	int ipMcaststormProtect;
# endif /* IP_IDP == FYES */
	Boolean pppoeDosIdp;

#if (FC == FYES)
#endif
}
#if ( USERIF & CLI )
__PACK__
#endif
EtherSlotxProfile;

#endif /* ( MDF_ETHERNET == FYES ) */

    /*
     * EtherSlotProfile:
     *
     * Ethernet slot card profile. Contains:
     *
     *  header The name and type of profile.
     *
     *  ipAddress The IP Address of the ethernet.
     *
     *  netmask The Network Mask of this interface.
     *
     *  ipAddress2 Alternate IP address of the ethernet.
     *
     *  netmask2 Netmask for the alternate IP address.
     *
     *  domainName The DNS domain name assigned to this unit.
     *
     *  primaryDnsServer The IP address of the primary DNS server.
     *
     *  secondaryDnsServer The IP address of the secondary DNS server. This
     *                                  server is used when the primary is not
     *                                  available.
     *
     *  primaryNetBiosNS The IP address of the primary NetBios name server.
     *
     *  secondaryNetBiosNS The IP address of the secondary NetBios name server.
     *
     *  authType The type of authentication to perform.
     *
     *  authHost The IP address of the authentication host.
     *
     *  authHost2 The IP address of the secondary authentication host.
     *
     *  authHost3 The IP address of the tertiary authentication host.
     *
     *  authPort The UDP port to use for RADIUS authentication.
     *
     *  authSrcPort The UDP source port to use for RADIUS authentication. If
     *                                  zero, the source port is selected from
     *                                  the non-privileged port range
     *                                  (1024-2000).
     *
     *  authKey The RADIUS access key.
     *
     *  authPool If TRUE an IP address is allocated from the default pool and
     *                                  passed to the RADIUS server during
     *                                  RADIUS authentication. This address may
     *                                  be assigned to the dial-in user for the
     *                                  duration of the connection.
     *
     *  authTimeout Number of seconds between retries to the authentication
     *                                  host.
     *
     *  authRspRequired This is flag that says whether entry is allowed if
     *                                  there is no response from the
     *                                  authentication server. This is only
     *                                  used for CLID profiles.
     *
     *  clidFailBusy
     *
     *  clidTimeoutBusy
     *
     *  acctType The type of accounting to perform.
     *
     *  acctHost The IP address of the first RADIUS accounting host.
     *
     *  acctHost2 The IP address of the second RADIUS accounting host.
     *
     *  acctHost3 The IP address of the third RADIUS accounting host.
     *
     *  acctPort The UDP port to use for RADIUS accounting.
     *
     *  acctSrcPort The UDP source port to use for RADIUS accounting. If zero,
     *                                  the source port is selected from the
     *                                  non-privileged port range (1024-2000).
     *
     *  acctKey The RADIUS accounting key.
     *
     *  acctTimeout Number of seconds to wait for a response to previous
     *                                  accounting request.
     *
     *  sessInterval THe interval to send out number of sessions per Class
     *                                  Attribute.
     *
     *  logHost The IP address of the log host for syslog updating.
     *
     *  logFacility The syslogd facility code for messages logged from this
     *                                  box.
     *
     *  logPriority The syslogd priority code for messages logged from this
     *                                  box.
     *
     *  sharedProf When TRUE multiple users may share a connection profile, as
     *                                  long as IP addresses are not
     *                                  duplicated.
     *
     *  assignOnly Flag, when set indicates that addresses assigned from the
     *                                  address pool may NOT be overridden by
     *                                  addresses received from the far end.
     *
     *  poolSummary Flag, when set indicates that host addresses assigned from
     *                                  the pool should be marked as PRIVATE in
     *                                  the routing table and summarized to the
     *                                  world at large via a (constant) network
     *                                  advertisement for the whole pool.
     *
     *  assignBase The base address of a pool of addresses we can use to assign
     *                                  to clients.
     *
     *  assignCount The number of host addresses in the above. pool. The
     *                                  addresses are contiguous.
     *
     *  filter The number of the filter profile assigned to this interface.
     *
     *  ripMode Specify how RIP is to be used on the ehternet. Options are off,
     *                                  on, ignore received routing updates,
     *                                  don't send routing updates.
     *
     *  ripPolicy An Enum describing whether to use Poison reverse or Split
     *                                  Horizon policy. Global for the box.
     *
     *  ospf The user configurable settings for OSPF on this interface.
     *
     *  ospfg The user configurable settings for OSPF that are global in
     *                                  nature.
     *
     *  proxyMode Specify how proxy arp is to be used.
     *
     *  ignoreDefRoute A boolean. When set to TRUE (its default value) we will
     *                                  ignore default addresses advertized by
     *                                  routing protocols.
     *
     *  ripSummary Summarize subnets in RIP broadcasts per RFC 1058/RFC 1009.
     *
     *  ripMulticast Use multicast address for sending RIP 2 on this interface
     *                                  .
     *
     *  sysPasswd Global terminal server system access password.
     *
     *  banner This is the terminal server login banner.
     *
     *  tsLoginPrompt
     *
     *  tsPasswdPrompt
     *
     *  tsPrompt The current terminal server prompt.
     *
     *  tsTerm The default terminal type for telnet sessions.
     *
     *  tsEnabled TRUE if the terminal server features are enabled.
     *
     *  tsPppEnabled TRUE if terminal server users are allowed to intiate async
     *                                  PPP sessions.
     *
     *  tsSlipEnabled TRUE if users are allowed to initiate SLIP sessions.
     *
     *  tsTelnetEnabled TRUE if users are allowed to telnet out of the box.
     *
     *  tsRloginEnabled TRUE if users are allowed to rlogin out of the box.
     *
     *  tsClearCall TRUE if calls should be cleared when a valid telnet session
     *                                  terminates.
     *
     *  tsTelnetMode Selects default Telnet mode: ASCII, Binary, or
     *                                  Transparent.
     *
     *  tsBufferChars Whether to buffer termserv characters or to forward them
     *                                  ASAP.
     *
     *  tsRemote TRUE if using remote RADIUS configuration.
     *
     *  tsAutoTelnet TRUE if unknown terminal server commands should be treated
     *                                  as the name of a host to telnet to.
     *
     *  timeoutForAutoPPP The number of seconds to wait for PPP before putting
     *                                  up the login banner and converting to
     *                                  telnet mode.
     *
     *  tsImmediateServiceType None / Telnet / Raw-Tcp / Rlogin / X25-Pad
     *                                  enumeration
     *
     *  tsImmediateHost Name or IP address or X.121 address of the Immediate
     *                                  Telnet / RawTcp / X25Pad host
     *
     *  tsImmediateTcpPort TCP port to which the Telnet / RawTcp stream is to
     *                                  be redirected to
     *
     *  tsTelnetHostAuth Option defines if telnet is started directly bypassing
     *                                  Term Server authentication process.
     *                                  Authentication is the responsibility of
     *                                  the telnet host.
     *
     *  tsV42bis Describes the error correction mode for the V.34 modems.
     *
     *  ts7Even TRUE if we are speaking 7-even to the digital modem.
     *
     *  tsSilent Don't generate any status messages.
     *
     *  tsMenuMode If TRUE dial in users will come up in menu mode instead of
     *                                  command mode.
     *
     *  tsToggleScreen If TRUE users will be able to toggle between menu mode
     *                                  and command mode.
     *
     *  pppMsg Disable the PPP/SLIP start up message.
     *
     *  clearScrn Clear the screen for termsrv.
     *
     *  wanBootpReply Reply to BOOTP request you receive from the Async WAN
     *                                  clients.
     *
     *  tsSecure The terminal server security mode.
     *
     *  host1Addr The address of the hosts to access when terminal server menu
     *                                  mode is being used without remote
     *                                  configuration.
     *
     *  host1Text The text to put in the terminal server menu for the above
     *                                  hosts when remote configuration isn't
     *                                  available.
     *
     *  host2Addr The address of the hosts to access when terminal server menu
     *                                  mode is being used without remote
     *                                  configuration.
     *
     *  host2Text The text to put in the terminal server menu for the above
     *                                  hosts when remote configuration isn't
     *                                  available.
     *
     *  host3Addr The address of the hosts to access when terminal server menu
     *                                  mode is being used without remote
     *                                  configuration.
     *
     *  host3Text The text to put in the terminal server menu for the above
     *                                  hosts when remote configuration isn't
     *                                  available.
     *
     *  host4Addr The address of the hosts to access when terminal server menu
     *                                  mode is being used without remote
     *                                  configuration.
     *
     *  host4Text The text to put in the terminal server menu for the above
     *                                  hosts when remote configuration isn't
     *                                  available.
     *
     *  thirdPrompt This is a text field that will print a third prompt for a
     *                                  terminal server login. If this value is
     *                                  null no third prompt is used.
     *
     *  thirdPromptSequence Select where the third prompt should appear in the
     *                                  login sequence: either before or after
     *                                  user name & password.
     *
     *  rarpEnabled TRUE if this box is to RARP for its IP address.
     *
     *  bootpEnabled TRUE if this box is to use bootp to get params and check
     *                                  for a new load.
     *
     *  bridgingEnabled TRUE if this box is to support bridging. Also requires
     *                                  the bridging option in the security
     *                                  prom to be enabled.
     *
     *  ipxRoutingEnabled TRUE if this box is currently routing IPX. We don't
     *                                  do IPX routing protocols or packet
     *                                  forwarding if FALSE. Spoofing is
     *                                  independent, not affected by this.
     *
     *  fill Align for P25.
     *
     *  logEnabled TRUE if sysloging is to be performed.
     *
     *  telnetPassword The password that must be used to be able to Telnet into
     *                                  the box.
     *
     *  etherAnsNumber1 Incoming calls directed to these numbers are assumed to
     *                                  be LAN connections.
     *
     *  etherAnsNumber2 Incoming calls directed to these numbers are assumed to
     *                                  be LAN connections.
     *
     *  etherAnsNumber3 Incoming calls directed to these numbers are assumed to
     *                                  be LAN connections.
     *
     *  etherAnsNumber4 Incoming calls directed to these numbers are assumed to
     *                                  be LAN connections.
     *
     *  etherIF The type of phyical interface, UTP, COAX, AUI
     *
     *  readCommunity The SNMP community name for read access.
     *
     *  readWriteCommunity The SNMP community name for read/write access.
     *
     *
     *  snmpEnabled A boolean. When set to FALSE (its default value) we will
     *                                  not allow access to all SNMP managers, 
     *					When set to
     *                                  TRUE, we will allow snmp sub system.
     *
     *  snmpSecurity A boolean. When set to FALSE (its default value) we will
     *                                  allow access to all SNMP managers that
     *                                  know the community string. When set to
     *                                  TRUE, we will check the source IP
     *                                  address against the ones that are in
     *                                  the readAccessHost[] and the
     *                                  writeAccessHost[] arrays before
     *                                  allowing access.
     *
     *  readAccessHost The IP address of a SNMP manager which has read access.
     *
     *  readAccessMask The IP netmask of a SNMP manager which has read access.
     *
     *  writeAccessHost The IP address of a SNMP manager which has write
     *                                  access.
     *
     *  writeAccessMask The IP netmask of a SNMP manager which has write
     *                                  access.
     *
     *  x25WanAddress The IP address assigned to WAN connections when using
     *                                  X.25.
     *
     *  ipxFrameType The IPX Frame Type we are configured to recognize.
     *
     *  ipxEtherNetNumber
     *
     *  ipxDialinPool
     *
     *  dialPlan
     *
     *  trunkGroupsNA
     *
     *  pwsEnabled
     *
     *  pwsHost
     *
     *  pwsPort
     *
     *  ignoreIcmpRedirects If TRUE, incoming ICMP redirects will be ignored,
     *                                  otherwise, they will be processed.
     *
     *  dropSourceRoutedIpPackets If TRUE, do not forward IP packets with the
     *                                  source route option set.
     *
     *  ringback When FALSE modem ringback tones will not be generated for
     *                                  digital modem calls. Required for some
     *                                  intl locations.
     *
     *  dhcpSpoofEnabled
     *
     *  dhcpSpoofPnpEnabled
     *
     *  dhcpSpoofIpAddress
     *
     *  dhcpSpoofNetmask
     *
     *  dhcpSpoofRenewalTime
     *
     *  dhcpSpoofBecomeDefaultRouter If set to Yes, then we will advertise
     *                                  ourself as the Default Route in the
     *                                  DHCP reply messages.
     *
     *  dhcpSpoofDialIfLinkDown When DHCP Request is spoofed, dial the first
     *                                  connection profile
     *
     *  alwaysSpoof When PnP is enabled, offer choice to always spoof or not
     *
     *  atmpAgentMode One of AtmpAgentMode.
     *
     *  atmpAgentType One of AtmpHomeAgentType.
     *
     *  atmpUdpPort UDP port number to use locally.
     *
     *  atmpHomeAgentPassword The password required to access this home agent.
     *
     *  atmpSapReply
     *
     *  sapFilter The number of the IPX SAP Filter assigned to this interface.
     *
     *  tsModemDialout Allows modem outdial from the terminal server if TRUE.
     *
     *  appletalkAra Allow ethernet support for Appletalk/ARA.
     *
     *  tsMaxBaud Describes the maximum baud rate the C.34 modems should try.
     *
     *  radServEnable Whether the on-board RADIUS server is enabled or not.
     *
     *  radServPort The UDP port to use for the on-board RADIUS server.
     *
     *  hintNetLo A hint for the Appletalk low net number
     *
     *  hintNetHi A hint for the Appletalk hi net number
     *
     *  hintNetNode A hint for the Appletalk node number
     *
     *  hintZone The default zone that the MAX will come up in.
     *
     *  sntpHost The IP Address of the SNTP host.
     *
     *  sntpEnabled Use SNTP to get time.
     *
     *  tzMode UTT canned Timezones.
     *
     *  natRouting A boolean. When set to TRUE it translates all the lan
     *                                  addresses to dynamicaly assigned
     *                                  internet address.
     *
     *  natProfile The profile to use for NAT Routing.
     *
     *  dnsListAttempt Should DNS List feature be used.
     *
     *  sapProxy Use IPX SAP Proxy.
     *
     *  sapProxyNets The Network# for IPX SAP Proxy.
     *
     *  udpCksum Should internal stack use UDP cksum on packets it generates.
     *
     *  ipFragment Should internal stack ignoring IP_DF when do ip fragment.
     *
     *  pptpMode Enables/Disables support for the Point to Point Tunneling
     *                                  Protocol.
     *
     *  pptpServers The IP Address or Names of the PPTP servers.
     *
     *  tsMdmTrnLevel The transmit attenuate level the C.34 modems should try.
     *
     *  dialoutPoison Should dialout routes be poisoned if no dialout trunks
     *                                  available
     *
     *  tsLocalEcho Telnet defaults to local echo when TRUE.
     *
     *  cellFirst If TRUE, the modem attempts cellular connection first - then
     *                                  land connection. If FALSE, land based
     *                                  is attempted first, then cellular.
     *                                  Default is land based - FALSE.
     *
     *  cellLevel The modem cellular communications transmit and receive level.
     *                                  Valid values are 10...18.
     *
     *  acctIDBase The Base to use in reporting Account ID.
     *
     *  directPPP Option defines if PPP negotiation is started directly after
     *                                  'PPP' Term Server command is received
     *                                  or, not.
     *
     *  staticPref The default preference given to static routes.
     *
     *  ripPref The default preference given to rip routes.
     *
     *  ospfPref The default preference given to ospf routes.
     *
     *  ospfAsePref The default preference given to ospf ASE routes.
     *
     *  ripTag The tag to associate with RIP routes.
     *
     *  ripAseType The ASE type to associate with RIP routes.
     *
     *  bootpRelayEnabled Enables/Disables BOOTP Relay functionality.
     *
     *  bootpServers List of BOOTP Servers which BOOTP Requests will be
     *                                  forwared to.
     *
     *  tsImmediateModem Allows an immediate telnet from LAN to a modem.
     *
     *  immediateModemPort The telnet port number so that you go to immediate
     *                                  modem.
     *
     *  multicastForwarding Multicast forwarding Enabled.
     *
     *  mboneProfile MBONE interface.
     *
     *  multicastAllowed Multicast traffic allowed.
     *
     *  ipxType20 Propagate IPX Type 20 packets (NetBIOS).
     *
     *  stackName The name of the Stack that the MAX is a member of.
     *
     *  stackEnabled Enable stacking for this MAX.
     *
     *  stackUdpPort UDP port number to use locally.
     *
     *  multicastRateLimit Multicast traffic rate limit in seconds
     *
     *  radServSessionKeyEnable Whether the on-board RADIUS server is enabled
     *                                  or not.
     *
     *  radServAttrType An enum value specifying the type of RADIUS Server
     *                                  session search
     *
     *  dialoutSecurity The security method used to control immediate modem
     *                                  access.
     *
     *  immModemPwd The password that must be used to gain access to immediate
     *                                  modem
     *
     *  retryCount Number of times to retry an authentication attempt.
     *
     *  useDesCrypt Use DES encryption instead of native encryption.
     *
     *  nodeSecret node secret assigned to this router, hexadecimal notation.
     *
     *  ipAddMsg This is a text field that will be printed in front of the IP
     *                                  address in the terminal server when
     *                                  going into PPP.
     *
     *  atlkRouter The type of AppleTalk Router to enable.
     *
     *  atlkNetStart The start of the AppleTalk Net number range.
     *
     *  atlkNetEnd The end of the AppleTalk Net number range.
     *
     *  atlkDefaultZone The default zone for the AppleTalk router.
     *
     *  atlkZoneList The Zone List for an AppleTalk seed router.
     *
     *  localProfileFirst Authenticate using local profiles first.
     *
     *  dnsListSize DNS List Size.
     *
     *  clientPrimaryDnsServer Default user IP address of the primary DNS
     *                                  server.
     *
     *  clientSecondaryDnsServer Default user IP address of the secondary DNS
     *                                  server. This server is used when the
     *                                  primary is not available.
     *
     *  allowAsClientDnsInfo This flag controls if main DNS info should be
     *                                  allowed as Client DNS info.
     *
     *  authSessInterval THe interval to send out number of sessions per Class
     *                                  Attribute. For RADIUS/Logout session
     *                                  events.
     *
     *  pktWaitTime The number of milliseconds to accumulate modem data in a
     *                                  packet.
     *
     *  pktChars The number of characters to accumulate modem data in a packet.
     *
     *  authTSsecure Allow access to terminal server when RADIUS Login-Host is
     *                                  not specify when authTSsecure is set no
     *
     *  radServClient The IP addresses of the allowed clients.
     *
     *  radServNetmask The IP netmasks of the allowed clients.
     *
     *  radServKey The on-board RADIUS server key.
     *
     *  multicastHeartBeatAddr Multicast heart beat address.
     *
     *  multicastHeartBeatPort Multicast heart beat port.
     *
     *  multicastHeartBeatSlotTime Multicast heart beat time.
     *
     *  multicastHeartBeatSlotlength Multicast heart beat slot length.
     *
     *  multicastHeartBeatAlarmThreshold Multicast heart beat alarm threshold.
     *
     *  multicastHeartBeatSrcAddr Multicast heart beat source address.
     *
     *  multicastHeartBeatSrcAddrMask Multicast heart beat source address mask.
     *
     *  tsPromptFormat TRUE if the terminal server prompt should interpret \\n.
     *
     *  secDomainName The secondary DNS domain name assigned to this unit.
     *
     *  timeoutForTSrvLogin The number of seconds to wait at the login prompt
     *                                  for the user to login.
     *
     *  authSend67 If Yes, default attributes 6,7 of Radius and send them in
     *                                  the authentication request.
     *
     *  tcpModemEnabled Enable TCP MODEM connections.
     *
     *  tcpModemPort Port number to accept TCP MODEM connections on.
     *
     *  tsModemModulation Describes the modulations, K56 or V.34.
     *
     *  tcpTimeout The maximum time to spend in TCP retransmissions before
     *                                  deciding that there is no connection.
     *
     *  localDnsTableEnabled Local DNS table read enable. This table is used
     *                                  when the remote DNS server is not
     *                                  available.
     *
     *  localDnsTableAutoUpdate Local DNS table automatic updates. Each
     *                                  name-match entry is updated
     *                                  automatically after a successful DNS
     *                                  resolve.
     *
     *  authFrmAdrStart Set yes to send a second Radius accounting start record
     *                                  when the Framed-Address is assigned.
     *                                  Default No for backward compatibility.
     *
     *  vtpAgentMode One of VtpAgentMode.
     *
     *  vtpAgentType One of VtpHomeAgentType.
     *
     *  vtpUdpPort UDP port number to use locally.
     *
     *  vtpHomeAgentPassword The password required to access this home agent.
     *
     *  vtpSapReply
     *
     *  ipNetmaskMsg This is a text field that will be printed in front of the
     *                                  IP netmask in the terminal server when
     *                                  going into SLIP.
     *
     *  ipGatewayAddMsg This is a text field that will be printed in front of
     *                                  the IP Gateway address in the terminal
     *                                  server when going into SLIP.
     *
     *  slipMsg Specify the level of information displayed in the SLIP start up
     *                                  message.
     *
     *  multicastMemberTimeout Multicast membership idle timeout.
     *
     *  poolName The name of the pool given by the user, a standard null
     *                                  terminated ASCII string.
     *
     *  authBootHost The IP address of the authentication boot host.
     *
     *  authBootHost2 The IP address of the secondary authentication boot host.
     *
     *  authBootPort The UDP port to use for RADIUS authentication.
     *
     *  etherIFB The type of phyical interface, UTP, COAX, AUI
     *
     *  ipAddressB The IP Address of the 2nd ethernet.
     *
     *  netmaskB The Network Mask of this interface.
     *
     *  ipAddress2B Alternate IP Address of the 2nd ethernet.
     *
     *  netmask2B Netmask for the alternate IP address.
     *
     *  ripModeB Specify how RIP is to be used on the ethernet. Options are
     *                                  off, on, ignore received routing
     *                                  updates, don't send routing updates.
     *
     *  proxyModeB Specify how proxy arp is to be used.
     *
     *  filterB The number of the filter profile assigned to this interface.
     *
     *  ipxFrameTypeB The IPX Frame Type we are configured to recognize.
     *
     *  ipxEtherNetNumberB
     *
     *  sapFilterB The number of the IPX SAP Filter assigned to this interface.
     *
     *  ipxType20B Propagate IPX Type 20 packets (NetBIOS).
     *
     *  natLan Which NAT Lan option is to be use.
     *
     *  poolOspfAdvType The OSPF advertisement type to be used with pool
     *                                  summaries.
     *
     *  ext The overflow area for mibslot definitions.
     */

#if ( MDF_ETHERNET == FYES )
#include "mibfiltr.h"   /* for filterPolicy fp */

typedef struct {
    Boolean             enabled;
    filterPolicy        fp;
} filterGlobalConf;


     /*
      * add switch for all filter
      */
typedef struct  st_filter_switch{

    /*
     * *cast filter. 
     * (multicast, broadcast or unicast filter).
     */
    Boolean                             multicastFilterEnabled;
    Boolean                             multicastFilterOtherForward;
    Boolean                             igmpDenyEnabled;


    /*
     * mac filter:
     * 
     * source mac filter should be added here.
     */
    //filterGloabalConf     macFilter;


    /*
     * added Internet-Layer filters below.
     */



    /*
     * add Transport-Layer filters below(Tcp/Udp and so on).
     */


    /*
     * add Application-Layer filers below.
     */

    /*
     * added by llliu@080428.
     * for Dns-Filter;
     */
    filterGlobalConf                    dnsFilter;

    /* add for allowing exceptive qq to connect internet*/
    Boolean				qqEnabled;


}st_filterSwitch;


#if (LOG == FYES)

/* add for logging according the choosed switch */
typedef struct st_log_switch{
    Boolean				netActionLogEnabled;
    Boolean				httpLogEnabled;
    Boolean				telnetLogEnabled;
    Boolean				dhcpLogEnabled;
    Boolean				arpLogEnabled;
    Boolean				noticeLogEnabled;
    Boolean				dialLogEnabled;
    Boolean				natLogEnabled;
    Boolean				floodLogEnabled;
    Boolean				otherLogEnabled;
}st_logSwitch;
#endif



typedef struct etherSlotProfile {
#line 2887 "mibslot.mdf"
    SlotProfileHeader                   header;
#line 2891 "mibslot.mdf"
#if ( MDF_IP == FYES )
    IpAddress                           ipAddress;
    Word	                        mtu;
#endif /* ( MDF_IP == FYES ) */
#line 2896 "mibslot.mdf"
#if ( MDF_IP == FYES )
    IpAddress                           netmask;
#endif /* ( MDF_IP == FYES ) */
#line 2901 "mibslot.mdf"
#if (( MDF_IP == FYES ) && ( PLATFORM & ( MPORT | P50 | PDSL | P25 | M200 | TNT )))
    IpAddress                           ipAddress2;
#endif /* (( MDF_IP == FYES ) && ( PLATFORM & ( MPORT | P50 | PDSL | P25 | M200 | TNT ))) */
#line 2906 "mibslot.mdf"
#if (( MDF_IP == FYES ) && ( PLATFORM & ( MPORT | P50 | PDSL | P25 | M200 | TNT )))
    IpAddress                           netmask2;
#endif /* (( MDF_IP == FYES ) && ( PLATFORM & ( MPORT | P50 | PDSL | P25 | M200 | TNT ))) */
#line 2911 "mibslot.mdf"
#if (( MDF_IP == FYES ) && ( MDF_DNS == FYES ))
    char                                domainName[ MAX_DOMAIN_NAME_LENGTH + 1 ];
#endif /* (( MDF_IP == FYES ) && ( MDF_DNS == FYES )) */
#line 2916 "mibslot.mdf"
#if (( MDF_IP == FYES ) && ( MDF_DNS == FYES ))
    IpAddress                           primaryDnsServer;
#endif /* (( MDF_IP == FYES ) && ( MDF_DNS == FYES )) */
#line 2921 "mibslot.mdf"
#if (( MDF_IP == FYES ) && ( MDF_DNS == FYES ))
    IpAddress                           secondaryDnsServer;
#endif /* (( MDF_IP == FYES ) && ( MDF_DNS == FYES )) */
#line 2927 "mibslot.mdf"
#if ( MDF_IP == FYES )
    IpAddress                           primaryNetBiosNS;
#endif /* ( MDF_IP == FYES ) */
#line 2932 "mibslot.mdf"
#if ( MDF_IP == FYES )
    IpAddress                           secondaryNetBiosNS;
#endif /* ( MDF_IP == FYES ) */
#line 2937 "mibslot.mdf"
#if IP_RD_TC_COND
    AuthType                            authType;
    radiusRefreshType			authLoadConfig;
#endif /* IP_RD_TC_COND */
#line 2942 "mibslot.mdf"
#if IP_RD_TC_COND
    IpAddress                           authHost;
#endif /* IP_RD_TC_COND */
#line 2947 "mibslot.mdf"
#if IP_RD_TC_COND
    IpAddress                           authHost2;
#endif /* IP_RD_TC_COND */
#line 2952 "mibslot.mdf"
#if IP_RD_TC_COND
    IpAddress                           authHost3;
#endif /* IP_RD_TC_COND */
#line 2957 "mibslot.mdf"
#if IP_RD_TC_COND
    Word                                authPort;
#endif /* IP_RD_TC_COND */
#line 2962 "mibslot.mdf"
#if IP_RD_TC_COND
    Word                                authSrcPort;
#endif /* IP_RD_TC_COND */
#line 2969 "mibslot.mdf"
#if IP_RD_TC_COND
    char                                authKey[ MAX_PASSWORD_LENGTH + 2 ];
#endif /* IP_RD_TC_COND */
#line 2974 "mibslot.mdf"
#if IP_RD_TC_COND
    Boolean                             authPool;
#endif /* IP_RD_TC_COND */
#line 2981 "mibslot.mdf"
#if IP_RD_TC_COND
    Word                                authTimeout;
#endif /* IP_RD_TC_COND */
#line 2986 "mibslot.mdf"
#if IP_RD_TC_C_COND
    Boolean                             authRspRequired;
#endif /* IP_RD_TC_C_COND */
#line 2992 "mibslot.mdf"
#if ( MDF_CLID == FYES )
    Boolean                             clidFailBusy;
#endif /* ( MDF_CLID == FYES ) */
#line 2996 "mibslot.mdf"
#if ( MDF_CLID == FYES )
    Boolean                             clidTimeoutBusy;
#endif /* ( MDF_CLID == FYES ) */
#line 3000 "mibslot.mdf"
#if RADIUS_COND
    AcctType                            acctType;
#endif /* RADIUS_COND */
#line 3005 "mibslot.mdf"
#if RADIUS_COND
    IpAddress                           acctHost;
#endif /* RADIUS_COND */
#line 3010 "mibslot.mdf"
#if RADIUS_COND
    IpAddress                           acctHost2;
#endif /* RADIUS_COND */
#line 3015 "mibslot.mdf"
#if RADIUS_COND
    IpAddress                           acctHost3;
#endif /* RADIUS_COND */
#line 3020 "mibslot.mdf"
#if RADIUS_COND
    Word                                acctPort;
#endif /* RADIUS_COND */
#line 3025 "mibslot.mdf"
#if RADIUS_COND
    Word                                acctSrcPort;
#endif /* RADIUS_COND */
#line 3032 "mibslot.mdf"
#if RADIUS_COND
    char                                acctKey[ MAX_PASSWORD_LENGTH + 2 ];
#endif /* RADIUS_COND */
#line 3037 "mibslot.mdf"
#if RADIUS_COND
    Word                                acctTimeout;
#endif /* RADIUS_COND */
#line 3043 "mibslot.mdf"
#if RADIUS_COND
    Word                                sessInterval;
#endif /* RADIUS_COND */
#line 3048 "mibslot.mdf"
#if ( MDF_IP == FYES )
    IpAddress                           logHost_1;
//      char                            logHost[MAX_DOMAIN_NAME_LENGTH + 1]; //cyh@070307  move to last line
#endif /* ( MDF_IP == FYES ) */
#line 3053 "mibslot.mdf"
#if ( MDF_IP == FYES )
    int                                 logFacility;
#endif /* ( MDF_IP == FYES ) */
#line 3058 "mibslot.mdf"
#if ( MDF_IP == FYES )
    Word                                logPriority;
#endif /* ( MDF_IP == FYES ) */
#line 3063 "mibslot.mdf"
#if ( MDF_IP == FYES )
    Boolean                             sharedProf;
#endif /* ( MDF_IP == FYES ) */
#line 3069 "mibslot.mdf"
#if ( MDF_IP == FYES )
    Boolean                             assignOnly;
#endif /* ( MDF_IP == FYES ) */
#line 3075 "mibslot.mdf"
#if ( MDF_IP == FYES )
    Boolean                             poolSummary;
#endif /* ( MDF_IP == FYES ) */
#line 3083 "mibslot.mdf"
#if ( MDF_IP == FYES )
    IpAddress                           assignBase[ MAX_NVRAM_ASSIGN_POOL ];
#endif /* ( MDF_IP == FYES ) */
#line 3089 "mibslot.mdf"
#if ( MDF_IP == FYES )
    Word                                assignCount[ MAX_NVRAM_ASSIGN_POOL ];
#endif /* ( MDF_IP == FYES ) */
#line 3095 "mibslot.mdf"
#if ( MDF_IP == FYES )
    Word                                filter;
#endif /* ( MDF_IP == FYES ) */
#line 3100 "mibslot.mdf"
#if ( MDF_IP == FYES )
    RoutingMode                         ripMode;
#endif /* ( MDF_IP == FYES ) */
#line 3106 "mibslot.mdf"
#if ( MDF_IP == FYES )
    RipPolicy                           ripPolicy;
#endif /* ( MDF_IP == FYES ) */
#line 3112 "mibslot.mdf"
#if ( MDF_OSPF == FYES )
    MibProfOspf                         ospf;
#endif /* ( MDF_OSPF == FYES ) */
#line 3117 "mibslot.mdf"
#if ( MDF_OSPF == FYES )
    MibProfOspfg                        ospfg;
#endif /* ( MDF_OSPF == FYES ) */
#line 3122 "mibslot.mdf"
#if ( MDF_IP == FYES )
    ProxyMode                           proxyMode;
#endif /* ( MDF_IP == FYES ) */
#line 3127 "mibslot.mdf"
#if ( MDF_IP == FYES )
    Boolean                             ignoreDefRoute;
#endif /* ( MDF_IP == FYES ) */
#line 3133 "mibslot.mdf"
#if ( MDF_IP == FYES )
    Boolean                             ripSummary;
#endif /* ( MDF_IP == FYES ) */
#line 3138 "mibslot.mdf"
#if ( MDF_IP == FYES )
    Boolean                             ripMulticast;
#endif /* ( MDF_IP == FYES ) */
#line 3143 "mibslot.mdf"
#if (( MDF_IP == FYES ) && ( MDF_TERMSRV == FYES ))
    char                                sysPasswd[ MAX_PASSWORD_LENGTH + 2 ];
#endif /* (( MDF_IP == FYES ) && ( MDF_TERMSRV == FYES )) */
#line 3148 "mibslot.mdf"
#if (( MDF_IP == FYES ) && ( MDF_TERMSRV == FYES ))
    char                                banner[ MAX_BANNER_LEN + 2 ];
#endif /* (( MDF_IP == FYES ) && ( MDF_TERMSRV == FYES )) */
#line 3153 "mibslot.mdf"
#if (( MDF_IP == FYES ) && ( MDF_TERMSRV == FYES ) && ( MDF_ASYNC == FYES ))
    char                                tsLoginPrompt[ MAX_TS_LOGIN_PROMPT_LENGTH + 1 ];
#endif /* (( MDF_IP == FYES ) && ( MDF_TERMSRV == FYES ) && ( MDF_ASYNC == FYES )) */
#line 3157 "mibslot.mdf"
#if (( MDF_IP == FYES ) && ( MDF_TERMSRV == FYES ) && ( MDF_ASYNC == FYES ))
    char                                tsPasswdPrompt[ MAX_TS_PASSWD_PROMPT_LENGTH + 1 ];
#endif /* (( MDF_IP == FYES ) && ( MDF_TERMSRV == FYES ) && ( MDF_ASYNC == FYES )) */
#line 3161 "mibslot.mdf"
#if (( MDF_IP == FYES ) && ( MDF_TERMSRV == FYES ))
    char                                tsPrompt[ MAX_TS_PROMPT_LENGTH + 1 ];
#endif /* (( MDF_IP == FYES ) && ( MDF_TERMSRV == FYES )) */
#line 3166 "mibslot.mdf"
#if (( MDF_IP == FYES ) && ( MDF_TERMSRV == FYES ))
    char                                tsTerm[ MAX_TS_TERM_LENGTH + 1 ];
#endif /* (( MDF_IP == FYES ) && ( MDF_TERMSRV == FYES )) */
#line 3171 "mibslot.mdf"
#if (( MDF_IP == FYES ) && ( MDF_TERMSRV == FYES ))
    Boolean                             tsEnabled;
#endif /* (( MDF_IP == FYES ) && ( MDF_TERMSRV == FYES )) */
#line 3176 "mibslot.mdf"
#if (( MDF_IP == FYES ) && ( MDF_TERMSRV == FYES ))
    Boolean                             tsPppEnabled;
#endif /* (( MDF_IP == FYES ) && ( MDF_TERMSRV == FYES )) */
#line 3182 "mibslot.mdf"
#if (( MDF_IP == FYES ) && ( MDF_TERMSRV == FYES ))
    Boolean                             tsSlipEnabled;
#endif /* (( MDF_IP == FYES ) && ( MDF_TERMSRV == FYES )) */
#line 3187 "mibslot.mdf"
#if (( MDF_IP == FYES ) && ( MDF_TERMSRV == FYES ))
    Boolean                             tsTelnetEnabled;
#endif /* (( MDF_IP == FYES ) && ( MDF_TERMSRV == FYES )) */
#line 3192 "mibslot.mdf"
#if (( MDF_IP == FYES ) && ( MDF_TERMSRV == FYES ))
    Boolean                             tsRloginEnabled;
#endif /* (( MDF_IP == FYES ) && ( MDF_TERMSRV == FYES )) */
#line 3197 "mibslot.mdf"
#if (( MDF_IP == FYES ) && ( MDF_TERMSRV == FYES ))
    Boolean                             tsClearCall;
#endif /* (( MDF_IP == FYES ) && ( MDF_TERMSRV == FYES )) */
#line 3203 "mibslot.mdf"
#if (( MDF_IP == FYES ) && ( MDF_TERMSRV == FYES ))
    TsTelnetMode                        tsTelnetMode;
#endif /* (( MDF_IP == FYES ) && ( MDF_TERMSRV == FYES )) */
#line 3208 "mibslot.mdf"
#if (( MDF_IP == FYES ) && ( MDF_TERMSRV == FYES ))
    Boolean                             tsBufferChars;
#endif /* (( MDF_IP == FYES ) && ( MDF_TERMSRV == FYES )) */
#line 3213 "mibslot.mdf"
#if (( MDF_IP == FYES ) && ( MDF_TERMSRV == FYES ))
    Boolean                             tsRemote;
#endif /* (( MDF_IP == FYES ) && ( MDF_TERMSRV == FYES )) */
#line 3218 "mibslot.mdf"
#if (( MDF_IP == FYES ) && ( MDF_TERMSRV == FYES ))
    Boolean                             tsAutoTelnet;
#endif /* (( MDF_IP == FYES ) && ( MDF_TERMSRV == FYES )) */
#line 3224 "mibslot.mdf"
#if TERMSVR_COND
    Word                                timeoutForAutoPPP;
#endif /* TERMSVR_COND */
#line 3230 "mibslot.mdf"
#if ( ( TERMSVR_COND ) || ( ( TCP_MODEM == FYES ) && ( PLATFORM & P50 ) ) )
    ImmediateServiceType                tsImmediateServiceType;
#endif /* ( ( TERMSVR_COND ) || ( ( TCP_MODEM == FYES ) && ( PLATFORM & P50 ) ) ) */
#line 3235 "mibslot.mdf"
#if TERMSVR_COND
    char                                tsImmediateHost[ MAX_DOMAIN_NAME_LENGTH + 1 ];
#endif /* TERMSVR_COND */
#line 3241 "mibslot.mdf"
#if TERMSVR_COND
    Word                                tsImmediateTcpPort;
#endif /* TERMSVR_COND */
#line 3246 "mibslot.mdf"
#if TERMSVR_COND
    Boolean                             tsTelnetHostAuth;
#endif /* TERMSVR_COND */
#line 3253 "mibslot.mdf"
#if TERMSVR_COND
    TsErrorCorrectionMode               tsV42bis;
#endif /* TERMSVR_COND */
#line 3258 "mibslot.mdf"
#if TERMSVR_COND
    Boolean                             ts7Even;
#endif /* TERMSVR_COND */
#line 3263 "mibslot.mdf"
#if TERMSVR_COND
    Boolean                             tsSilent;
#endif /* TERMSVR_COND */
#line 3268 "mibslot.mdf"
#if TERMSVR_COND
    Boolean                             tsMenuMode;
#endif /* TERMSVR_COND */
#line 3274 "mibslot.mdf"
#if TERMSVR_COND
    Boolean                             tsToggleScreen;
#endif /* TERMSVR_COND */
#line 3280 "mibslot.mdf"
#if TERMSVR_COND
    TsPppInfo                           pppMsg;
#endif /* TERMSVR_COND */
#line 3285 "mibslot.mdf"
#if TERMSVR_COND
    Boolean                             clearScrn;
#endif /* TERMSVR_COND */
#line 3290 "mibslot.mdf"
#if TERMSVR_COND
    Boolean                             wanBootpReply;
#endif /* TERMSVR_COND */
#line 3295 "mibslot.mdf"
#if ( MDF_TERMSRV == FYES )
    TsSecureMode                        tsSecure;
#endif /* ( MDF_TERMSRV == FYES ) */
#line 3300 "mibslot.mdf"
#if TERMSVR_COND
    char                                host1Addr[ TS_TEXT_LEN + 1 ];
#endif /* TERMSVR_COND */
#line 3306 "mibslot.mdf"
#if TERMSVR_COND
    char                                host1Text[ TS_TEXT_LEN + 1 ];
#endif /* TERMSVR_COND */
#line 3312 "mibslot.mdf"
#if TERMSVR_COND
    char                                host2Addr[ TS_TEXT_LEN + 1 ];
#endif /* TERMSVR_COND */
#line 3318 "mibslot.mdf"
#if TERMSVR_COND
    char                                host2Text[ TS_TEXT_LEN + 1 ];
#endif /* TERMSVR_COND */
#line 3324 "mibslot.mdf"
#if TERMSVR_COND
    char                                host3Addr[ TS_TEXT_LEN + 1 ];
#endif /* TERMSVR_COND */
#line 3330 "mibslot.mdf"
#if TERMSVR_COND
    char                                host3Text[ TS_TEXT_LEN + 1 ];
#endif /* TERMSVR_COND */
#line 3336 "mibslot.mdf"
#if TERMSVR_COND
    char                                host4Addr[ TS_TEXT_LEN + 1 ];
#endif /* TERMSVR_COND */
#line 3342 "mibslot.mdf"
#if TERMSVR_COND
    char                                host4Text[ TS_TEXT_LEN + 1 ];
#endif /* TERMSVR_COND */
#line 3348 "mibslot.mdf"
#if TERMSVR_COND
    char                                thirdPrompt[ MAX_PASSWORD_LENGTH + 2 ];
#endif /* TERMSVR_COND */
#line 3354 "mibslot.mdf"
#if TERMSVR_COND
    ThirdPromptSequence                 thirdPromptSequence;
#endif /* TERMSVR_COND */
#line 3360 "mibslot.mdf"
#if ( MDF_IP == FYES )
    Boolean                             rarpEnabled;
#endif /* ( MDF_IP == FYES ) */
#line 3365 "mibslot.mdf"
#if ( MDF_IP == FYES )
    Boolean                             bootpEnabled;
#endif /* ( MDF_IP == FYES ) */
#line 3371 "mibslot.mdf"
#if ( MDF_IP == FYES )
    Boolean                             bridgingEnabled;
#endif /* ( MDF_IP == FYES ) */
#line 3377 "mibslot.mdf"
#if ( MDF_IP == FYES )
    Boolean                             ipxRoutingEnabled;
#endif /* ( MDF_IP == FYES ) */
#line 3384 "mibslot.mdf"
#if ( MDF_IP == FYES )
    Boolean                             fill;
#endif /* ( MDF_IP == FYES ) */
#line 3389 "mibslot.mdf"
#if ( MDF_IP == FYES )
    Boolean                             logEnabled;
#endif /* ( MDF_IP == FYES ) */
#line 3394 "mibslot.mdf"
#if ( MDF_IP == FYES )
    char                                telnetPassword[ MAX_PASSWORD_LENGTH + 2 ];
#endif /* ( MDF_IP == FYES ) */
#line 3399 "mibslot.mdf"
#if ( PLATFORM & MPORT )
    char                                etherAnsNumber1[ MAX_ETHER_ANS_NUMBER + 1 ];
#endif /* ( PLATFORM & MPORT ) */
#line 3405 "mibslot.mdf"
#if ( PLATFORM & MPORT )
    char                                etherAnsNumber2[ MAX_ETHER_ANS_NUMBER + 1 ];
#endif /* ( PLATFORM & MPORT ) */
#line 3411 "mibslot.mdf"
#if ( PLATFORM & MPORT )
    char                                etherAnsNumber3[ MAX_ETHER_ANS_NUMBER + 1 ];
#endif /* ( PLATFORM & MPORT ) */
#line 3417 "mibslot.mdf"
#if ( PLATFORM & MPORT )
    char                                etherAnsNumber4[ MAX_ETHER_ANS_NUMBER + 1 ];
#endif /* ( PLATFORM & MPORT ) */
#line 3423 "mibslot.mdf"
    EtherIF                             etherIF;
#line 3427 "mibslot.mdf"
#if ( MDF_SNMP == FYES )
    char                                readCommunity[ MAX_COMM_NAME_LENGTH + 1 ];
#endif /* ( MDF_SNMP == FYES ) */
#line 3432 "mibslot.mdf"
#if ( MDF_SNMP == FYES )
    char                                readWriteCommunity[ MAX_COMM_NAME_LENGTH + 1 ];
#endif /* ( MDF_SNMP == FYES ) */
#line 3437 "mibslot.mdf"
#if ( MDF_SNMP == FYES )
    Boolean                             snmpEnabled;
    Boolean                             snmpSecurity;
#endif /* ( MDF_SNMP == FYES ) */
#line 3445 "mibslot.mdf"
#if ( MDF_SNMP == FYES )
    IpAddress                           readAccessHost[ MAX_SNMP_ACCESS_HOST ];
    IpAddress                           readAccessMask[ MAX_SNMP_ACCESS_HOST ];
#endif /* ( MDF_SNMP == FYES ) */
#line 3450 "mibslot.mdf"
#if ( MDF_SNMP == FYES )
    IpAddress                           writeAccessHost[ MAX_SNMP_ACCESS_HOST ];
    IpAddress                           writeAccessMask[ MAX_SNMP_ACCESS_HOST ];
#endif /* ( MDF_SNMP == FYES ) */
#line 3455 "mibslot.mdf"
#if ( MDF_WANX25 == FYES )
    IpAddress                           x25WanAddress;
#endif /* ( MDF_WANX25 == FYES ) */
#line 3460 "mibslot.mdf"
#if ( MDF_IPX_SPOOF == FYES || MDF_IPX_ROUTE == FYES )
    IpxFrameType                        ipxFrameType;
#endif /* ( MDF_IPX_SPOOF == FYES || MDF_IPX_ROUTE == FYES ) */
#line 3465 "mibslot.mdf"
#if ( MDF_IPX_ROUTE == FYES )
    LongWord                            ipxEtherNetNumber;
#endif /* ( MDF_IPX_ROUTE == FYES ) */
#line 3469 "mibslot.mdf"
#if ( MDF_IPX_ROUTE == FYES )
    LongWord                            ipxDialinPool;
#endif /* ( MDF_IPX_ROUTE == FYES ) */
#line 3473 "mibslot.mdf"
#if ( PLATFORM & MPORT )
    int                                 dialPlan;
#endif /* ( PLATFORM & MPORT ) */
#line 3477 "mibslot.mdf"
#if ( PLATFORM & MPORT )
    Boolean                             trunkGroupsNA;
#endif /* ( PLATFORM & MPORT ) */
#line 3481 "mibslot.mdf"
#if ( MDF_LCP_CHALLENGE_CLIENT == FYES )
    Boolean                             pwsEnabled;
#endif /* ( MDF_LCP_CHALLENGE_CLIENT == FYES ) */
#line 3485 "mibslot.mdf"
#if ( MDF_LCP_CHALLENGE_CLIENT == FYES )
    IpAddress                           pwsHost;
#endif /* ( MDF_LCP_CHALLENGE_CLIENT == FYES ) */
#line 3489 "mibslot.mdf"
#if ( MDF_LCP_CHALLENGE_CLIENT == FYES )
    Word                                pwsPort;
#endif /* ( MDF_LCP_CHALLENGE_CLIENT == FYES ) */
#line 3493 "mibslot.mdf"
    Boolean                             ignoreIcmpRedirects;
#line 3498 "mibslot.mdf"
    Boolean                             dropSourceRoutedIpPackets;
#line 3502 "mibslot.mdf"
#if ( MDF_LMODEM == FYES )
    Boolean                             ringback;
#endif /* ( MDF_LMODEM == FYES ) */
#line 3508 "mibslot.mdf"
#if ( MDF_DHCP_SPOOF == FYES )
    Boolean                             dhcpSpoofEnabled;
#endif /* ( MDF_DHCP_SPOOF == FYES ) */
#line 3512 "mibslot.mdf"
#if ( MDF_DHCP_SPOOF == FYES )
    Boolean                             dhcpSpoofPnpEnabled;
#endif /* ( MDF_DHCP_SPOOF == FYES ) */
#line 3516 "mibslot.mdf"
#if ( MDF_DHCP_SPOOF == FYES )
    IpAddress                           dhcpSpoofIpAddress;
#endif /* ( MDF_DHCP_SPOOF == FYES ) */
#line 3520 "mibslot.mdf"
#if ( MDF_DHCP_SPOOF == FYES )
    IpAddress                           dhcpSpoofNetmask;
#endif /* ( MDF_DHCP_SPOOF == FYES ) */
#line 3524 "mibslot.mdf"
#if ( MDF_DHCP_SPOOF == FYES )
// zhz@20021211, to support longer lease time
//  Word                                dhcpSpoofRenewalTime;
    Uint32                              dhcpSpoofRenewalTime;
#endif /* ( MDF_DHCP_SPOOF == FYES ) */
#line 3528 "mibslot.mdf"
#if ( MDF_DHCP_SPOOF == FYES )
    Boolean                             dhcpSpoofBecomeDefaultRouter;
    IpAddress                           dhcpSpoofGateway;
#endif /* ( MDF_DHCP_SPOOF == FYES ) */
#line 3534 "mibslot.mdf"
#if ( MDF_DHCP_SPOOF == FYES )
    Boolean                             dhcpSpoofDialIfLinkDown;
#endif /* ( MDF_DHCP_SPOOF == FYES ) */
#line 3539 "mibslot.mdf"
#if ( MDF_DHCP_SPOOF == FYES )
    Boolean                             alwaysSpoof;
#endif /* ( MDF_DHCP_SPOOF == FYES ) */
#line 3544 "mibslot.mdf"
#if ( MDF_ATMP == FYES )
    AtmpAgentMode                       atmpAgentMode;
#endif /* ( MDF_ATMP == FYES ) */
#line 3549 "mibslot.mdf"
#if ( MDF_ATMP == FYES )
    AtmpHomeAgentType                   atmpAgentType;
#endif /* ( MDF_ATMP == FYES ) */
#line 3554 "mibslot.mdf"
#if ( MDF_ATMP == FYES )
    Word                                atmpUdpPort;
#endif /* ( MDF_ATMP == FYES ) */
#line 3559 "mibslot.mdf"
#if ( MDF_ATMP == FYES )
    char                                atmpHomeAgentPassword[ MAX_PASSWORD_LENGTH + 2 ];
#endif /* ( MDF_ATMP == FYES ) */
#line 3564 "mibslot.mdf"
#if ( MDF_ATMP == FYES )
    Boolean                             atmpSapReply;
#endif /* ( MDF_ATMP == FYES ) */
#line 3568 "mibslot.mdf"
#if ( MDF_IPX_ROUTE == FYES )
    Word                                sapFilter;
#endif /* ( MDF_IPX_ROUTE == FYES ) */
#line 3573 "mibslot.mdf"
#if ( (MDF_LMODEM_TSDIALOUT == FYES) && (!(USERIF & CLI)))
    Boolean                             tsModemDialout;
#endif /* ( (MDF_LMODEM_TSDIALOUT == FYES) && (!(USERIF & CLI))) */
#line 3578 "mibslot.mdf"
#if ( MDF_ARAP == FYES || MDF_APPLE_ROUTE == FYES )
    Boolean                             appletalkAra;
#endif /* ( MDF_ARAP == FYES || MDF_APPLE_ROUTE == FYES ) */
#line 3583 "mibslot.mdf"
#if TERMSVR_COND
    TsMaxBaudRate                       tsMaxBaud;
#endif /* TERMSVR_COND */
#line 3588 "mibslot.mdf"
#if (MDF_RADIUS_SERV == FYES)
    Boolean                             radServEnable;
#endif /* (MDF_RADIUS_SERV == FYES) */
#line 3593 "mibslot.mdf"
#if (MDF_RADIUS_SERV == FYES)
    Word                                radServPort;
#endif /* (MDF_RADIUS_SERV == FYES) */
#line 3598 "mibslot.mdf"
#if (MDF_ARAP == FYES || MDF_APPLE_ROUTE == FYES)
    Word                                hintNetLo;
#endif /* (MDF_ARAP == FYES || MDF_APPLE_ROUTE == FYES) */
#line 3603 "mibslot.mdf"
#if (MDF_ARAP == FYES || MDF_APPLE_ROUTE == FYES)
    Word                                hintNetHi;
#endif /* (MDF_ARAP == FYES || MDF_APPLE_ROUTE == FYES) */
#line 3608 "mibslot.mdf"
#if (MDF_ARAP == FYES || MDF_APPLE_ROUTE == FYES)
    LongWord                            hintNetNode;
#endif /* (MDF_ARAP == FYES || MDF_APPLE_ROUTE == FYES) */
#line 3613 "mibslot.mdf"
#if (MDF_ARAP == FYES || MDF_APPLE_ROUTE == FYES)
    ZoneNameType                        hintZone;
#endif /* (MDF_ARAP == FYES || MDF_APPLE_ROUTE == FYES) */
#line 3618 "mibslot.mdf"
#if (MDF_SNTP == FYES)
    IpAddress                           sntpHost[ MAX_SNTP_HOSTS ];
#endif /* (MDF_SNTP == FYES) */
#line 3623 "mibslot.mdf"
#if (MDF_SNTP == FYES)
    SntpMode                            sntpEnabled;
#endif /* (MDF_SNTP == FYES) */
#line 3628 "mibslot.mdf"
#if (MDF_SNTP == FYES)
    UtcOffset                           tzMode;
    Uint32			        sntpInterval;
#endif /* (MDF_SNTP == FYES) */
#line 3633 "mibslot.mdf"
#if ( MDF_NAT == FYES )
    Boolean                             slotNatRouting;
#endif /* ( MDF_NAT == FYES ) */
#if ( MDF_NAT == FYES )
    char                                slotNatProfile[ MAX_HOST_NAME_LENGTH + 1 ];
#endif /* ( MDF_NAT == FYES ) */
#if ((MDF_IP == FYES) && (MDF_DNS == FYES))
    Boolean                             dnsListAttempt;
#endif /* ((MDF_IP == FYES) && (MDF_DNS == FYES)) */
#line 3649 "mibslot.mdf"
#if ((MDF_IPX_ROUTE == FYES) && (PLATFORM & (P25 | P50 | PDSL)))
    Boolean                             sapProxy;
#endif /* ((MDF_IPX_ROUTE == FYES) && (PLATFORM & (P25 | P50 | PDSL))) */
#line 3654 "mibslot.mdf"
#if ((MDF_IPX_ROUTE == FYES) && (PLATFORM & (P25 | P50 | PDSL)))
    LongWord                            sapProxyNets[ MAX_SAP_PROXY_NETS ];
#endif /* ((MDF_IPX_ROUTE == FYES) && (PLATFORM & (P25 | P50 | PDSL))) */
#line 3659 "mibslot.mdf"
#if ( MDF_IP== FYES)
    Boolean                             udpCksum;
    Boolean                             ipFragment;
#endif /* ( MDF_IP== FYES) */
#line 3664 "mibslot.mdf"
#if ( MDF_PPTP == FYES )
    PptpMode                            pptpMode;
#endif /* ( MDF_PPTP == FYES ) */
#line 3669 "mibslot.mdf"
#if ( MDF_PPTP == FYES ) || ( MDF_L2TP == FYES )
    char                                pptpServers[ MAX_PPTP_SERVERS ][ MAX_HOST_NAME_LENGTH + 1 ];
#endif /* ( MDF_PPTP == FYES ) || ( MDF_L2TP == FYES ) */
#line 3674 "mibslot.mdf"
#if TERMSVR_COND
    TsMdmTrnLevel                       tsMdmTrnLevel;
#endif /* TERMSVR_COND */
#line 3679 "mibslot.mdf"
#if (MDF_IP == FYES)
    Boolean                             dialoutPoison;
#endif /* (MDF_IP == FYES) */
#line 3684 "mibslot.mdf"
#if (( MDF_IP == FYES ) && ( MDF_TERMSRV == FYES ))
    Boolean                             tsLocalEcho;
#endif /* (( MDF_IP == FYES ) && ( MDF_TERMSRV == FYES )) */
#line 3689 "mibslot.mdf"
#if ( PLATFORM & MPORT ) && ( MDF_LMODEM == FYES )
    Boolean                             cellFirst;
#endif /* ( PLATFORM & MPORT ) && ( MDF_LMODEM == FYES ) */
#line 3696 "mibslot.mdf"
#if ( PLATFORM & MPORT ) && ( MDF_LMODEM == FYES )
    CellLevel                           cellLevel;
#endif /* ( PLATFORM & MPORT ) && ( MDF_LMODEM == FYES ) */
#line 3702 "mibslot.mdf"
#if RADIUS_COND
    AcctBaseType                        acctIDBase;
#endif /* RADIUS_COND */
#line 3707 "mibslot.mdf"
#if TERMSVR_COND
    Boolean                             directPPP;
#endif /* TERMSVR_COND */
#line 3713 "mibslot.mdf"
#if (MDF_IP_ROUTE == FYES)
    LongWord                            staticPref;
#endif /* (MDF_IP_ROUTE == FYES) */
#line 3718 "mibslot.mdf"
#if (MDF_IP_ROUTE == FYES)
    LongWord                            ripPref;
#endif /* (MDF_IP_ROUTE == FYES) */
#line 3723 "mibslot.mdf"
#if ((MDF_IP_ROUTE == FYES) && (MDF_OSPF == FYES))
    LongWord                            ospfPref;
#endif /* ((MDF_IP_ROUTE == FYES) && (MDF_OSPF == FYES)) */
#line 3728 "mibslot.mdf"
#if ((MDF_IP_ROUTE == FYES) && (MDF_OSPF == FYES))
    LongWord                            ospfAsePref;
#endif /* ((MDF_IP_ROUTE == FYES) && (MDF_OSPF == FYES)) */
#line 3733 "mibslot.mdf"
#if ((MDF_IP_ROUTE == FYES) && (MDF_OSPF == FYES))
    LongWord                            ripTag;
#endif /* ((MDF_IP_ROUTE == FYES) && (MDF_OSPF == FYES)) */
#line 3738 "mibslot.mdf"
#if ((MDF_IP_ROUTE == FYES) && (MDF_OSPF == FYES))
    LongWord                            ripAseType;
#endif /* ((MDF_IP_ROUTE == FYES) && (MDF_OSPF == FYES)) */
#line 3743 "mibslot.mdf"
#if ( MDF_BOOTP_RELAY == FYES )
    Boolean                             bootpRelayEnabled;
#endif /* ( MDF_BOOTP_RELAY == FYES ) */
#line 3748 "mibslot.mdf"
#if ( MDF_BOOTP_RELAY == FYES )
    IpAddress                           bootpServers[ MAX_BOOTP_SERVERS ];
#endif /* ( MDF_BOOTP_RELAY == FYES ) */
#line 3753 "mibslot.mdf"
#if ((MDF_LMODEM_TSDIALOUT == FYES) && (!(USERIF & CLI)))
    Boolean                             tsImmediateModem;
#endif /* ((MDF_LMODEM_TSDIALOUT == FYES) && (!(USERIF & CLI))) */
#line 3758 "mibslot.mdf"
#if ( (MDF_LMODEM_TSDIALOUT == FYES) && (!(USERIF & CLI)))
    Word                                immediateModemPort;
#endif /* ( (MDF_LMODEM_TSDIALOUT == FYES) && (!(USERIF & CLI))) */
#line 3763 "mibslot.mdf"
#if ((MDF_MROUTING == FYES) || (MDF_MTROUTING == FYES))
    Boolean                             multicastForwarding;
#endif /* ((MDF_MROUTING == FYES) || (MDF_MTROUTING == FYES)) */
#line 3768 "mibslot.mdf"
#if ((MDF_MROUTING == FYES) || (MDF_MTROUTING == FYES))
    char                                mboneProfile[ MAX_HOST_NAME_LENGTH + 1 ];
#endif /* ((MDF_MROUTING == FYES) || (MDF_MTROUTING == FYES)) */
#line 3773 "mibslot.mdf"
#if ((MDF_MROUTING == FYES) && (MDF_IGMP == FYES))
    Boolean                             multicastAllowed;
#endif /* ((MDF_MROUTING == FYES) && (MDF_IGMP == FYES)) */
#line 3778 "mibslot.mdf"
#if ( MDF_IPX_ROUTE == FYES )
    Boolean                             ipxType20;
#endif /* ( MDF_IPX_ROUTE == FYES ) */
#line 3783 "mibslot.mdf"
#if ( MDF_STACKING == FYES )
    char                                stackName[ MAX_STACK_NAME_LENGTH + 1 ];
#endif /* ( MDF_STACKING == FYES ) */
#line 3788 "mibslot.mdf"
#if ( MDF_STACKING == FYES )
    Boolean                             stackEnabled;
#endif /* ( MDF_STACKING == FYES ) */
#line 3793 "mibslot.mdf"
#if ( MDF_STACKING == FYES )
    Word                                stackUdpPort;
#endif /* ( MDF_STACKING == FYES ) */
#line 3798 "mibslot.mdf"
#if ((MDF_MROUTING == FYES) && (MDF_IGMP == FYES))
    Uint16                              multicastRateLimit;
#endif /* ((MDF_MROUTING == FYES) && (MDF_IGMP == FYES)) */
#line 3803 "mibslot.mdf"
#if (MDF_RADIUS_SERV == FYES)
    Bool                                radServSessionKeyEnable;
#endif /* (MDF_RADIUS_SERV == FYES) */
#line 3808 "mibslot.mdf"
#if (MDF_RADIUS_SERV == FYES)
    RadServAttrType                     radServAttrType;
#endif /* (MDF_RADIUS_SERV == FYES) */
#line 3814 "mibslot.mdf"
#if ( (MDF_LMODEM_TSDIALOUT == FYES) && (!(USERIF & CLI)) )
    dialOutSecurityType                 dialoutSecurity;
#endif /* ( (MDF_LMODEM_TSDIALOUT == FYES) && (!(USERIF & CLI)) ) */
#line 3819 "mibslot.mdf"
#if ( (MDF_LMODEM_TSDIALOUT == FYES) && (!(USERIF & CLI)) )
    char                                immModemPwd[ MAX_PASSWORD_LENGTH + 2 ];
#endif /* ( (MDF_LMODEM_TSDIALOUT == FYES) && (!(USERIF & CLI)) ) */
#line 3824 "mibslot.mdf"
    Word                                retryCount;
#line 3828 "mibslot.mdf"
#if ( MDF_SECURID == FYES )
    Boolean                             useDesCrypt;
#endif /* ( MDF_SECURID == FYES ) */
#line 3833 "mibslot.mdf"
#if ( MDF_SECURID == FYES )
    char                                nodeSecret[ (SECURID_SECRETSIZE*2)+1 ];
#endif /* ( MDF_SECURID == FYES ) */
#line 3838 "mibslot.mdf"
#if (( MDF_IP == FYES ) && ( MDF_TERMSRV == FYES ))
    char                                ipAddMsg[ MAX_IP_ADD_MSG + 1 ];
#endif /* (( MDF_IP == FYES ) && ( MDF_TERMSRV == FYES )) */
#line 3844 "mibslot.mdf"
#if ( MDF_APPLE_ROUTE == FYES )
    AtlkRouteType                       atlkRouter;
#endif /* ( MDF_APPLE_ROUTE == FYES ) */
#line 3849 "mibslot.mdf"
#if ( MDF_APPLE_ROUTE == FYES )
    Word                                atlkNetStart;
#endif /* ( MDF_APPLE_ROUTE == FYES ) */
#line 3854 "mibslot.mdf"
#if ( MDF_APPLE_ROUTE == FYES )
    Word                                atlkNetEnd;
#endif /* ( MDF_APPLE_ROUTE == FYES ) */
#line 3859 "mibslot.mdf"
#if ( MDF_APPLE_ROUTE == FYES )
    ZoneNameType                        atlkDefaultZone;
#endif /* ( MDF_APPLE_ROUTE == FYES ) */
#line 3864 "mibslot.mdf"
#if ( MDF_APPLE_ROUTE == FYES )
    ZoneNameType                        atlkZoneList[ MAX_SEED_ZONE_NAMES ];
#endif /* ( MDF_APPLE_ROUTE == FYES ) */
#line 3869 "mibslot.mdf"
#if ( MDF_REMOTE_AUTH == FYES )
    AuthLpfType                         localProfileFirst;
#endif /* ( MDF_REMOTE_AUTH == FYES ) */
#line 3874 "mibslot.mdf"
#if ((MDF_IP == FYES) && (MDF_DNS == FYES))
    int                                 dnsListSize;
#endif /* ((MDF_IP == FYES) && (MDF_DNS == FYES)) */
#line 3879 "mibslot.mdf"
#if (( MDF_IP == FYES ) && ( MDF_DNS == FYES ))
    char                                clientDomainName[ MAX_DOMAIN_NAME_LENGTH + 1 ];
    IpAddress                           clientPrimaryDnsServer;
#endif /* (( MDF_IP == FYES ) && ( MDF_DNS == FYES )) */
#line 3884 "mibslot.mdf"
#if (( MDF_IP == FYES ) && ( MDF_DNS == FYES ))
    char                                clientSecDomainName[ MAX_DOMAIN_NAME_LENGTH + 1 ];
    IpAddress                           clientSecondaryDnsServer;
#endif /* (( MDF_IP == FYES ) && ( MDF_DNS == FYES )) */
#line 3890 "mibslot.mdf"
#if (( MDF_IP == FYES ) && ( MDF_DNS == FYES ))
    Boolean                             allowAsClientDnsInfo;
    Boolean                             dnsProxyEnabled;
#endif /* (( MDF_IP == FYES ) && ( MDF_DNS == FYES )) */
#line 3896 "mibslot.mdf"
#if IP_RD_TC_COND
    Word                                authSessInterval;
#endif /* IP_RD_TC_COND */
#line 3902 "mibslot.mdf"
#if (( MDF_IP == FYES ) && ( MDF_TERMSRV == FYES ) )
    Word                                pktWaitTime;
#endif /* (( MDF_IP == FYES ) && ( MDF_TERMSRV == FYES ) ) */
#line 3907 "mibslot.mdf"
#if (( MDF_IP == FYES ) && ( MDF_TERMSRV == FYES ) )
    Word                                pktChars;
#endif /* (( MDF_IP == FYES ) && ( MDF_TERMSRV == FYES ) ) */
#line 3912 "mibslot.mdf"
#if ( MDF_IP == FYES && MDF_RADIUS == FYES )
    Boolean                             authTSsecure;
#endif /* ( MDF_IP == FYES && MDF_RADIUS == FYES ) */
#line 3918 "mibslot.mdf"
#if (MDF_RADIUS_SERV == FYES)
    IpAddress                           radServClient[ MAX_RAD_CLIENTS ];
#endif /* (MDF_RADIUS_SERV == FYES) */
#line 3923 "mibslot.mdf"
#if (MDF_RADIUS_SERV == FYES)
    IpAddress                           radServNetmask[ MAX_RAD_CLIENTS ];
#endif /* (MDF_RADIUS_SERV == FYES) */
#line 3928 "mibslot.mdf"
#if (MDF_RADIUS_SERV == FYES)
    char                                radServKey[ MAX_RAD_CLIENTS ][ MAX_PASSWORD_LENGTH + 2 ];
#endif /* (MDF_RADIUS_SERV == FYES) */
#line 3933 "mibslot.mdf"
#if (( MDF_IP == FYES ) && ( MDF_MROUTING == FYES ))
    IpAddress                           multicastHeartBeatAddr;
#endif /* (( MDF_IP == FYES ) && ( MDF_MROUTING == FYES )) */
#line 3938 "mibslot.mdf"
#if (( MDF_IP == FYES ) && ( MDF_MROUTING == FYES ))
    int                                 multicastHeartBeatPort;
#endif /* (( MDF_IP == FYES ) && ( MDF_MROUTING == FYES )) */
#line 3943 "mibslot.mdf"
#if (( MDF_IP == FYES ) && ( MDF_MROUTING == FYES ))
    LongWord                            multicastHeartBeatSlotTime;
#endif /* (( MDF_IP == FYES ) && ( MDF_MROUTING == FYES )) */
#line 3948 "mibslot.mdf"
#if (( MDF_IP == FYES ) && ( MDF_MROUTING == FYES ))
    LongWord                            multicastHeartBeatSlotlength;
#endif /* (( MDF_IP == FYES ) && ( MDF_MROUTING == FYES )) */
#line 3953 "mibslot.mdf"
#if (( MDF_IP == FYES ) && ( MDF_MROUTING == FYES ))
    LongWord                            multicastHeartBeatAlarmThreshold;
#endif /* (( MDF_IP == FYES ) && ( MDF_MROUTING == FYES )) */
#line 3958 "mibslot.mdf"
#if (( MDF_IP == FYES ) && ( MDF_MROUTING == FYES ))
    IpAddress                           multicastHeartBeatSrcAddr;
#endif /* (( MDF_IP == FYES ) && ( MDF_MROUTING == FYES )) */
#line 3963 "mibslot.mdf"
#if (( MDF_IP == FYES ) && ( MDF_MROUTING == FYES ))
    IpAddress                           multicastHeartBeatSrcAddrMask;
#endif /* (( MDF_IP == FYES ) && ( MDF_MROUTING == FYES )) */
#line 3968 "mibslot.mdf"
#if (( MDF_IP == FYES ) && ( MDF_TERMSRV == FYES ))
    Boolean                             tsPromptFormat;
#endif /* (( MDF_IP == FYES ) && ( MDF_TERMSRV == FYES )) */
#line 3973 "mibslot.mdf"
#if (( MDF_IP == FYES ) && ( MDF_DNS == FYES ))
    char                                secDomainName[ MAX_DOMAIN_NAME_LENGTH + 1 ];
#endif /* (( MDF_IP == FYES ) && ( MDF_DNS == FYES )) */
#line 3978 "mibslot.mdf"
#if TERMSVR_COND
    Word                                timeoutForTSrvLogin;
#endif /* TERMSVR_COND */
#line 3984 "mibslot.mdf"
#if ( MDF_IP == FYES && MDF_RADIUS == FYES )
    Boolean                             authSend67;
#endif /* ( MDF_IP == FYES && MDF_RADIUS == FYES ) */
#line 3990 "mibslot.mdf"
#if ( TCP_MODEM == FYES )
    Boolean                             tcpModemEnabled;
#endif /* ( TCP_MODEM == FYES ) */
#line 3995 "mibslot.mdf"
#if ( TCP_MODEM == FYES )
    Word                                tcpModemPort;
#endif /* ( TCP_MODEM == FYES ) */
#line 4000 "mibslot.mdf"
#if TERMSVR_COND
    TsModemModulation                   tsModemModulation;
#endif /* TERMSVR_COND */
#line 4005 "mibslot.mdf"
#if (( MDF_IP == FYES ) && ( TELNET == FYES ))
    Word                                tcpTimeout;
#endif /* (( MDF_IP == FYES ) && ( TELNET == FYES )) */
#line 4011 "mibslot.mdf"
#if ( MDF_DNS_FALLBACK_TABLE == FYES )
    Boolean                             localDnsTableEnabled;
#endif /* ( MDF_DNS_FALLBACK_TABLE == FYES ) */
#line 4017 "mibslot.mdf"
#if ( MDF_DNS_FALLBACK_TABLE == FYES )
    Boolean                             localDnsTableAutoUpdate;
#endif /* ( MDF_DNS_FALLBACK_TABLE == FYES ) */
#line 4023 "mibslot.mdf"
#if ( MDF_IP == FYES && MDF_RADIUS == FYES )
    Boolean                             authFrmAdrStart;
#endif /* ( MDF_IP == FYES && MDF_RADIUS == FYES ) */
#line 4030 "mibslot.mdf"
#if ( MDF_VTP == FYES )
    VtpAgentMode                        vtpAgentMode;
#endif /* ( MDF_VTP == FYES ) */
#line 4035 "mibslot.mdf"
#if ( MDF_VTP == FYES )
    VtpHomeAgentType                    vtpAgentType;
#endif /* ( MDF_VTP == FYES ) */
#line 4040 "mibslot.mdf"
#if ( MDF_VTP == FYES )
    Word                                vtpUdpPort;
#endif /* ( MDF_VTP == FYES ) */
#line 4045 "mibslot.mdf"
#if ( MDF_VTP == FYES )
    char                                vtpHomeAgentPassword[ MAX_PASSWORD_LENGTH + 2 ];
#endif /* ( MDF_VTP == FYES ) */
#line 4050 "mibslot.mdf"
#if ( MDF_VTP == FYES )
    Boolean                             vtpSapReply;
#endif /* ( MDF_VTP == FYES ) */
#line 4054 "mibslot.mdf"
#if (( MDF_IP == FYES ) && ( MDF_TERMSRV == FYES ))
    char                                ipNetmaskMsg[ MAX_IP_NETMASK_MSG + 1 ];
#endif /* (( MDF_IP == FYES ) && ( MDF_TERMSRV == FYES )) */
#line 4060 "mibslot.mdf"
#if (( MDF_IP == FYES ) && ( MDF_TERMSRV == FYES ))
    char                                ipGatewayAddMsg[ MAX_IP_GATEWAY_ADD_MSG + 1 ];
#endif /* (( MDF_IP == FYES ) && ( MDF_TERMSRV == FYES )) */
#line 4066 "mibslot.mdf"
#if TERMSVR_COND
    TsSlipInfo                          slipMsg;
#endif /* TERMSVR_COND */
#line 4072 "mibslot.mdf"
#if ((MDF_MROUTING == FYES) && (MDF_IGMP == FYES))
    Uint16                              multicastMemberTimeout;
#endif /* ((MDF_MROUTING == FYES) && (MDF_IGMP == FYES)) */
#line 4078 "mibslot.mdf"
    char                                poolName[ MAX_NVRAM_ASSIGN_POOL ][ POOL_NAME_LEN + 1 ];
#line 4083 "mibslot.mdf"
#if IP_RD_TC_COND
    IpAddress                           authBootHost;
#endif /* IP_RD_TC_COND */
#line 4088 "mibslot.mdf"
#if IP_RD_TC_COND
    IpAddress                           authBootHost2;
#endif /* IP_RD_TC_COND */
#line 4093 "mibslot.mdf"
#if IP_RD_TC_COND
    Word                                authBootPort;
#endif /* IP_RD_TC_COND */
#line 4099 "mibslot.mdf"
#if ( MDF_TWO_ETHERNET == FYES)
    EtherIF                             etherIFB;
#endif /* ( MDF_TWO_ETHERNET == FYES) */
#line 4104 "mibslot.mdf"
#if ( MDF_TWO_ETHERNET == FYES && ( MDF_IP == FYES ))
    IpAddress                           ipAddressB;
#endif /* ( MDF_TWO_ETHERNET == FYES && ( MDF_IP == FYES )) */
#line 4109 "mibslot.mdf"
#if ( MDF_TWO_ETHERNET == FYES && ( MDF_IP == FYES ))
    IpAddress                           netmaskB;
#endif /* ( MDF_TWO_ETHERNET == FYES && ( MDF_IP == FYES )) */
#line 4114 "mibslot.mdf"
#if ( MDF_TWO_ETHERNET == FYES && (MDF_IP == FYES ))
    IpAddress                           ipAddress2B;
#endif /* ( MDF_TWO_ETHERNET == FYES && (MDF_IP == FYES )) */
#line 4119 "mibslot.mdf"
#if ( MDF_TWO_ETHERNET == FYES && ( MDF_IP == FYES ))
    IpAddress                           netmask2B;
#endif /* ( MDF_TWO_ETHERNET == FYES && ( MDF_IP == FYES )) */
#line 4124 "mibslot.mdf"
#if ( MDF_TWO_ETHERNET == FYES && ( MDF_IP == FYES ))
    RoutingMode                         ripModeB;
#endif /* ( MDF_TWO_ETHERNET == FYES && ( MDF_IP == FYES )) */
#line 4130 "mibslot.mdf"
#if ( MDF_TWO_ETHERNET == FYES && ( MDF_IP == FYES ))
    ProxyMode                           proxyModeB;
#endif /* ( MDF_TWO_ETHERNET == FYES && ( MDF_IP == FYES )) */
#line 4135 "mibslot.mdf"
#if ( MDF_TWO_ETHERNET == FYES && ( MDF_IP == FYES ))
    Word                                filterB;
#endif /* ( MDF_TWO_ETHERNET == FYES && ( MDF_IP == FYES )) */
#line 4140 "mibslot.mdf"
#if ( MDF_TWO_ETHERNET == FYES && ( MDF_IPX_ROUTE == FYES ) )
    IpxFrameType                        ipxFrameTypeB;
#endif /* ( MDF_TWO_ETHERNET == FYES && ( MDF_IPX_ROUTE == FYES ) ) */
#line 4145 "mibslot.mdf"
#if ( MDF_TWO_ETHERNET == FYES && ( MDF_IPX_ROUTE == FYES ))
    LongWord                            ipxEtherNetNumberB;
#endif /* ( MDF_TWO_ETHERNET == FYES && ( MDF_IPX_ROUTE == FYES )) */
#line 4149 "mibslot.mdf"
#if ( MDF_TWO_ETHERNET == FYES && (MDF_IPX_ROUTE == FYES ))
    Word                                sapFilterB;
#endif /* ( MDF_TWO_ETHERNET == FYES && (MDF_IPX_ROUTE == FYES )) */
#line 4154 "mibslot.mdf"
#if ( MDF_TWO_ETHERNET == FYES && ( MDF_IPX_ROUTE == FYES ))
    Boolean                             ipxType20B;
#endif /* ( MDF_TWO_ETHERNET == FYES && ( MDF_IPX_ROUTE == FYES )) */
#line 4159 "mibslot.mdf"
#if ( NAT_LAN_OPTIONS == FYES )
    NatLan                              slotNatLan;
#endif /* ( NAT_LAN_OPTIONS == FYES ) */
#line 4164 "mibslot.mdf"
#if (( MDF_OSPF == FYES ) && ( MDF_IP == FYES ))
    Int                                 poolOspfAdvType;
#endif /* (( MDF_OSPF == FYES ) && ( MDF_IP == FYES )) */
#if ( VROUTER == FYES )
    char        vRouterName[ MAX_NAME_LEN + 1 ];
#endif
#line 4169 "mibslot.mdf"
#if ( MDF_ETHERNET == FYES )
    EtherSlotxProfile                   ext;
#endif /* ( MDF_ETHERNET == FYES ) */

    Boolean		dnsAutoAssign;

#if (DOT1X == FYES)
Dot1xPortProf  Dot1xMib;
#endif
st_filterSwitch filterSwitch;   /*add by brwang */

#if (LOG == FYES)
st_logSwitch	logSwitch;      /* add for logging according the choosed switch */
#endif

    char                                logHost[MAX_DOMAIN_NAME_LENGTH + 1]; //cyh@070107
}
#if ( USERIF & CLI )
__PACK__
#endif
EtherSlotProfile;

#endif /* ( MDF_ETHERNET == FYES ) */

    /*
     * EtherDataSlotProfile:
     *
     * Ethernet data card profile. The ethernet data card adds additional WAN
     * connections to an etheret slot card. It doesn't have any params of its
     * own at this time.
     *
     *  header The name and type of profile.
     *
     *  dummy
     */

#if ( MDF_ETHERNET == FYES )

typedef struct etherDataSlotProfile {
#line 4245 "mibslot.mdf"
    SlotProfileHeader                   header;
#line 4249 "mibslot.mdf"
    Word                                dummy;
}
#if ( USERIF & CLI )
__PACK__
#endif
EtherDataSlotProfile;

#endif /* ( MDF_ETHERNET == FYES ) */

    /*
     * ModemDisableMode:
     *
     * Values for disabling/enabling a Lan modem. When these values are in the
     * modemSlot field of the LanModemSlotProfile, they apply to every
     * 'existing' modem on the card in that slot. In the modemDisable field
     * they apply only to the modem in that index/item position on the card.
     *
     *  ENABLE_MODEM Default value, modem enabled.
     *
     *  DISABLE_MODEM Disable a modem.
     *
     *  DISABLE_MODEM_CHAN Disable a modem + one b-channel.
     */

#if ( ( PLATFORM & MPORT ) && ( LMODEM == FYES ) )

typedef enum ModemDisableMode {
#line 4287 "mibslot.mdf"
    ENABLE_MODEM,
#line 4290 "mibslot.mdf"
    DISABLE_MODEM,
#line 4293 "mibslot.mdf"
#if ( NETIF & T1 )
    DISABLE_MODEM_CHAN
#endif /* ( NETIF & T1 ) */
} ModemDisableMode;

#endif /* ( ( PLATFORM & MPORT ) && ( LMODEM == FYES ) ) */

#if ( ( PLATFORM & MPORT ) && ( LMODEM == FYES ) )



static __inline__ Bool
validModemDisableMode (int x)
{
    switch (x) {
#line 4287 "mibslot.mdf"
    case ENABLE_MODEM:
#line 4290 "mibslot.mdf"
    case DISABLE_MODEM:
#line 4293 "mibslot.mdf"
#if ( NETIF & T1 )
    case DISABLE_MODEM_CHAN:
#endif /* ( NETIF & T1 ) */
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* ( ( PLATFORM & MPORT ) && ( LMODEM == FYES ) ) */

    /*
     * LanModemSlotProfile:
     *
     * Lan Modem data card profile. The LAN modem card has phone numbers of
     * it's own. This allows phone number selection (and port number selection)
     * to override automatic slot detection by voice bearer.
     *
     *  header The name and type of profile.
     *
     *  modemAnsNumber1
     *
     *  modemAnsNumber2
     *
     *  modemAnsNumber3
     *
     *  modemAnsNumber4
     *
     *  modemSlot Enable/disable all modems on the slotcard.
     *
     *  modemDisable Enable/Disable an individual modem on the slotcard.
     */

#if ( MDF_LMODEM == FYES )

typedef struct lanModemSlotProfile {
#line 4326 "mibslot.mdf"
    SlotProfileHeader                   header;
#line 4330 "mibslot.mdf"
    char                                modemAnsNumber1[ MAX_ETHER_ANS_NUMBER + 1 ];
#line 4333 "mibslot.mdf"
    char                                modemAnsNumber2[ MAX_ETHER_ANS_NUMBER + 1 ];
#line 4336 "mibslot.mdf"
    char                                modemAnsNumber3[ MAX_ETHER_ANS_NUMBER + 1 ];
#line 4339 "mibslot.mdf"
    char                                modemAnsNumber4[ MAX_ETHER_ANS_NUMBER + 1 ];
#line 4342 "mibslot.mdf"
#if ( PLATFORM & MPORT )
    ModemDisableMode                    modemSlot;
#endif /* ( PLATFORM & MPORT ) */
#line 4347 "mibslot.mdf"
#if ( PLATFORM & MPORT )
    ModemDisableMode                    modemDisable[ MAX_16MODEMS_PER_SLOT ];
#endif /* ( PLATFORM & MPORT ) */
}
#if ( USERIF & CLI )
__PACK__
#endif
LanModemSlotProfile;

#endif /* ( MDF_LMODEM == FYES ) */

    /*
     * ATBaudRate:
     *
     * These are the baud rates that the MAX200 can communicate with a PC CARD
     * modem.
     *
     *  AT_BAUD_2400 2400 baud.
     *
     *  AT_BAUD_4800 4800 baud.
     *
     *  AT_BAUD_9600 9600 baud.
     *
     *  AT_BAUD_19200 19.2K baud.
     *
     *  AT_BAUD_38400 38.4K baud.
     *
     *  AT_BAUD_57600 57.6K baud.
     *
     *  AT_BAUD_115200 115.2K baud.
     */

#if ( PLATFORM & ( M200 ) )

typedef enum ATBaudRate {
#line 4387 "mibslot.mdf"
    AT_BAUD_2400 = 2400,
#line 4390 "mibslot.mdf"
    AT_BAUD_4800 = 4800,
#line 4393 "mibslot.mdf"
    AT_BAUD_9600 = 9600,
#line 4396 "mibslot.mdf"
    AT_BAUD_19200 = 19200,
#line 4399 "mibslot.mdf"
    AT_BAUD_38400 = 38400,
#line 4402 "mibslot.mdf"
    AT_BAUD_57600 = 57600,
#line 4405 "mibslot.mdf"
    AT_BAUD_115200 = 115200
} ATBaudRate;

#endif /* ( PLATFORM & ( M200 ) ) */

#if ( PLATFORM & ( M200 ) )



static __inline__ Bool
validATBaudRate (int x)
{
    switch (x) {
#line 4387 "mibslot.mdf"
    case AT_BAUD_2400:
#line 4390 "mibslot.mdf"
    case AT_BAUD_4800:
#line 4393 "mibslot.mdf"
    case AT_BAUD_9600:
#line 4396 "mibslot.mdf"
    case AT_BAUD_19200:
#line 4399 "mibslot.mdf"
    case AT_BAUD_38400:
#line 4402 "mibslot.mdf"
    case AT_BAUD_57600:
#line 4405 "mibslot.mdf"
    case AT_BAUD_115200:
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* ( PLATFORM & ( M200 ) ) */

    /*
     * ATModemSlotProfile:
     *
     * MAX 200 AT Modem PC CARD profile. If the defaultStrings variable is set
     * to true (DEFAULT) then the strings sent to the modem will come from
     * hardcoded values in the code base. If defaultStrings is set to false
     * (CUSTOM) then the strings sent to the modem will come from this profile.
     *
     *  header The name and type of profile.
     *
     *  name Manufacturers name as read from the PC CARD tuples. The user is
     *                                  not allowed to modify this value.
     *
     *  product Manufacturers product name as read from the PC CARD tuples. The
     *                                  user is not allowed to modify this
     *                                  value.
     *
     *  spkrOn TRUE is speaker should be turned on, FALSE otherwise.
     *
     *  useDefaultStrings DEFAULT (true) if this slot is using the modem
     *                                  strings that are hard-coded in the
     *                                  software, CUSTOM (false) if the strings
     *                                  that follow are to be used.
     *
     *  initStr String to send to the modem when initializing it.
     *
     *  answerStr Send this string to the modem to set it to auto-answer mode
     *                                  (e.g. ATS0=1).
     *
     *  spkrOffStr This string controls how the speaker is used with the modem:
     *                                  ATM0=Off, ATM1=On until carrier
     *                                  detected, ATM2=Always on, ATM3=Off
     *                                  during dialing, on until carrier,
     *                                  ATL0=Lowest speaker volume, ATL1=Low
     *                                  speaker volume, ATL2=Medium speaker
     *                                  volume, ATL3=High speaker volume.
     *
     *  hangupStr Send this string to the modem to force hangup.
     *
     *  dialStr Command prefix to send to dial a phone number (e.g. ATDT).
     *
     *  baudRate Baud rate between MAX 200 and PC CARD modem.
     *
     *  unknown Is modem type a know type?
     *
     *  dialoutInit String to intialize modem for dialout with MAXDial.
     */

#if ( PLATFORM & ( M200 ) )

typedef struct atModemSlotProfile {
#line 4435 "mibslot.mdf"
    SlotProfileHeader                   header;
#line 4439 "mibslot.mdf"
    char                                name[ MAX_MODEM_NAME + 1 ];
#line 4444 "mibslot.mdf"
    char                                product[ MAX_MODEM_NAME + 1 ];
#line 4449 "mibslot.mdf"
    Boolean                             spkrOn;
#line 4453 "mibslot.mdf"
    Boolean                             useDefaultStrings;
#line 4459 "mibslot.mdf"
    char                                initStr[ MAX_MODEM_INIT_STRING + 1 ];
#line 4463 "mibslot.mdf"
    char                                answerStr[ MAX_MODEM_INIT_STRING + 1 ];
#line 4468 "mibslot.mdf"
    char                                spkrOffStr[ MAX_MODEM_SPKR_STRING + 1 ];
#line 4480 "mibslot.mdf"
    char                                hangupStr[ MAX_MODEM_DIAL_STRING + 1 ];
#line 4484 "mibslot.mdf"
    char                                dialStr[ MAX_MODEM_DIAL_STRING + 1 ];
#line 4488 "mibslot.mdf"
    ATBaudRate                          baudRate;
#line 4492 "mibslot.mdf"
    Boolean                             unknown;
#line 4496 "mibslot.mdf"
#if ((LMODEM_TSDIALOUT == FYES) && (!(USERIF & CLI)))
    char                                dialoutInit[ MAX_MODEM_DIALOUT_INIT + 1 ];
#endif /* ((LMODEM_TSDIALOUT == FYES) && (!(USERIF & CLI))) */
}
#if ( USERIF & CLI )
__PACK__
#endif
ATModemSlotProfile;

#endif /* ( PLATFORM & ( M200 ) ) */

    /*
     * PhoneRingPattern:
     *
     * The various ring-patterns supported are enumerated below. They are:
     *
     *  PHONE_STANDARD_RING 2 seconds on, 4 seconds off.
     *
     *  PHONE_ON_ALWAYS_RING Always on, no off time.
     *
     *  PHONE_FAST_RING 2 seconds on, 2 seconds off.
     *
     *  PHONE_DOUBLE_RING 1 seconds on, .25 sec pause, 1 second on, 3.75
     *                                  seconds off.
     *
     *  PHONE_NUMBER_OF_RING
     */

#if ( MDF_POTS == FYES )

typedef enum PhoneRingPattern {
#line 4534 "mibslot.mdf"
    PHONE_STANDARD_RING,
#line 4537 "mibslot.mdf"
    PHONE_ON_ALWAYS_RING,
#line 4540 "mibslot.mdf"
    PHONE_FAST_RING,
#line 4543 "mibslot.mdf"
    PHONE_DOUBLE_RING,
#line 4546 "mibslot.mdf"
    PHONE_NUMBER_OF_RING
} PhoneRingPattern;

#endif /* ( MDF_POTS == FYES ) */

#if ( MDF_POTS == FYES )



static __inline__ Bool
validPhoneRingPattern (int x)
{
    switch (x) {
#line 4534 "mibslot.mdf"
    case PHONE_STANDARD_RING:
#line 4537 "mibslot.mdf"
    case PHONE_ON_ALWAYS_RING:
#line 4540 "mibslot.mdf"
    case PHONE_FAST_RING:
#line 4543 "mibslot.mdf"
    case PHONE_DOUBLE_RING:
#line 4546 "mibslot.mdf"
    case PHONE_NUMBER_OF_RING:
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* ( MDF_POTS == FYES ) */

    /*
     * DualPOTSSlotProfile:
     *
     * Dual POTS Slot Profile:
     *
     *  header The name and type of profile.
     *
     *  switchedCallType The switched call type associated with a POTS call.
     *
     *  phoneUsage1 The association between SPID/phoneNumbers for the first
     *                                  POTS port on a slot. These
     *                                  SPID/phoneNumbers can overlap with
     *                                  other POTS ports in the system.
     *
     *  phoneUsage2 The association between SPID/phoneNumbers for the second
     *                                  POTS port on a POTS slot. These
     *                                  SPID/phoneNumbers can overlap with
     *                                  other POTS ports in the system.
     *
     *  infoXferCapPhone1 The specify Information Transfer Capabilty type from
     *                                  the first POTS port on a slot. If
     *                                  INFO_XFER_CAP_SPEECH is selected, call
     *                                  from the first POT port will use Voice
     *                                  bearer capability in SETUP message. If
     *                                  INFO_XFER_CAP_AUDIO is selected, we
     *                                  assume that the device connected is not
     *                                  a telephone and would use 3.1k Audio
     *                                  bearer capability.
     *
     *  infoXferCapPhone2 The specify Information Transfer Capabilty type from
     *                                  the first POTS port on a slot. If
     *                                  INFO_XFER_CAP_SPEECH is selected, call
     *                                  from the first POT port will use Voice
     *                                  bearer capability in SETUP message. If
     *                                  INFO_XFER_CAP_AUDIO is selected, we
     *                                  assume that the device connected is not
     *                                  a telephone and would use 3.1k Audio
     *                                  bearer capability.
     *
     *  callerID Is POTS caller ID feature enabled
     *
     *  forwardDisconnect Is the POTS forward disconnect feature enabled
     *
     *  phoneRing1 The ringing pattern for the first POTS port on a POTS slot.
     *
     *  phoneRing2 The ringing pattern for the second POTS port on a POTS slot.
     *
     *  phoneBinding Bind the SPID/phone numbers associated with a host port in
     *                                  the Data/Phone Usage params to the port
     *                                  for outgoing calls. If set TRUE the
     *                                  outgoing call will only be originated
     *                                  from the SPID/phoneNumber/CES/TEI
     *                                  associated with the port in Data/Phone
     *                                  Usage. This means that even though
     *                                  there may be a B-channel available, if
     *                                  the logical link associated with a
     *                                  phone number is in use the call cannot
     *                                  be placed. If FALSE, then the first
     *                                  available logical link is used if the
     *                                  logical link associated with the phone
     *                                  number is not available.
     *
     *  dataUsage An enum value specifying which SPIDs/phoneNumbers are
     *                                  associated with data calls on the
     *                                  P25/P50.
     *
     *  hookflashActivator An boolean value specifying which
     *                                  PhoneDialInputType's are to be used for
     *                                  a particular supplementary services
     *                                  invocation.
     *
     *  dblhookflashActivator An boolean value specifying which
     *                                  PhoneDialInputType's are to be used for
     *                                  a particular supplementary services
     *                                  invocation.
     *
     *  confButton An enum value specifying which ISDN feature activators are
     *                                  to be used for a particular
     *                                  supplementary services invocation.
     *
     *  dropButton An enum value specifying which ISDN feature activators are
     *                                  to be used for a particular
     *                                  supplementary services invocation.
     *
     *  xferButton An enum value specifying which ISDN feature activators are
     *                                  to be used for a particular
     *                                  supplementary services invocation.
     */

#if ( MDF_POTS == FYES)

typedef struct dualPOTSSlotProfile {
#line 4573 "mibslot.mdf"
    SlotProfileHeader                   header;
#line 4577 "mibslot.mdf"
    SwitchedCallType                    switchedCallType;
#line 4581 "mibslot.mdf"
    PhoneUsage                          phoneUsage1;
#line 4587 "mibslot.mdf"
    PhoneUsage                          phoneUsage2;
#line 4593 "mibslot.mdf"
    InfoXferCapability                  infoXferCapPhone1;
#line 4601 "mibslot.mdf"
    InfoXferCapability                  infoXferCapPhone2;
#line 4609 "mibslot.mdf"
    Boolean                             callerID;
#line 4613 "mibslot.mdf"
    Boolean                             forwardDisconnect;
#line 4618 "mibslot.mdf"
    PhoneRingPattern                    phoneRing1;
#line 4622 "mibslot.mdf"
    PhoneRingPattern                    phoneRing2;
#line 4626 "mibslot.mdf"
    Boolean                             phoneBinding;
#line 4637 "mibslot.mdf"
    PhoneUsage                          dataUsage;
#line 4642 "mibslot.mdf"
    Boolean                             hookflashActivator;
#line 4648 "mibslot.mdf"
    Boolean                             dblhookflashActivator;
#line 4654 "mibslot.mdf"
    unsigned short                      confButton;
#line 4660 "mibslot.mdf"
    unsigned short                      dropButton;
#line 4666 "mibslot.mdf"
    unsigned short                      xferButton;
}
#if ( USERIF & CLI )
__PACK__
#endif
DualPOTSSlotProfile;

#endif /* ( MDF_POTS == FYES) */

    /*
     * V110SlotProfile:
     *
     * V.110 card profile. The V.110 card has phone numbers of it's own. This
     * allows phone number selection (and port number selection) to override
     * automatic slot detection by LLCIE.
     *
     *  header The name and type of profile.
     *
     *  v110AnsNumber1
     *
     *  v110AnsNumber2
     *
     *  v110AnsNumber3
     *
     *  v110AnsNumber4
     */

#if ( MDF_V110 == FYES )

typedef struct v110SlotProfile {
#line 4705 "mibslot.mdf"
    SlotProfileHeader                   header;
#line 4709 "mibslot.mdf"
    char                                v110AnsNumber1[ MAX_ETHER_ANS_NUMBER + 1 ];
#line 4712 "mibslot.mdf"
    char                                v110AnsNumber2[ MAX_ETHER_ANS_NUMBER + 1 ];
#line 4715 "mibslot.mdf"
    char                                v110AnsNumber3[ MAX_ETHER_ANS_NUMBER + 1 ];
#line 4718 "mibslot.mdf"
    char                                v110AnsNumber4[ MAX_ETHER_ANS_NUMBER + 1 ];
}
#if ( USERIF & CLI )
__PACK__
#endif
V110SlotProfile;

#endif /* ( MDF_V110 == FYES ) */

    /*
     * V32SlotProfile:
     *
     * V.32 card profile. The V.32 card has phone numbers of it's own. This
     * allows phone number selection (and port number selection) to override
     * automatic slot detection by LLCIE.
     *
     *  header The name and type of profile.
     *
     *  v32AnsNumber1
     *
     *  v32AnsNumber2
     *
     *  v32AnsNumber3
     *
     *  v32AnsNumber4
     */

#if ( MDF_V32_PHS == FYES )

typedef struct v32SlotProfile {
#line 4755 "mibslot.mdf"
    SlotProfileHeader                   header;
#line 4759 "mibslot.mdf"
    char                                v32AnsNumber1[ MAX_ETHER_ANS_NUMBER + 1 ];
#line 4762 "mibslot.mdf"
    char                                v32AnsNumber2[ MAX_ETHER_ANS_NUMBER + 1 ];
#line 4765 "mibslot.mdf"
    char                                v32AnsNumber3[ MAX_ETHER_ANS_NUMBER + 1 ];
#line 4768 "mibslot.mdf"
    char                                v32AnsNumber4[ MAX_ETHER_ANS_NUMBER + 1 ];
}
#if ( USERIF & CLI )
__PACK__
#endif
V32SlotProfile;

#endif /* ( MDF_V32_PHS == FYES ) */

    /*
     * VDSPSlotProfile:
     *
     * VDSP card profile. The VDSP card has phone numbers of it's own. This
     * allows phone number selection (and port number selection) to override
     * automatic slot detection by LLCIE.
     *
     *  header The name and type of profile.
     *
     *  VDSPAnsNumber1
     *
     *  VDSPAnsNumber2
     *
     *  VDSPAnsNumber3
     *
     *  VDSPAnsNumber4
     */

#if ( MDF_VOIP == FYES )

typedef struct VDSPSlotProfile {
#line 4806 "mibslot.mdf"
    SlotProfileHeader                   header;
#line 4810 "mibslot.mdf"
    char                                VDSPAnsNumber1[ MAX_ETHER_ANS_NUMBER + 1 ];
#line 4813 "mibslot.mdf"
    char                                VDSPAnsNumber2[ MAX_ETHER_ANS_NUMBER + 1 ];
#line 4816 "mibslot.mdf"
    char                                VDSPAnsNumber3[ MAX_ETHER_ANS_NUMBER + 1 ];
#line 4819 "mibslot.mdf"
    char                                VDSPAnsNumber4[ MAX_ETHER_ANS_NUMBER + 1 ];
}
#if ( USERIF & CLI )
__PACK__
#endif
VDSPSlotProfile;

#endif /* ( MDF_VOIP == FYES ) */

    /*
     * IModemSlotProfile:
     *
     * Imodem slot card profile. Contains:
     *
     *  header The name and type of profile.
     *
     *  proxyMode Specify whether or not we proxy LCP for the Host.
     *
     *  dataUsage An enum value specifying which SPIDs/phoneNumbers are
     *                                  associated with data calls on the P15.
     *
     *  iModemProfile The one and only profile to use for the imodem.
     */

#if ( MDF_IMODEM == FYES )

typedef struct iModemSlotProfile {
#line 4854 "mibslot.mdf"
    SlotProfileHeader                   header;
#line 4858 "mibslot.mdf"
#if ( IMODEM == FYES )
    Boolean                             proxyMode;
#endif /* ( IMODEM == FYES ) */
#line 4863 "mibslot.mdf"
#if ( MDF_POTS == FYES )
    PhoneUsage                          dataUsage;
#endif /* ( MDF_POTS == FYES ) */
#line 4869 "mibslot.mdf"
#if ( IMODEM == FYES )
    char                                iModemProfile[ MAX_HOST_NAME_LENGTH + 1 ];
#endif /* ( IMODEM == FYES ) */
}
#if ( USERIF & CLI )
__PACK__
#endif
IModemSlotProfile;

#endif /* ( MDF_IMODEM == FYES ) */

#line 4901 "mibslot.mdf"

    /*
     * The space allocated for a slot profile is generic for all types of
     * slots in the system.  Therefore, a union of each of the different slot
     * types is created here.  When new slot types are added, they are added
     * to this structure.
     * NOTE: all slot profiles must include the header as their first element
     * or nothing will work.
     */
typedef struct {
    union {
	SlotProfileHeader	generic;
	GenericSlotProfile	genSlot;
        DualAIMSlotProfile	dualAimSlot;
	AIM6SlotProfile		aim6Slot;
#  if ( MDF_SERIAL_WAN == FYES )
	SerialWanSlotProfile	serialWanSlot;
#  endif
#  if ( MDF_PRIMARY_NAILED_56 == FYES )
	Nailed56SlotProfile	n56Slot;
#  endif
#  if ( PRIMARY_NAILED_T1 == FYES )
	NailedT1SlotProfile	nt1Slot;
#  endif
#  if ( PLATFORM & ( M2000 | P220 ) )
	SerialT1CSU_SlotProfile	st1csuSlot;
#  endif
        DualHostSlotProfile	dualHostSlot;
        QuadHostSlotProfile	quadHostSlot;
#  if ( MDF_ETHERNET == FYES )
	EtherSlotProfile	etherSlot;
	EtherDataSlotProfile	etherDataSlot;
#  endif
#  if ( MDF_LMODEM == FYES )
	LanModemSlotProfile	lanModemSlot;
#  endif
#  if PLATFORM & ( M200 )
	ATModemSlotProfile	atModemSlot;
#  endif
#  if (MDF_POTS == FYES)
	DualPOTSSlotProfile	dualPotsSlot;
#  endif
#  if ( MDF_V110 == FYES )
	V110SlotProfile		v110Slot;
#  endif
#  if ( MDF_V35 == FYES )
	V35SlotProfile		v35Slot;
#  endif
#  if (MDF_IMODEM == FYES)
	IModemSlotProfile	iModemSlot;
#  endif
#  if ( MDF_V32_PHS == FYES )
	V32SlotProfile		v32Slot;
#  endif
#  if ( MDF_VOIP == FYES )
	VDSPSlotProfile		VDSPSlot;
#  endif
    } cardType;
} SlotProfile;

#  if ( MDF_MIBMGR == FYES )

extern ConstPtr
mibFactoryEtherProfile( MibProfileType	mibType,
			Uint32		info );

#  endif /* ( MDF_MIBMGR == FYES ) */

#line 4972 "mibslot.mdf"

# endif /* MIBSLOT_H */
