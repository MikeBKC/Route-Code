    /*
     * Notice: file generated by MIBMAKE from mibfiltr.mdf
     * DO NOT EDIT THIS FILE!!!  Edit mibfiltr.mdf
     */
/*
 * $Id: mibfiltr.h,v 1.2 2012/08/29 10:01:13 yu.dehai Exp $
 *
 *      Copyright (c) 1995 UTT Technologies, Inc.
 *      All rights reserved.
 *      Use of copyright notice does not imply publication.
 *
 *
 *                      CONFIDENTIAL INFORMATION
 *                      ------------------------
 *      This Document contains Confidential Information or Trade Secrets,
 *      or both, which are the property of UTT Technologies, Inc.
 *      This document may not be copied, reproduced, reduced to any
 *      electronic medium or machine readable form or otherwise duplicated
 *      and the information herein may not be used, disseminated or
 *      otherwise disclosed, except with the prior written consent of
 *      UTT Technologies, Inc.
 */

#include "mibipgroup.h"
#include "mibpdb.h"

#if ! defined( MIBFILTR_H )
#define MIBFILTR_H

    /* This file contains the internal representation of the filter profile
     * (MIB_PROF_FILTER). The name of this profile is stored in the global
     * variable mibProfFilter.
     */

extern const char* const		mibProfFilter;

#define MAX_FILTER_NAME_LENGTH		MAX_PROFILE_NAME_LENGTH
//#define	MAX_FILTER_PROFILE_NAME_LEN	9
    /*
     * The maximum number of octets in a generic filter.
     */
#define MAX_FILTER_LEN		8

    /*
     * A generic filter with space allocated for alignment padding.
     */
#define PADDED_MAX_FILTER_LEN  (MAX_FILTER_LEN + sizeof(Uint32))

typedef enum FilterAlgType {
    FILTER_ALG_NONE,
    FILTER_ALG_DNS,
    FILTER_ALG_URL,
    FILTER_ALG_STR,
    FILTER_ALG_FTP,
    FILTER_ALG_MSN,
    FILTER_ALG_QQ,
    FILTER_ALG_BT,
    FILTER_ALG_EMULE,
    FILTER_ALG_FDXL,
    FILTER_ALG_MAX
} FilterAlgType;

#if 0
#if (OBJECT_GROUP == FYES)
	typedef enum oldORnew{
		        OLD_FILTER,
		        NEW_FILTER
	}oldOnew;
#endif   /*(OBJECT_GROUP == FYES)*/
#endif
    /*
     * FilterType:
     *
     * There is a generic mask and compare filter type as well as a type for
     * each known protocol. The filter types are defined here.
     *
     *  FILTER_GENERIC A generic mask and compare filter.
     *
     *  FILTER_IP An IP specific filter.
     *
     *  FILTER_IP_ROUTE An ROUTE specific filter.
     *
     *  FILTER_IPX An IPX specific filter.
     *
     *  FILTER_TOS An IP type-of-service specific filter.
     *
     *  FILTER_IPSSG An IP Service select gateway  specific filter.     //xhzhuang 2002-12-25
     *
     *  FILTER_TYPE_MAX One more that the last valid filter type.
     */
typedef enum FilterType {
    FILTER_GENERIC,
    FILTER_IP,
    FILTER_IP_ROUTE,
    FILTER_IPX,
    FILTER_TOS,
/* ********* xhzhuang 2002-12-25 ********** */
    FILTER_IPSSG,
/* **************************************** */
    FILTER_TYPE_MAX
} FilterType;


static __inline__ Bool
validFilterType (int x)
{
    switch (x) {
    case FILTER_GENERIC:
    case FILTER_IP:
    case FILTER_IP_ROUTE:
    case FILTER_IPX:
    case FILTER_TOS:
    case FILTER_IPSSG:                  /* xhzhuang 2002-12-25 */
    case FILTER_TYPE_MAX:
        return TRUE;
    default:
        return FALSE;
    }
}

    /*
     * FilterComparison:
     *
     * To perform proper filtering source and destination fields must do more
     * than compare equal/not-equal. The types of comparisons are:
     *
     *  COMPARE_NONE Packet address/port is not used in this filter.
     *
     *  COMPARE_LESS Packet address/port less than filter address/port.
     *
     *  COMPARE_EQUAL Packet address/port same as filter address/port.
     *
     *  COMPARE_GREATER Packet address/port greater than filter address/port.
     *
     *  COMPARE_NOT_EQUAL Packet address/port not same as filter address/port.
     */
typedef enum FilterComparison {
    COMPARE_NONE,
    COMPARE_LESS,
    COMPARE_EQUAL,
    COMPARE_GREATER,
    COMPARE_NOT_EQUAL
} FilterComparison;


static __inline__ Bool
validFilterComparison (int x)
{
    switch (x) {
    case COMPARE_NONE:
    case COMPARE_LESS:
    case COMPARE_EQUAL:
    case COMPARE_GREATER:
    case COMPARE_NOT_EQUAL:
        return TRUE;
    default:
        return FALSE;
    }
}

    /*
     * RouteFilterAction:
     *
     * To perform proper filtering source and destination fields must do more
     * than compare equal/not-equal. The types of comparisons are:
     *
     *  ROUTEACTION_NONE No action taken here.
     *
     *  ROUTEACTION_ACCEPT If the filter matches accept the route.
     *
     *  ROUTEACTION_DENY If the filter matches reject the route.
     *
     *  ROUTEACTION_ADD If the filter matches, add a value to the route metric
     *                                  and accept.
     */
typedef enum RouteFilterAction {
    ROUTEACTION_NONE,
    ROUTEACTION_ACCEPT,
    ROUTEACTION_DENY,
    ROUTEACTION_ADD
} RouteFilterAction;


static __inline__ Bool
validRouteFilterAction (int x)
{
    switch (x) {
    case ROUTEACTION_NONE:
    case ROUTEACTION_ACCEPT:
    case ROUTEACTION_DENY:
    case ROUTEACTION_ADD:
        return TRUE;
    default:
        return FALSE;
    }
}

    /*
     * IpServiceGroup:
     *
     * An IpServiceGroup entry contains fields known within IP packets. The fields
     * are:
     *
     *  protocol The protocol number of the protocol to filter for. If set to
     *                                  zero this entry will match any IP
     *                                  protocol.
     *
     *  sourceAddressMask A mask to apply to a source address before
     *                                  comparison.
     *
     *  sourceAddress A value to compare with the masked source addresses.
     *
     *  destAddressMask A mask to apply to a destination address before
     *                                  comparison.
     *
     *  destAddress A value to compare with the masked destination addresses.
     *
     *  sourceTest The type of comparison for the source port field. May be set
     *                                  to no comparison.
     *
     *  sourcePort A value to compare with the source port. The comparison is
     *                                  defined by the sourceTest field.
     *
     *  destTest The type of comparison for the destination port field. May be
     *                                  set to no comparison.
     *
     *  destPort A value to compare with the destination port. The comparison
     *                                  is defined by the destTest field.
     *
     *  tcpEstab Indicates whether to look at tcp packets in an established
     *                                  connection.
     */

typedef struct ipService {
    Boolean                             forward;
    Uint32				action;	
    Word                                protocol;
    IpAddress                           sourceAddressMask;
    IpAddress                           sourceAddress;
    IpAddress                           destAddressMask;
    IpAddress                           destAddress;
    Word                                sourcePort;
    Word                                sourcePortMask;
    Word                                destPort;
    Word                                destPortMask;
    Boolean                             tcpEstab;
} IpServiceGroup;

    /*
     * GenericFilter:
     *
     * A generic filter can be used for bridging or any protocol. It is a
     * simple mask and test filter.
     *
     *  offset Offset from start of frame of data to test.
     *
     *  len Number of octets to test. Max value is 8 octets.
     *
     *  more Include next entry in as part of filter.
     *
     *  compNeq Defines type of comparison( Equals(FALSE) or Notequals(TRUE).
     *                                  Default is Equals.
     *
     *  dummyForPadding padding for alignment of mask and value fields, it
     *                                  assumes that MAX_FILTER_LEN == 8
     *
     *  mask A mask to be applied to the data at offset. Only the first len
     *                                  octets will be applied.
     *
     *  value The value to compare with the masked data. Only the first len
     *                                  octets will be compared.
     */
typedef struct genericFilter {
    Word                                offset;
    Word                                len;
    Boolean                             more;
    Boolean                             compNeq;
    Word                                dummyForPadding;
    Byte                                mask[ PADDED_MAX_FILTER_LEN ];
    Byte                                value[ PADDED_MAX_FILTER_LEN ];
}
#if ( USERIF & CLI )
#endif
GenericFilter;

typedef struct subFilter { 
    Pointer    filterList;
    Word       subLength; 
    Word       subLife; 
    Pointer    arg;
} SubFilter;

/* *************** xhzhuang 2002-12-25 *****************
 * 
 * struct ipssgFilter
 * for check MAC address 
 *
 ******************************************************* */
typedef struct ipssgFilter { 
    Word                                protocol; 
#if ( MDF_IP == FYES )
    IpAddress                           sourceAddressMask;
#endif /* ( MDF_IP == FYES ) */ 
#if ( MDF_IP == FYES )
    IpAddress                           sourceAddress;
#endif /* ( MDF_IP == FYES ) */ 
#if ( MDF_IP == FYES )
    IpAddress                           destAddressMask;
#endif /* ( MDF_IP == FYES ) */ 
#if ( MDF_IP == FYES )
    IpAddress                           destAddress;
#endif /* ( MDF_IP == FYES ) */ 
    FilterComparison                    sourceTest; 
    Word                                sourcePort; 
    FilterComparison                    destTest; 
    Word                                destPort; 
    Boolean                             tcpEstab;          /*  above is ipFilter  */
   Uint8      sMac[ETHER_ADDR_LEN] ;    /* source MAC addr      */
   Boolean    sNeq;
   Uint8      dMac[ETHER_ADDR_LEN] ;    /* destinate MAC addr   */
   Boolean    dNeq;
   Uint16     eType ;      		/* ethernet type        */
   Boolean    eNeq;     		/* for eType compare    */    
   char       tmrgName[MAX_PROFILE_NAME_LENGTH+1]; /* add by chenyunhua*/
#if ( MDF_IP == FYES )
    IpAddress                           sourceAddrFrom;
#endif /* ( MDF_IP == FYES ) */ 
#if ( MDF_IP == FYES )
    IpAddress                           sourceAddrTo;
#endif /* ( MDF_IP == FYES ) */ 
#if ( MDF_IP == FYES )
    IpAddress                           destAddrFrom;
#endif /* ( MDF_IP == FYES ) */ 
#if ( MDF_IP == FYES )
    IpAddress                           destAddrTo;
#endif /* ( MDF_IP == FYES ) */ 
    Word                                sourcePortFrom; 
    Word                                sourcePortTo; 
    Word                                destPortFrom; 
    Word                                destPortTo; 
// zhz@20050528
    FilterAlgType			fAlgType;
    Char 				keyProfile[MAX_PROFILE_NAME_LENGTH + 1];
    char       				keyName[MAX_HOST_NAME_LENGTH+1];    	/* add by zhz*/
    Word       				keyLength; 
    FilterComparison                    keyTest; 
    SubFilter  				*subfilt;
    SubFilter  				*nextfilt;
#if 0
#if (OBJECT_GROUP == FYES)					/*add by brwang*/
    oldOnew                             oldOrnew;
    char                                srcipname[MAX_IPGROUP_NAME_LENGTH+1];
    char                                destipname[MAX_IPGROUP_NAME_LENGTH+1];
    IpGroup      	                *srcipgroup;
    IpGroup                 	        *destipgroup;
    char                                portname[MAX_PORTGROUP_NAME_LENGTH+1];
    PortGroup                           *portgroup;
#endif /*(OBJECT_GROUP == FYES)*/
#endif
 
}
#if ( USERIF & CLI )
#endif
IpSsgFilter;
/* ***************************************************** */   
    /*
     * IpFilter:
     *
     * An IpFilter entry contains fields known within IP packets. The fields
     * are:
     *
     *  protocol The protocol number of the protocol to filter for. If set to
     *                                  zero this entry will match any IP
     *                                  protocol.
     *
     *  sourceAddressMask A mask to apply to a source address before
     *                                  comparison.
     *
     *  sourceAddress A value to compare with the masked source addresses.
     *
     *  destAddressMask A mask to apply to a destination address before
     *                                  comparison.
     *
     *  destAddress A value to compare with the masked destination addresses.
     *
     *  sourceTest The type of comparison for the source port field. May be set
     *                                  to no comparison.
     *
     *  sourcePort A value to compare with the source port. The comparison is
     *                                  defined by the sourceTest field.
     *
     *  destTest The type of comparison for the destination port field. May be
     *                                  set to no comparison.
     *
     *  destPort A value to compare with the destination port. The comparison
     *                                  is defined by the destTest field.
     *
     *  tcpEstab Indicates whether to look at tcp packets in an established
     *                                  connection.
     */
typedef struct ipFilter {
    Word                                protocol;
#if ( MDF_IP == FYES )
    IpAddress                           sourceAddressMask;
#endif /* ( MDF_IP == FYES ) */
#if ( MDF_IP == FYES )
    IpAddress                           sourceAddress;
#endif /* ( MDF_IP == FYES ) */
#if ( MDF_IP == FYES )
    IpAddress                           destAddressMask;
#endif /* ( MDF_IP == FYES ) */
#if ( MDF_IP == FYES )
    IpAddress                           destAddress;
#endif /* ( MDF_IP == FYES ) */
    FilterComparison                    sourceTest;
    Word                                sourcePort;
    FilterComparison                    destTest;
    Word                                destPort;
    Boolean                             tcpEstab;
}
#if ( USERIF & CLI )
#endif
IpFilter;

    /*
     * TosFilter:
     *
     * An TosFilter entry contains fields known within IP packets. The fields
     * are:
     *
     *  protocol The protocol number of the protocol you like to support
     *                                  type-of-service. If set to zero this
     *                                  entry will match any IP protocol.
     *
     *  sourceAddressMask A mask to apply to a source address before
     *                                  comparison.
     *
     *  sourceAddress A value to compare with the masked source addresses.
     *
     *  destAddressMask A mask to apply to a destination address before
     *                                  comparison.
     *
     *  destAddress A value to compare with the masked destination addresses.
     *
     *  sourceTest The type of comparison for the source port field. May be set
     *                                  to no comparison.
     *
     *  sourcePort A value to compare with the source port. The comparison is
     *                                  defined by the sourceTest field.
     *
     *  destTest The type of comparison for the destination port field. May be
     *                                  set to no comparison.
     *
     *  destPort A value to compare with the destination port. The comparison
     *                                  is defined by the destTest field.
     *
     *  precedence Tag the precedence bits (priority bits) in the TOS octet of
     *                                  IP datagram header with this value when
     *                                  match occurs.
     *
     *  tos Tag the type of service field in the TOS octet of IP datagram
     *                                  header with this value when match
     *                                  occurs.
     */
typedef struct tosFilter {
    Word                                protocol;
#if ( MDF_IP == FYES )
    IpAddress                           sourceAddressMask;
#endif /* ( MDF_IP == FYES ) */
#if ( MDF_IP == FYES )
    IpAddress                           sourceAddress;
#endif /* ( MDF_IP == FYES ) */
#if ( MDF_IP == FYES )
    IpAddress                           destAddressMask;
#endif /* ( MDF_IP == FYES ) */
#if ( MDF_IP == FYES )
    IpAddress                           destAddress;
#endif /* ( MDF_IP == FYES ) */
    FilterComparison                    sourceTest;
    Word                                sourcePort;
    FilterComparison                    destTest;
    Word                                destPort;
    Int                                 precedence;
    Int                                 tos;
}
#if ( USERIF & CLI )
#endif
TosFilter;

    /*
     * IpRouteFilter:
     *
     * A RouteFilter entry contains fields known for a IP Route . The fields
     * are:
     *
     *  sourceAddressMask A mask to apply to a source address before
     *                                  comparison.
     *
     *  sourceAddress A value to compare with the masked source addresses.
     *
     *  routeAddressMask A mask to apply to a destination address before
     *                                  comparison.
     *
     *  routeAddress A value to compare with the masked destination addresses.
     *
     *  addMetric A value to be added to metric of the route, this is valid
     *                                  only when action is add.
     *
     *  action The type of action taken when match occurs.
     */
typedef struct ipRouteFilter {
#if ( MDF_IP == FYES )
    IpAddress                           sourceAddressMask;
#endif /* ( MDF_IP == FYES ) */
#if ( MDF_IP == FYES )
    IpAddress                           sourceAddress;
#endif /* ( MDF_IP == FYES ) */
#if ( MDF_IP == FYES )
    IpAddress                           routeAddressMask;
#endif /* ( MDF_IP == FYES ) */
#if ( MDF_IP == FYES )
    IpAddress                           routeAddress;
#endif /* ( MDF_IP == FYES ) */
#if ( MDF_IP == FYES )
    Word                                addMetric;
#endif /* ( MDF_IP == FYES ) */
    RouteFilterAction                   action;
}
#if ( USERIF & CLI )
#endif
IpRouteFilter;

    /*
     * IpxFilter:
     *
     * An IpxFilter entry contains fields known within IPX packets. The fields
     * are:
     *
     *  srcNetAddress A value to compare with source network addresses.
     *
     *  destNetAddress A value to compare with destination network addresses.
     *
     *  srcNodeAddress A value to compare with source node addresses.
     *
     *  destNodeAddress A value to compare with destination node addresses.
     *
     *  srcSocket The type of comparison for the source socket field. May be
     *                                  set to no comparison.
     *
     *  srcTest The type of comparison for the source socket field. May be set
     *                                  to no comparison.
     *
     *  destSocket A value to compare with the destination socket. The
     *                                  comparison is defined by the destTest
     *                                  field.
     *
     *  destTest The type of comparison for the destination socket field. May
     *                                  be set to no comparison.
     */
typedef struct ipxFilter {
#if ( MDF_IPX_ROUTE == FYES )
    IpxNet                              srcNetAddress;
#endif /* ( MDF_IPX_ROUTE == FYES ) */
#if ( MDF_IPX_ROUTE == FYES )
    IpxNet                              destNetAddress;
#endif /* ( MDF_IPX_ROUTE == FYES ) */
#if ( MDF_IPX_ROUTE == FYES )
    IpxNode                             srcNodeAddress;
#endif /* ( MDF_IPX_ROUTE == FYES ) */
#if ( MDF_IPX_ROUTE == FYES )
    IpxNode                             destNodeAddress;
#endif /* ( MDF_IPX_ROUTE == FYES ) */
#if ( MDF_IPX_ROUTE == FYES )
    IpxSocket                           srcSocket;
#endif /* ( MDF_IPX_ROUTE == FYES ) */
#if ( MDF_IPX_ROUTE == FYES )
    FilterComparison                    srcTest;
#endif /* ( MDF_IPX_ROUTE == FYES ) */
#if ( MDF_IPX_ROUTE == FYES )
    IpxSocket                           destSocket;
#endif /* ( MDF_IPX_ROUTE == FYES ) */
#if ( MDF_IPX_ROUTE == FYES )
    FilterComparison                    destTest;
#endif /* ( MDF_IPX_ROUTE == FYES ) */
}
#if ( USERIF & CLI )
#endif
IpxFilter;

typedef union un_filterUnion {
    GenericFilter                       genFilter;
    IpFilter                            ipFilter;
    IpSsgFilter                         ssgFilter;
    IpRouteFilter                       ipRouteFilter;
#if ( MDF_IPX_ROUTE == FYES )
    IpxFilter                           ipxFilter;
#endif /* ( MDF_IPX_ROUTE == FYES ) */
#if ( IPTOS == FYES )
    TosFilter                           tosFilter;
#endif /* ( IPTOS == FYES ) */
} FilterUnion;

    /*
     * FilterEntry:
     *
     * A FilterEntry defines a particular filter. The filter will part of a
     * table of filters applied to either the input or the output from an
     * interface. The filter entry is a discriminated union of filter types.
     *
     *  active When TRUE, this filter entry has been defined and properly
     *                                  initialized. When FALSE, this entry
     *                                  should be skipped when filtering.
     *
     *  forward When TRUE a packet matching this filter will be forwarded or
     *                                  restart the idle timer. When FALSE a
     *                                  packet matching this filter will be
     *                                  dropped or not restart the idle timer.
     *
     *  filterType The type of filter contained in this entry. Used to select
     *                                  which of the following fields should be
     *                                  used.
     *
     *  genFilter A generic filter can be used for bridging or any protocol. It
     *                                  is a simple mask and test filter.
     *
     *  ipFilter An IpFilter entry contains fields known within IP packets.:
     *
     *  ipRouteFilter An IpFilter entry contains fields known within IP Route.:
     *
     *  ipxFilter An IpxFilter entry contains fields known within IPX packets.:
     *
     *  tosFilter An TosFilter entry contains fields known within IP packets.:
     *
     *  name The name of this filter entry.
     *
     */
typedef struct filterEntry {
    Char 				name[MAX_PROFILE_NAME_LENGTH + 1];
    Boolean                             active;
    Char 				groupName[MAX_PROFILE_NAME_LENGTH + 1];
    Boolean                             forward;
    FilterType                          filterType;
    Boolean				filterEnd;
    Uint32				action;	
			/* if match, how to do next ?, drop, forward, acct */
    GenericFilter                       genFilter;
    IpFilter                            ipFilter;
/* ************** xhzhuang 2002-12-25 ***************** */
   IpSsgFilter                          ssgFilter;
    IpRouteFilter                       ipRouteFilter;
#if ( MDF_IPX_ROUTE == FYES )
    IpxFilter                           ipxFilter;
#endif /* ( MDF_IPX_ROUTE == FYES ) */
#if ( IPTOS == FYES )
    TosFilter                           tosFilter;
#endif /* ( IPTOS == FYES ) */

# if 0
    FilterUnion				fu;
# endif
}
#if ( USERIF & CLI )
#endif
FilterEntry;

    /*
     * FilterProfile:
     *
     * A filter profile consists of the filters used to control data into and
     * out of an interface. (Each switched connection is considered a separate
     * interface.) Each entry is named and refered to by name to assign a
     * filter to an interface. Filters are used for two purposes: route
     * filters: used to determine which packets get transferred on an
     * interface. idle filters: determine which packets are allowed to restart
     * the idle timer. Packets that coded as forward restart the idle timer,
     * packets coded as drop do not restart the idle timer.
     *
     *  filterName The name of this filter. All filters are referenced by name
     *                                  so a name must be assigned to active
     *                                  filters.
     *
     *  inputFilters A table of filters applied to packets received on an
     *                                  interface.
     *
     *  outputFilters A table of filters applied to packets sent on an
     *                                  interface.
     */
typedef struct st_filterProfile {
//  char                                filterName[ MAX_PROFILE_NAME_LENGTH + 1 ];
    char                                name[MAX_PROFILE_NAME_LENGTH+1];
    Boolean                             active;
    FilterEntry                         inputFilters[ MAX_FILTER_ENTRIES ];
    FilterEntry                         outputFilters[ MAX_FILTER_ENTRIES ];
}
#if ( USERIF & CLI )
#endif
FilterProfile;
    /*
     * The index field of a filter profile.
     */
#define MIB_PROF_FILTER_INDEX_FIELD	1

extern ConstPtr
mibFactoryFilterProfile( MibProfileType mibType,
		         ConstPtr	mibIndex,
		         Int		mibIndexLen );

/*
typedef enum en_ether_type{
    ETHER_ARP=0800,
    ETHER_IP=0800,
    ETHER_RARP=8035,
}etherFilterType;
*/
typedef enum en_etherfilter_type{
    ETHERFILTER_BROAD = 0,
    ETHERFILTER_MULTI,
}etherFilterType;

typedef struct st_etherfilter_profile{
    char            name[MAX_PROFILE_NAME_LENGTH+1];
    Boolean         active;
    Boolean         forward;
    Uint32          interface;
    Uint16          etherType;
    etherFilterType filterType;
}EtherFilterProfile;

typedef struct st_etherfilter_segment{
    char            name[MAX_PROFILE_NAME_LENGTH+1];
    Uint16          etherType;
    struct          st_etherfilter_segment *next;
    etherFilterType filterType;
    Boolean         forward;
    Uint32          count;
}etherFilterSegment;

/*
 * added by llliu@080428.
 */
/*
 * filter policy.
 *
 * FP:
 * FilterPolicy.
 *
 */

#define FILTER_IF_LAN                   (0x1)

#define FILTER_IF(x)                    (FILTER_IF_LAN << x)


typedef enum filterPolicy {

    FP_ALLOW,           /* let this packet go */
    FP_DENY            /* drop it */

    /*
     * add new type above please.
     */

} filterPolicy;


/*
 *
 * DNS-filter profile structure.
 */
#define MAX_DNS_FILTER_PROFILES         100




typedef struct {
    char                hostName[MAX_PROFILE_NAME_LENGTH + 1];
    Boolean             active;
    filterPolicy        fp;
    Uint32              interface;          /* bit mask type */
    char                domainName[MAX_DOMAIN_NAME_LENGTH + 1];
    //char                ipGroup[];
} DnsFilterProfile;


#define MAX_PDB_BIT_COUNT	((MAX_PDB_PROFILES >> 3) + 1)

/*
 *上网行为管理
 */
typedef struct {
    Boolean	enable;
    Boolean	active;
    char	indexName[MAX_INDEX_NAME_LEN + 1];
    char	groupName[MAX_IPGROUP_NAME_LENGTH + 1];
    char	tmrgName[MAX_PROFILE_NAME_LENGTH + 1];
    char	remark[MAX_REMARK_LENGTH + 1];
    Byte	pdbPolicy[MAX_PDB_BIT_COUNT];
} NetActionManageProfile;

/*
 * 允许例外的QQ上网
 */
typedef struct {
    Boolean	enable;
    Uint32	qqNumber;
    char	indexName[MAX_INDEX_NAME_LEN + 1];
    char	remark[MAX_REMARK_LENGTH + 1];
}QQExceptionProfile;

#endif /* MIBFILTR_H */


