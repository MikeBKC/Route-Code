    /*
     * Notice: file generated by MIBMAKE from mibinppp.mdf
     * DO NOT EDIT THIS FILE!!!  Edit mibinppp.mdf
     */
#line 3 "mibinppp.mdf"
/*
 * $Id: mibinppp.h,v 1.1.1.1 2011/08/17 11:11:56 brwang Exp $
 *
 *      Copyright (c) 1996 UTT Technologies, Inc.
 *      All rights reserved.
 *      Use of copyright notice does not imply publication.
 *
 *
 *                      CONFIDENTIAL INFORMATION
 *                      ------------------------
 *      This Document contains Confidential Information or Trade Secrets,
 *      or both, which are the property of UTT Technologies, Inc.
 *      This document may not be copied, reproduced, reduced to any
 *      electronic medium or machine readable form or otherwise duplicated
 *      and the information herein may not be used, disseminated or
 *      otherwise disclosed, except with the prior written consent of
 *      UTT Technologies, Inc.
 */

#line 32 "mibinppp.mdf"

#if (( ! defined( MIBINPPP_H ) ) && ( MDF_PPP == FYES ))
# define MIBINPPP_H

# include "mibgen.h"
# include "mibglob.h"
# include "mibpppauth.h"
# include "mibcomp.h"
# include "mibcbcp.h"
# include "mibmonitor.h"
# if ( CBCP == FYES )
#  include "cbcp.h"
# endif


    /*
     * How to build the factory instance of this profile.
     */
extern ConstPtr
mibFactoryPppOptions( MibProfileType	mibType,
		      Uint32		info );

    /*
     * Our parameter table is made external as the profile is used
     * within other profiles.
     */
extern const MibFieldComplexParams	pppOptionsParams;

    /*
     * PPPInterfaceType:
     *
     * Describes the PPP framing interface
     *
     *  PPP_HDLC_FRAMING PPP using HDLC-like framing
     *
     *  PPP_FRAME_RELAY_FRAMING PPP using Frame Relay for framing
     *
     *  PPP_AAL5_FRAMING PPP using AAL5 for framing
     *
     *  PPP_X25_FRAMING PPP using X.25 framing
     */

#if ( MDF_M_M_FRAMING == FYES )

typedef enum PPPInterfaceType {
#line 99 "mibinppp.mdf"
    PPP_HDLC_FRAMING,
#line 102 "mibinppp.mdf"
    PPP_FRAME_RELAY_FRAMING,
#line 105 "mibinppp.mdf"
    PPP_AAL5_FRAMING,
#line 108 "mibinppp.mdf"
    PPP_X25_FRAMING
} PPPInterfaceType;

#endif /* ( MDF_M_M_FRAMING == FYES ) */

#if ( MDF_M_M_FRAMING == FYES )



static __inline__ Bool
validPPPInterfaceType (int x)
{
    switch (x) {
#line 99 "mibinppp.mdf"
    case PPP_HDLC_FRAMING:
#line 102 "mibinppp.mdf"
    case PPP_FRAME_RELAY_FRAMING:
#line 105 "mibinppp.mdf"
    case PPP_AAL5_FRAMING:
#line 108 "mibinppp.mdf"
    case PPP_X25_FRAMING:
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* ( MDF_M_M_FRAMING == FYES ) */

typedef enum en_PPPLqmType {
    PPP_LQM_DISABLED,
    PPP_LQM_ENABLED,
    PPP_LQM_ECHO,
    PPP_LQM_MAX
} PppLqmType;

    /*
     * PppOptions:
     *
     * Ppp configuration options.
     *
     *  pppAuthMode The type of PPP authentication to use for this call.
     *
     *  sendPassword This is the password sent to the far end; used for MPP and
     *                                  PPP PAP and CHAP security.
     *
     *  substSendName Name send to the far end, if different from the global
     *                                  system name.
     *
     *  recvPassword This is the password received from the far end; used for
     *                                  MPP and PPP PAP and CHAP security.
     *
     *  pppEnabled Hidden, needed by answer profile.
     *
     *  fill1 filler to 32-bit boundary.
     *
     *  compressionType The type of link compression to use for PPP, MP, and
     *                                  MPP calls.
     *
     *  myPppMru The Maximum Receive Unit, i.e. the largest frame we will
     *                                  accept.
     *
     *  lqmEnable Link Quality Monitoring. Set to Yes to enable the PPP LQM
     *                                  protocol.
     *
     *  discOnAuthTimeout Hiddem, needed by answer profile.
     *
     *  lqmMinPeriod The minimum period, in 1/100 of a second, that we will
     *                                  accept/send link quality monitoring
     *                                  packets.
     *
     *  lqmMaxPeriod The maximum period, in 1/100 of a second, that we will
     *                                  accept/send link quality monitoring
     *                                  packets.
     *
     *  acfCompEnable Enable PPP address and control field compression option.
     *
     *  pfCompEnable Enable Procotol Field Compression (async only).
     *
     *  asyncControlCharMap A 4 byte (32 bit) field, that indicates which of
     *                                  the 32 control codes should not be sent
     *                                  in the clear.
     *
     *  cbcpEnable Enable Microsoft Callback Control Protocol Negotiation.
     *
     *  cbcpMode CBCP operation allowed on to use for this call.
     *
     *  cbcpDelay Delay to request before callback to us is initiated
     *
     *  cbcpTrunkGroup Trunk group to use for the callback.
     *
     *  splitCodeDotUserEnabled TRUE if local splitting of passwords is desired
     *                                  in CACHE-TOKEN. This feature permits
     *                                  the use of usernames longer than five
     *                                  chars, when using a typical 4 digit pin
     *                                  and 6 digit ACE token code.
     *
     *  pppInterfaceType PPP network interface for this profile.
     */
/*
 * NK = netkeeper
 * but CNC is not netKeeper is MAX
 */
#if (NETKEEPER == FYES)
typedef enum nk_dail_mode {
    NK_DIAL_MODE_NORMAL,
    NK_DIAL_MODE_SPECIAL_1,//jiangxi 2.5 v7 v12
    NK_DIAL_MODE_SPECIAL_2,//hunan,hubei 3.0
    NK_DIAL_MODE_SPECIAL_3 //henan       345
} NKDIALMODE;
#endif


typedef struct st_pppOptions {
#line 131 "mibinppp.mdf"
    PppAuthMode                         pppAuthMode;
#line 136 "mibinppp.mdf"
    char                                sendPassword[ MAX_PASSWORD_LENGTH + 1 ];
#line 142 "mibinppp.mdf"
#if ( SUB_SEND_NAME == FYES )
    char                                substSendName[ MAX_UNIT_NAME_LEN + 1 ];
    char                                substRecvName[ MAX_UNIT_NAME_LEN + 1 ];
#endif /* ( SUB_SEND_NAME == FYES ) */
#if (NETKEEPER == FYES)
    NKDIALMODE                          nkDialMode;
#endif
#line 148 "mibinppp.mdf"
    char                                recvPassword[ MAX_PASSWORD_LENGTH + 1 ];
#line 154 "mibinppp.mdf"
    Boolean                             pppEnabled;
#line 160 "mibinppp.mdf"
    char                                fill1;
#line 166 "mibinppp.mdf"
    CompressionType                     compressionType;
#line 172 "mibinppp.mdf"
    Uint16                              myPppMru;
    Uint16                              myPppMtu;
#line 178 "mibinppp.mdf"
    PppLqmType                          lqmEnable;
#line 184 "mibinppp.mdf"
    Bool                                discOnAuthTimeout;
#line 190 "mibinppp.mdf"
    Uint16                              lqmMinPeriod;
#line 196 "mibinppp.mdf"
    Uint16                              lqmMaxPeriod;
#line 202 "mibinppp.mdf"
    Boolean                             acfCompEnable;
#line 208 "mibinppp.mdf"
    Boolean                             pfCompEnable;
#line 214 "mibinppp.mdf"
    Byte                                asyncControlCharMap[ 4 ];
#line 221 "mibinppp.mdf"
#if ( MDF_CBCP == FYES )
    Boolean                             cbcpEnable;
#endif /* ( MDF_CBCP == FYES ) */
#line 227 "mibinppp.mdf"
#if ( MDF_CBCP == FYES )
    CbcpMode                            cbcpMode;
#endif /* ( MDF_CBCP == FYES ) */
#line 233 "mibinppp.mdf"
#if ( MDF_CBCP == FYES )
    Uint16                              cbcpDelay;
#endif /* ( MDF_CBCP == FYES ) */
#line 239 "mibinppp.mdf"
#if ( MDF_CBCP == FYES )
    Uint16                              cbcpTrunkGroup;
#endif /* ( MDF_CBCP == FYES ) */
#line 245 "mibinppp.mdf"
#if ( LCP_CHALLENGE_CLIENT == FYES )
    Boolean                             splitCodeDotUserEnabled;
#endif /* ( LCP_CHALLENGE_CLIENT == FYES ) */
#line 253 "mibinppp.mdf"
#if ( M_M_FRAMING == FYES )
    PPPInterfaceType                    pppInterfaceType;
#endif /* ( M_M_FRAMING == FYES ) */
}
#if ( USERIF & CLI )
__PACK__
#endif
PppOptions;
#line 344 "mibinppp.mdf"

# endif /* (( ! defined( MIBINPPP_H ) ) && ( MDF_PPP == FYES )) */

