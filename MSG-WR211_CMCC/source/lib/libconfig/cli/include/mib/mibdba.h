    /*
     * Notice: file generated by MIBMAKE from mibdba.mdf
     * DO NOT EDIT THIS FILE!!!  Edit mibdba.mdf
     */
#line 2 "mibdba.mdf"
/*
 * $Id: mibdba.h,v 1.1.1.1 2011/08/17 11:11:56 brwang Exp $
 *
 *      Copyright (c) 1995 UTT Technologies, Inc.
 *      All rights reserved.
 *      Use of copyright notice does not imply publication.
 *
 *
 *                      CONFIDENTIAL INFORMATION
 *                      ------------------------
 *      This Document contains Confidential Information or Trade Secrets,
 *      or both, which are the property of UTT Technologies, Inc.
 *      This document may not be copied, reproduced, reduced to any
 *      electronic medium or machine readable form or otherwise duplicated
 *      and the information herein may not be used, disseminated or
 *      otherwise disclosed, except with the prior written consent of
 *      UTT Technologies, Inc.
 */

#line 24 "mibdba.mdf"

#if ! defined( MIBDBA_H )
# define MIBDBA_H

# include "mibsct.h"


    /* This file contains the internal representation of the dba profile
     * (MIB_PROF_DBA_SESSION). The name of this profile is stored in the global
     * variable mibProfDba.
     */

extern const char* const		mibProfDba;

#line 56 "mibdba.mdf"

    /*
     * The DBA parameters may change based on the time of day, among other
     * things.  The total number of time periods supported within the profile
     * is defined below.  This is hard-wired, and is based purely on
     * gut-feeling.  I don't think it makes sense to make this a variable
     * parameters, though.
     */
# define MAX_TIME_PERIODS	4


    /*
     * CallChType:
     *
     * Channel Type.
     *
     *  CALL_CH_N_BY
     *
     *  CALL_CH_N_BY_BONDING
     *
     *  CALL_CH_1_CH
     *
     *  CALL_CH_2_CH
     *
     *  CALL_CH_FT1
     *
     *  CALL_CH_FT1_AIM
     *
     *  CALL_CH_FT1_BO
     *
     *  CALL_CH_FT1_STATIC_BO
     *
     *  NUMBER_OF_CALL_CH_TYPES
     */
typedef enum CallChType {
#line 73 "mibdba.mdf"
    CALL_CH_N_BY,
#line 74 "mibdba.mdf"
    CALL_CH_N_BY_BONDING,
#line 75 "mibdba.mdf"
    CALL_CH_1_CH,
#line 76 "mibdba.mdf"
    CALL_CH_2_CH,
#line 78 "mibdba.mdf"
#if ( MDF_NAILED_CHANS == FYES )
    CALL_CH_FT1,
#endif /* ( MDF_NAILED_CHANS == FYES ) */
#line 81 "mibdba.mdf"
#if ( MDF_NAILED_CHANS == FYES )
    CALL_CH_FT1_AIM,
#endif /* ( MDF_NAILED_CHANS == FYES ) */
#line 84 "mibdba.mdf"
#if ( MDF_NAILED_CHANS == FYES )
    CALL_CH_FT1_BO,
#endif /* ( MDF_NAILED_CHANS == FYES ) */
#line 87 "mibdba.mdf"
#if defined( SPRINT_UPS_SPECIALX )
    CALL_CH_FT1_STATIC_BO,
#endif /* defined( SPRINT_UPS_SPECIALX ) */
#line 90 "mibdba.mdf"
    NUMBER_OF_CALL_CH_TYPES
} CallChType;


static __inline__ Bool
validCallChType (int x)
{
    switch (x) {
#line 73 "mibdba.mdf"
    case CALL_CH_N_BY:
#line 74 "mibdba.mdf"
    case CALL_CH_N_BY_BONDING:
#line 75 "mibdba.mdf"
    case CALL_CH_1_CH:
#line 76 "mibdba.mdf"
    case CALL_CH_2_CH:
#line 78 "mibdba.mdf"
#if ( MDF_NAILED_CHANS == FYES )
    case CALL_CH_FT1:
#endif /* ( MDF_NAILED_CHANS == FYES ) */
#line 81 "mibdba.mdf"
#if ( MDF_NAILED_CHANS == FYES )
    case CALL_CH_FT1_AIM:
#endif /* ( MDF_NAILED_CHANS == FYES ) */
#line 84 "mibdba.mdf"
#if ( MDF_NAILED_CHANS == FYES )
    case CALL_CH_FT1_BO:
#endif /* ( MDF_NAILED_CHANS == FYES ) */
#line 87 "mibdba.mdf"
#if defined( SPRINT_UPS_SPECIALX )
    case CALL_CH_FT1_STATIC_BO:
#endif /* defined( SPRINT_UPS_SPECIALX ) */
#line 90 "mibdba.mdf"
    case NUMBER_OF_CALL_CH_TYPES:
        return TRUE;
    default:
        return FALSE;
    }
}

    /*
     * CallMgmtProtocol:
     *
     * A single DBA session may be either fixed rate or variable rate... Other
     * alternatives are single or dual-v.35 clear channel mode, static rate (no
     * control channel), and exact rate (variable width control channel
     * selected to give the user an exact N=56/64 (not implemented --requires
     * new hardware).
     *
     *  CALL_MGMT_STATIC_RATE
     *
     *  CALL_MGMT_MANUAL_RATE
     *
     *  CALL_MGMT_DYNAMIC_RATE
     *
     *  CALL_MGMT_DELTA_RATE
     *
     *  CALL_MGMT_TIME_OF_DAY
     *
     *  CALL_MGMT_ONE_OF_EIGHT
     *
     *  CALL_MGMT_ONE_OF_FOURTY
     *
     *  CALL_MGMT_BONDING_0
     *
     *  CALL_MGMT_BONDING_1
     *
     *  CALL_MGMT_BONDING_2
     *
     *  CALL_MGMT_BONDING_3
     *
     *  NUMBER_OF_CALL_MGMT_PROTOCOLS
     */
typedef enum CallMgmtProtocol {
#line 102 "mibdba.mdf"
    CALL_MGMT_STATIC_RATE,
#line 103 "mibdba.mdf"
    CALL_MGMT_MANUAL_RATE,
#line 104 "mibdba.mdf"
    CALL_MGMT_DYNAMIC_RATE,
#line 105 "mibdba.mdf"
    CALL_MGMT_DELTA_RATE,
#line 106 "mibdba.mdf"
    CALL_MGMT_TIME_OF_DAY,
#line 108 "mibdba.mdf"
#if defined AUSI_SUB_CHANNEL
    CALL_MGMT_ONE_OF_EIGHT,
#endif /* defined AUSI_SUB_CHANNEL */
#line 111 "mibdba.mdf"
#if defined AUSI_SUB_CHANNEL
    CALL_MGMT_ONE_OF_FOURTY,
#endif /* defined AUSI_SUB_CHANNEL */
#line 114 "mibdba.mdf"
    CALL_MGMT_BONDING_0,
#line 115 "mibdba.mdf"
    CALL_MGMT_BONDING_1,
#line 116 "mibdba.mdf"
    CALL_MGMT_BONDING_2,
#line 117 "mibdba.mdf"
    CALL_MGMT_BONDING_3,
#line 118 "mibdba.mdf"
    NUMBER_OF_CALL_MGMT_PROTOCOLS
} CallMgmtProtocol;


static __inline__ Bool
validCallMgmtProtocol (int x)
{
    switch (x) {
#line 102 "mibdba.mdf"
    case CALL_MGMT_STATIC_RATE:
#line 103 "mibdba.mdf"
    case CALL_MGMT_MANUAL_RATE:
#line 104 "mibdba.mdf"
    case CALL_MGMT_DYNAMIC_RATE:
#line 105 "mibdba.mdf"
    case CALL_MGMT_DELTA_RATE:
#line 106 "mibdba.mdf"
    case CALL_MGMT_TIME_OF_DAY:
#line 108 "mibdba.mdf"
#if defined AUSI_SUB_CHANNEL
    case CALL_MGMT_ONE_OF_EIGHT:
#endif /* defined AUSI_SUB_CHANNEL */
#line 111 "mibdba.mdf"
#if defined AUSI_SUB_CHANNEL
    case CALL_MGMT_ONE_OF_FOURTY:
#endif /* defined AUSI_SUB_CHANNEL */
#line 114 "mibdba.mdf"
    case CALL_MGMT_BONDING_0:
#line 115 "mibdba.mdf"
    case CALL_MGMT_BONDING_1:
#line 116 "mibdba.mdf"
    case CALL_MGMT_BONDING_2:
#line 117 "mibdba.mdf"
    case CALL_MGMT_BONDING_3:
#line 118 "mibdba.mdf"
    case NUMBER_OF_CALL_MGMT_PROTOCOLS:
        return TRUE;
    default:
        return FALSE;
    }
}

    /*
     * FailureAction:
     *
     * If, after trying everything possible to set up a session based on the
     * parameters specified, the unit is still unable, it must do something
     * about it. The only options I can think of today are to either disconnect
     * the session altogether (this might be desirable in a video conferencing
     * system) or simply to try at a lower rate (a la LAN world).
     *
     *  FAILURE_DISCONNECT
     *
     *  FAILURE_REDUCE_RATE
     *
     *  FAILURE_RETRY
     *
     *  NUMBER_OF_FAILURE_ACTIONS
     */
typedef enum FailureAction {
#line 131 "mibdba.mdf"
    FAILURE_DISCONNECT,
#line 132 "mibdba.mdf"
    FAILURE_REDUCE_RATE,
#line 133 "mibdba.mdf"
    FAILURE_RETRY,
#line 134 "mibdba.mdf"
    NUMBER_OF_FAILURE_ACTIONS
} FailureAction;


static __inline__ Bool
validFailureAction (int x)
{
    switch (x) {
#line 131 "mibdba.mdf"
    case FAILURE_DISCONNECT:
#line 132 "mibdba.mdf"
    case FAILURE_REDUCE_RATE:
#line 133 "mibdba.mdf"
    case FAILURE_RETRY:
#line 134 "mibdba.mdf"
    case NUMBER_OF_FAILURE_ACTIONS:
        return TRUE;
    default:
        return FALSE;
    }
}

    /*
     * BertTestOptions:
     *
     * The options available to the user with regards to running an automatic
     * BERT test at call establishment time. This option is available for US
     * Sprint so that the Multiband will automatically detect the problems in
     * the network without the user having to intervene.
     *
     *  BERT_TEST_OFF
     *
     *  BERT_TEST_15_SECONDS
     *
     *  BERT_TEST_30_SECONDS
     *
     *  BERT_TEST_60_SECONDS
     *
     *  BERT_TEST_90_SECONDS
     *
     *  BERT_TEST_120_SECONDS
     *
     *  NUMBER_OF_BERT_TEST_OPTIONS
     */
typedef enum BertTestOptions {
#line 146 "mibdba.mdf"
    BERT_TEST_OFF,
#line 147 "mibdba.mdf"
    BERT_TEST_15_SECONDS,
#line 148 "mibdba.mdf"
    BERT_TEST_30_SECONDS,
#line 149 "mibdba.mdf"
    BERT_TEST_60_SECONDS,
#line 150 "mibdba.mdf"
    BERT_TEST_90_SECONDS,
#line 151 "mibdba.mdf"
    BERT_TEST_120_SECONDS,
#line 152 "mibdba.mdf"
    NUMBER_OF_BERT_TEST_OPTIONS
} BertTestOptions;


static __inline__ Bool
validBertTestOptions (int x)
{
    switch (x) {
#line 146 "mibdba.mdf"
    case BERT_TEST_OFF:
#line 147 "mibdba.mdf"
    case BERT_TEST_15_SECONDS:
#line 148 "mibdba.mdf"
    case BERT_TEST_30_SECONDS:
#line 149 "mibdba.mdf"
    case BERT_TEST_60_SECONDS:
#line 150 "mibdba.mdf"
    case BERT_TEST_90_SECONDS:
#line 151 "mibdba.mdf"
    case BERT_TEST_120_SECONDS:
#line 152 "mibdba.mdf"
    case NUMBER_OF_BERT_TEST_OPTIONS:
        return TRUE;
    default:
        return FALSE;
    }
}

    /*
     * DBAProfile:
     *
     * The general DBA profile is defined below.
     *
     *  name DBA Profiles are recognized by their names given them by the user.
     *                                  The name is a standard null terminated
     *                                  ASCII string.
     *
     *  phoneNumber The number to dial for this call.
     *
     *  billingNumber The billing number to use which is either a 'calling
     *                                  party number' or a 'billing suffix'
     *                                  that is appended to the end of the
     *                                  phone number.
     *
     *  callChType session channel type.
     *
     *  callMgmtProtocol One of the management type listed above.
     *
     *  switchedCallType The type of bearer channel capability to set up for
     *                                  each switched call in the session.
     *
     *  force56 TRUE if the data should be treated as 7-bit data even if the
     *                                  switchedCallType would normally imply 8
     *                                  bit data.
     *
     *  baseChannelCount When the session is initially set up, and if it is a
     *                                  fixed session, the number of channels
     *                                  to be used for the call.
     *
     *  incrementChannelCount Number of channels to increment as a block.
     *
     *  decrementChannelCount Number of channels to decrement as a block.
     *
     *  failureAction If unable to establish a dba session based on the
     *                                  parameters specified, then the action
     *                                  to be taken is specified in the
     *                                  failureAction.
     *
     *  bitInversionRequired TRUE if the data being transferred from the host
     *                                  should be inverted before being sent to
     *                                  the network, and FALSE otherwise. I
     *                                  think this needs to be supported by the
     *                                  device, but I will check before
     *                                  committing. Also, this affects the
     *                                  network interface too, I think.
     *
     *  ft1Caller BOOLEAN which is true for Fractional T1 calls when this side
     *                                  is the caller, and FALSE otherwise.
     *
     *  ft1Timeout
     *
     *  callByCallID The ID for the call-by-call signalling for PRI.
     *
     *  calledNumberType Indication of whether national number, international
     *                                  number, etc. is specified.
     *
     *  unknownPlanUNKNOWN If TRUE indicates that UNKNOWN number plan is used
     *                                  in conjunction with unknown number
     *                                  instead of default, ISDN.
     *
     *  localPlanISDN If TRUE indicates that ISDN number plan is used in
     *                                  conjunction with local number instead
     *                                  of default, PRIVATE.
     *
     *  transitNumber The string for use in the transit network ie for PRI
     *                                  calling when going through a LEC.
     *
     *  bertTestOptions Should we BERT at session startup and for how long.
     *
     *  timedCall TRUE if we should pay attention to the following time period
     *                                  parameters. Not used when the call type
     *                                  is dynamic N-by.
     *
     *  flagIdle TRUE if looking for flag idle, FALSE when looking for mark
     *                                  idle.
     *
     *  historyWeighType The algorithm to use for determining weighted line
     *                                  utilization.
     *
     *  secondsOfHistory Number of seconds to keep history data around for.
     *                                  This number is in the range of 1
     *                                  through MAX_HISTORY_SECONDS.
     *
     *  addSecondsOfPersistence Once the upper threshold of utilization is
     *                                  passed, the number of seconds it should
     *                                  stay there is defined here.
     *
     *  removeSecondsOfPersistence Once the lower threshold of utilization is
     *                                  passed, the number of seconds it should
     *                                  stay there is defined here.
     *
     *  timePeriodParameters If the session is variable, then the parameters to
     *                                  based on time-of-day segments (which
     *                                  may be all day...)
     *
     *  nailedUpGroup Nailed-up group letter. This is a group or number field
     *                                  as defined in lcdparam.h.
     *
     *  callPassword DBA call password authenticated against port's password on
     *                                  receiver side. Ignored if port's
     *                                  password is not defined.
     *
     *  dbaPRI_NumberingPlanID PRI Called Party element's Numbering-Plan-ID
     *                                  value for outgoing T1-to-PRI calls.
     */
typedef struct dbaProfile {
#line 198 "mibdba.mdf"
    char                                name[ MAX_NAME_LEN + 1 ];
#line 203 "mibdba.mdf"
    char                                phoneNumber[ MAX_USER_NUMBER_LENGTH + 1 ];
#line 207 "mibdba.mdf"
    char                                billingNumber[ MAX_BILLING_NUMBER_LENGTH + 1 ];
#line 213 "mibdba.mdf"
    CallChType                          callChType;
#line 217 "mibdba.mdf"
    CallMgmtProtocol                    callMgmtProtocol;
#line 221 "mibdba.mdf"
    SwitchedCallType                    switchedCallType;
#line 226 "mibdba.mdf"
    Boolean                             force56;
#line 231 "mibdba.mdf"
    Word                                baseChannelCount;
#line 236 "mibdba.mdf"
    Word                                incrementChannelCount;
#line 240 "mibdba.mdf"
    Word                                decrementChannelCount;
#line 244 "mibdba.mdf"
    FailureAction                       failureAction;
#line 250 "mibdba.mdf"
    Boolean                             bitInversionRequired;
#line 257 "mibdba.mdf"
#if ( MDF_NAILED_CHANS == FYES )
    Boolean                             ft1Caller;
#endif /* ( MDF_NAILED_CHANS == FYES ) */
#line 263 "mibdba.mdf"
#if ( MDF_NAILED_CHANS == FYES )
    Word                                ft1Timeout;
#endif /* ( MDF_NAILED_CHANS == FYES ) */
#line 267 "mibdba.mdf"
#if ( NETIF & ( T1 | E1 | DPNSS ))
    Word                                callByCallID;
#endif /* ( NETIF & ( T1 | E1 | DPNSS )) */
#line 272 "mibdba.mdf"
#if ( NETIF & ( T1 | E1 | DPNSS ))
    int                                 calledNumberType;
#endif /* ( NETIF & ( T1 | E1 | DPNSS )) */
#line 278 "mibdba.mdf"
#if ( PLATFORM & MPORT ) && ( NETIF & T1 )
    Boolean                             unknownPlanUNKNOWN;
#endif /* ( PLATFORM & MPORT ) && ( NETIF & T1 ) */
#line 284 "mibdba.mdf"
#if ( PLATFORM & MPORT ) && ( NETIF & T1 )
    Boolean                             localPlanISDN;
#endif /* ( PLATFORM & MPORT ) && ( NETIF & T1 ) */
#line 290 "mibdba.mdf"
#if ( NETIF & ( T1 | E1 | DPNSS ))
    char                                transitNumber[ MAX_TRANSIT_NUMBER_LENGTH + 1 ];
#endif /* ( NETIF & ( T1 | E1 | DPNSS )) */
#line 296 "mibdba.mdf"
    BertTestOptions                     bertTestOptions;
#line 300 "mibdba.mdf"
#if defined( TIMED_CALL )
    Boolean                             timedCall;
#endif /* defined( TIMED_CALL ) */
#line 306 "mibdba.mdf"
    Boolean                             flagIdle;
#line 310 "mibdba.mdf"
    HistoryWeighType                    historyWeighType;
#line 314 "mibdba.mdf"
    Word                                secondsOfHistory;
#line 319 "mibdba.mdf"
    Word                                addSecondsOfPersistence;
#line 324 "mibdba.mdf"
    Word                                removeSecondsOfPersistence;
#line 329 "mibdba.mdf"
    TimePeriodParameters                timePeriodParameters[ MAX_TIME_PERIODS ];
#line 334 "mibdba.mdf"
#if ( MDF_NAILED_CHANS == FYES )
    Word                                nailedUpGroup;
#endif /* ( MDF_NAILED_CHANS == FYES ) */
#line 340 "mibdba.mdf"
#if ( PLATFORM & MPORT )
    char                                callPassword[ MAX_PORTPW_LEN + 1 ];
#endif /* ( PLATFORM & MPORT ) */
#line 346 "mibdba.mdf"
#if ( ( PLATFORM & MPORT ) && ( NETIF & T1 ) )
    int                                 dbaPRI_NumberingPlanID;
#endif /* ( ( PLATFORM & MPORT ) && ( NETIF & T1 ) ) */
}
#if ( USERIF & CLI )
__PACK__
#endif
DBAProfile;
#line 373 "mibdba.mdf"

#endif /* MIBDBA_H */

