    /*
     * Notice: file generated by MIBMAKE from mibdebug.mdf
     * DO NOT EDIT THIS FILE!!!  Edit mibdebug.mdf
     */
#line 3 "mibdebug.mdf"
/*
 * $Id: mibdebug.h,v 1.1.1.1 2011/08/17 11:11:56 brwang Exp $
 *
 *      Copyright (c) 1996 UTT Technologies, Inc.
 *      All rights reserved.
 *      Use of copyright notice does not imply publication.
 *
 *
 *                      CONFIDENTIAL INFORMATION
 *                      ------------------------
 *      This Document contains Confidential Information or Trade Secrets,
 *      or both, which are the property of UTT Technologies, Inc.
 *      This document may not be copied, reproduced, reduced to any
 *      electronic medium or machine readable form or otherwise duplicated
 *      and the information herein may not be used, disseminated or
 *      otherwise disclosed, except with the prior written consent of
 *      UTT Technologies, Inc.
 */

#line 29 "mibdebug.mdf"

#if ! defined( MIBDEBUG_H )
# define MIBDEBUG_H

# if ( MIBMGR == FYES )
#  include "library.h"
# endif /* (MIBMGR == FYES ) */

    /*
     * This file contains the internal representation of the Debug profile
     * (MIB_PROF_DEBUG). The name of this profile is stored in the global
     * variable mibProfDebug.
     */

extern const char* const		mibProfDebug;

    /*
     * The field number used to index this profile
     */
# define MIB_PROF_DEBUG_INDEX_FIELD		7

    /*
     * Function to create the factory instance of a debug profile.
     */
# if (MIBMGR==FNO)
extern ConstPtr
mibFactoryDebugProfile( MibProfileType	mibType,
		        ConstPtr	mibIndex,
		        Int		mibIndexLen );
# endif

    /* this is the deafult value assigned to the generic debug
     * field in this profile */
# define DEFAULT_GENERIC_DEBUG_FIELD	0xffffffff


    /*
     * DebugProfile:
     *
     * A debug profile is used internally to preserve debugging information
     * across system resets.
     *
     *  physicalAddress The physical address of the card whose debug state is
     *                                  stored in this profile.
     *
     *  active Setting this field to Yes enables this profile. Setting this
     *                                  field to No disables this entire
     *                                  profile.
     *
     *  coreDumpEnabled Core dump on system failure can be enabled by setting
     *                                  this field to Yes. Core dumps are
     *                                  disabled if this field is No.
     *
     *  coreDumpServer The name (or IP address) of the host setup to receive
     *                                  our core dumps.
     *
     *  gdbEnabled GDB can be enabled by setting this field to Yes. GDB is
     *                                  disabled if this field is No.
     *
     *  gdbHost The name (or IP address) of the host running GDB.
     *
     *  csTrackingEnabled csTracking can be enabled by setting this field to
     *                                  Yes. csTracking is disabled if this
     *                                  field is No.
     *
     *  genField This field can be used as a generic bitmask stored in
     *                                  nonvolatile memory and thus preserved
     *                                  over resets and powerdowns
     */

#if ( MDF_CORE_DUMP == FYES ) || ( MDF_GDB == FYES ) || ( MDF_CS_TRACKING == FYES )

typedef struct st_debugProfile {
#line 112 "mibdebug.mdf"
    char                                name[MAX_PROFILE_NAME_LENGTH+1];
    Boolean                             active;
#line 105 "mibdebug.mdf"
#if ( MIBMGR == FYES )
    PhysicalAddress                     physicalAddress;
#endif /* ( MIBMGR == FYES ) */
#line 118 "mibdebug.mdf"
#if ( MDF_CORE_DUMP == FYES )
    Boolean                             coreDumpEnabled;
#endif /* ( MDF_CORE_DUMP == FYES ) */
#line 125 "mibdebug.mdf"
#if ( MDF_CORE_DUMP == FYES )
    char                                coreDumpServer[ MAX_HOST_NAME_LENGTH + 1 ];
#endif /* ( MDF_CORE_DUMP == FYES ) */
#line 132 "mibdebug.mdf"
#if ( MDF_GDB == FYES )
    Boolean                             gdbEnabled;
#endif /* ( MDF_GDB == FYES ) */
#line 139 "mibdebug.mdf"
#if ( MDF_GDB == FYES )
    char                                gdbHost[ MAX_HOST_NAME_LENGTH + 1 ];
#endif /* ( MDF_GDB == FYES ) */
#line 145 "mibdebug.mdf"
#if ( MDF_CS_TRACKING == FYES )
    Boolean                             csTrackingEnabled;
#endif /* ( MDF_CS_TRACKING == FYES ) */
#line 152 "mibdebug.mdf"
#if ( MDF_MIBMGR == FYES )
    Uint32                              genField;
#endif /* ( MDF_MIBMGR == FYES ) */
}
#if ( USERIF & CLI )
__PACK__
#endif
DebugProfile;

#endif /* ( MDF_CORE_DUMP == FYES ) || ( MDF_GDB == FYES ) || ( MDF_CS_TRACKING == FYES ) */
#line 162 "mibdebug.mdf"
    /*
     * writeDebugProfile
     *
     * Write the designated profile out to NVRAM
     *
     */
extern Boolean
writeDebugProfile( DebugProfile* profileData );

    /*
     * readDebugProfile
     *
     * Read the designated profile out from NVRAM
     *
     */
extern Boolean
readDebugProfile( DebugProfile* profileData );

#  if ( MIBMGR == FYES )

static DebugProfile	globalDebugProfile;
static __inline__ ConstPtr
mibFactoryDebugProfileByShelfAndSlot( TntShelfNumber	shelf,
				      TntSlotNumber	slot )
{

    memset( &globalDebugProfile, 0, sizeof( globalDebugProfile ));

    globalDebugProfile.active = TRUE;

    globalDebugProfile.physicalAddress.shelf = shelf;
    globalDebugProfile.physicalAddress.slot = slot;
    globalDebugProfile.physicalAddress.item = 0;

#   if ( MDF_CORE_DUMP == FYES )
    globalDebugProfile.coreDumpEnabled = FALSE;
    globalDebugProfile.coreDumpServer[0] = 0;
#   endif /* ( MDF_CORE_DUMP == FYES ) */

#   if ( MDF_GDB == FYES )
    globalDebugProfile.gdbEnabled = FALSE;
    globalDebugProfile.gdbHost[0] = 0;
#   endif /* ( MDF_GDB == FYES ) */

#   if ( MDF_CS_TRACKING == FYES )
    globalDebugProfile.csTrackingEnabled = TRUE;
#   endif /* MDF_CS_TRACKING == FYES ) */

    globalDebugProfile.genField = DEFAULT_GENERIC_DEBUG_FIELD;

    return &globalDebugProfile;
}

static __inline__ ConstPtr
mibFactoryDebugProfile( MibProfileType	mibType,
		        ConstPtr	mibIndex,
		        Int		mibIndexLen )
{
    (void) mibType;
    (void) mibIndex;
    (void) mibIndexLen;
    return mibFactoryDebugProfileByShelfAndSlot( (TntShelfNumber)0, (TntSlotNumber)0 );
}

extern __inline__ Boolean
readDebugProfileByShelfAndSlot( DebugProfile*	profileData,
				TntShelfNumber	shelf,
				TntSlotNumber	slot )
{
    if ( profileData ) {
	PhysicalAddress physicalAddress;
	MibResult r;

	physicalAddress.shelf = shelf;
	physicalAddress.slot = slot;
	physicalAddress.item = 0;
	r = mibDataByIndex ( MIB_PROF_DEBUG,
				&physicalAddress, sizeof(physicalAddress),
				profileData, sizeof(*profileData) );
	return ( r == MIB_RESULT_OK );
    }
    return FALSE;
}

extern __inline__ void
createDebugProfile( DebugProfile* profileData )
{
    *profileData = *(DebugProfile*)
	mibFactoryDebugProfileByShelfAndSlot( myShelfNumber(), mySlotNumber() );
}

extern __inline__ Boolean
readDebugProfile( DebugProfile* profileData )
{
    return readDebugProfileByShelfAndSlot( profileData, myShelfNumber(), mySlotNumber() );
}

extern __inline__ Boolean
writeDebugProfile( DebugProfile* profileData )
{
    profileData->physicalAddress.shelf = myShelfNumber();
    profileData->physicalAddress.slot = mySlotNumber();
    profileData->physicalAddress.item = 0;
    return MIB_RESULT_OK ==
       mibWriteProfile( MIB_PROF_DEBUG, profileData, sizeof(*profileData) );
}

#  endif /* ( MIBMGR == FYES ) */

#line 410 "mibdebug.mdf"

# endif /* MIBINET_H */

