# if (OLDNAT)
/*
 * Notice: file generated by MIBMAKE from mibnat.mdf
 * DO NOT EDIT THIS FILE!!!  Edit mibnat.mdf
 */

#line 2 "mibnat.mdf"
/*
 * 	$Id: mibnat.h,v 1.1.1.1 2011/08/17 11:11:56 brwang Exp $
 *
 *      Copyright (c) 1995 UTT Technologies, Inc.
 *      All rights reserved.
 *      Use of copyright notice does not imply publication.
 *
 *
 *                      CONFIDENTIAL INFORMATION
 *                      ------------------------
 *      This Document contains Confidential Information or Trade Secrets,
 *      or both, which are the property of UTT Technologies, Inc.
 *      This document may not be copied, reproduced, reduced to any
 *      electronic medium or machine readable form or otherwise duplicated
 *      and the information herein may not be used, disseminated or
 *      otherwise disclosed, except with the prior written consent of
 *      UTT Technologies, Inc.
 */

#line 24 "mibnat.mdf"

#if ! defined( MIBNAT_H )
#define MIBNAT_H

# include "mibglob.h"

    /* NAPT TIMEOUT */
    /* UDP fast times out in 30 seconds */
#  define NAPT_UDPFAST_TIMEOUT		(1 * 30)
    /* DNS times out in 1 minute */
#  define NAPT_UDPDNS_TIMEOUT		(1 * 60)
    /* Non-DNS UDP translations time out after 5 minutes */
#  define NAPT_UDPNONDNS_TIMEOUT	(5 * 60)
    /* TCP translations time out after idle time 12 hours */
#  define NAPT_TCP_TIMEOUT		(12*60*60)
    /* HTTP port over TCP translations time out after 10 minutes */
#  define NAPT_TCP_HTTP_TIMEOUT		(10 * 60)
    /* After FIN or RST is seen in the stream of this port, 
     * time out after 1 minutes 
     */
#  define NAPT_TCP_FINRST_TIMEOUT       (1 * 60)


    /* This file contains the internal representation of the nat profile
     * (MIB_PROF_NAT). The name of this profile is stored in the global
     * variable mibProfNat.
     */

extern const char* const		mibProfNat;

extern ConstPtr
mibFactoryNatProfile( MibProfileType	mibType,
		       ConstPtr		mibIndex,
		       Int		mibIndexLen );

#define MAX_NAT_FILTER    			2

#define MAX_NAT_OPENHOST    			6

//modify by cyh 061013 for min session count,old value is 100
#define MIN_NAT_PERUSER_SESSION_LIMIT	        0
#undef  MIN_NAT_PERUSER_SESSION_LIMIT	        
#define MIN_NAT_PERUSER_SESSION_LIMIT	        0
#define DEFAULT_NAT_PERUSER_SESSION_LIMIT	min(2500,MAX_NAT_TABLE_ENTRY)
#define DEFAULT_NAT_PERUSER_UDP_SESSION_LIMIT	min(2200,MAX_NAT_TABLE_ENTRY)
#define DEFAULT_NAT_PERUSER_ICMP_SESSION_LIMIT	min(100,MAX_NAT_TABLE_ENTRY)
#define DEFAULT_NAT_PERUSER_TCP_SESSION_LIMIT	min(2200,MAX_NAT_TABLE_ENTRY)
//#define DEFAULT_NAT_AGER_TIMER		617
//#define DEFAULT_NAT_AGER_TIMER		317
#define DEFAULT_NAT_AGER_TIMER			217
#define MAX_NAT_AGER_TIMER		 	36107	
    /*
     * The field number used to index this profile
    */

#define MIB_PROF_NAT_INDEX	1


    /*
     * StaticMapProtocol:
     *
     * Protocol field for static map entry
     *
     *  SM_TCP_PROT static map tcp protocol.
     *
     *  SM_UDP_PROT static map udp protocol.
     */
typedef enum StaticMapProtocol {
#line 83 "mibnat.mdf"
     SM_NONE_PROT,
     SM_TCP_PROT,
#line 86 "mibnat.mdf"
     SM_UDP_PROT,
     SM_ICMP_PROT,
     SM_IGMP_PROT,
     SM_IPINIP_PROT,
     SM_GRE_PROT,
     SM_ESP_PROT,
     SM_AH_PROT,
     SM_OSPF_PROT
} StaticMapProtocol;

typedef enum enNatAction {
	NAT_DISABLE,
	NAT_BiDIRECTION,
	NAT_INSIDE,
	NAT_OUTSIDE,
	MAX_NAT_ACTION
} natAction;

typedef enum en_natPoolType {
     NAT_NONE =  0x0,
     NAT_EASY =  0x1,
     NAT_TRANS = 0x2,
     NAT_SRC = 	 0x4,
     NAT_DST =   0x8
} natPoolType;

typedef struct st_nat_iff {
  char      	name[MAX_PROFILE_NAME_LENGTH + 1];    /* pool name */ 
  Boolean   	active;
  char      	profile[MAX_PROFILE_NAME_LENGTH + 1]; /* bind to a natProfile */
  Boolean	natEasyIp;
  Uint8		natOverride;
  natPoolType	poolType;                   /* globale/private/override */
  Boolean   	sharedPool;	 	    /* if can share with others */
  IpAddress 	globalIpBase;               /* global ip address start */
  Uint32    	globalIpNum;                /* global ip address end */
  IpAddress 	privateIpBase;              /* global ip address start */
  Uint32    	privateIpNum;               /* global ip address end */
  IpAddress 	ipFilterAddr[MAX_NAT_FILTER]; 
					/* ip address filer */
  IpAddress 	ipFilterMask[MAX_NAT_FILTER];            
					/* ip address filter mask*/
  IpAddress 	ipFilterEnd[MAX_NAT_FILTER];            
					/* end of ip address */
  IpAddress 	openHostInternal[MAX_NAT_OPENHOST];            
					/* internal ip host open to external */
  IpAddress 	openHostExternal[MAX_NAT_OPENHOST];            
					/* external ip  of openhost */
  Boolean       natReRouting;
  IpAddress     natReRoutingAddress;
  Char          natInFilterGroup[MAX_PROFILE_NAME_LENGTH+1];
  Char          natOutFilterGroup[MAX_PROFILE_NAME_LENGTH+1];
} natAddrPoolMap; 

static __inline__ Bool
validStaticMapProtocol (int x)
{
    switch (x) {
#line 83 "mibnat.mdf"
    case SM_TCP_PROT:
#line 86 "mibnat.mdf"
    case SM_UDP_PROT:
    case SM_ICMP_PROT:
    case SM_IGMP_PROT:
    case SM_IPINIP_PROT:
    case SM_GRE_PROT:
    case SM_ESP_PROT:
    case SM_AH_PROT:
    case SM_OSPF_PROT:
  
        return TRUE;
    default:
        return FALSE;
    }
}

    /*
     * StaticMapEntry:
     *
     * A StaticMapEntry defines a particular static mapping. The static mapping
     * is used for input Wan processing.
     *
     *  active When TRUE, this filter entry has been defined and properly
     *                                  initialized. When FALSE, this entry
     *                                  should be skipped
     *
     *  destPort The destPort represents the destination port number from
     *                                  TCP/UDP packets from the Wan to the
     *                                  Lan.
     *
     *  protocol The protocol represents the protocol type
     *
     *  localPort The localPort represents the local port number for machines
     *                                  on the Lan side.
     *
     *  localAddress The localAddress represents the local IP Address of
     *                                  machines on the Lan side.
     *
     *  name The name of static map.
     *
     */

typedef struct staticMapEntry {
#line 131 "mibnat.mdf"
    Boolean                             active;
#line 136 "mibnat.mdf"
    Word                                destPort;
#line 141 "mibnat.mdf"
    StaticMapProtocol                   protocol;
#line 145 "mibnat.mdf"
    Word                                localPort;
#line 150 "mibnat.mdf"
#if ( MDF_IP == FYES )
    IpAddress                           localAddress;
#endif /* ( MDF_IP == FYES ) */
    char				name[MAX_PROFILE_NAME_LENGTH + 1];
    Uint16				destPortRange;
    IpAddress				destAddress;
    Uint16				destAddressRange;
    char                                profile[MAX_PROFILE_NAME_LENGTH + 1];
}
#if ( USERIF & CLI )
__PACK__
#endif
StaticMapEntry;

    /*
     * NatProfile:
     *
     * A NatProfile contains configuration information for NAT.
     *
     *  natRouting A boolean. When set to TRUE it translates all the lan
     *                                  addresses to dynamicaly assigned
     *                                  internet address.
     *
     *  natProfile The profile to use for NAT Routing.
     *
     *  natLan Which NAT Lan option is to be use.
     *
     *  staticMaps A table of static mappings applied to incoming Wan NAT
     *                                  packets.
     *
     *  DefaultServer The LAN address of the Default Server on the Lan side
     *
     *  FrameRelayAddress The Frame Relay user assigned IP address
     *
     *  StickyIp A Boolen. When set to TRUE enables the sticky IP address
     *                                  feature - the router will try to retain
     *                                  the last IP address it got from the
     *                                  host by negotiating it with the host.
     *
     *  StickyTimeout A number. Represents the number of minutes the router
     *                                  will try to request the sticky IP
     *                                  address counting from the end of the
     *                                  last session.
     */

typedef struct st_natProfile {
#line 194 "mibnat.mdf"
#if ( MDF_NAT == FYES )
//    char                                Name[ MAX_PROFILE_NAME_LENGTH + 1 ];
    char                                name[MAX_PROFILE_NAME_LENGTH+1];
    Boolean                             active;

    Boolean                             enableNatRouting;
#endif /* ( MDF_NAT == FYES ) */
#line 200 "mibnat.mdf"
#if ( MDF_NAT == FYES )
    char                                natProfileName[ MAX_PROFILE_NAME_LENGTH + 1 ];
#endif /* ( MDF_NAT == FYES ) */
#line 205 "mibnat.mdf"
#if ( NAT_LAN_OPTIONS == FYES )
    NatLan                              natLan;
#endif /* ( NAT_LAN_OPTIONS == FYES ) */
#line 211 "mibnat.mdf"
#if ( MDF_NAPT_LAN == FYES )
    StaticMapEntry                      staticMaps[ MAX_STATIC_MAP_ENTRIES ];
#endif /* ( MDF_NAPT_LAN == FYES ) */
#line 216 "mibnat.mdf"
#if ( MDF_NAPT_LAN == FYES )
    IpAddress                           DefaultServer;
#endif /* ( MDF_NAPT_LAN == FYES ) */
#line 221 "mibnat.mdf"
#if ( MDF_FRAME_RELAY == FYES )
    IpAddress                           FrameRelayAddress;
#endif /* ( MDF_FRAME_RELAY == FYES ) */
#line 226 "mibnat.mdf"
#if ( MDF_NAPT_LAN == FYES )
    Boolean                             StickyIp;
#endif /* ( MDF_NAPT_LAN == FYES ) */
#line 233 "mibnat.mdf"
#if ( MDF_NAPT_LAN == FYES )
    Word                                StickyTimeout;
#endif /* ( MDF_NAPT_LAN == FYES ) */
	/* Add:Ast@20030106 */
	/* a tcp port, normally 1720 */
    Word				H323SignallingPort;
	/* a udp port, normally 1719 */
    Word				H323RasPort;
	/* we can disable a spoofing nat route here */
    Boolean				createSpoofRoute;
    Uint32				naptAgerTimer;
    Uint32				naptTcpIdleTimeout;
    Uint32				naptIcmpIdleTimeout;
    Uint32				naptUdpIdleTimeout;
    Uint32				naptFastUdpIdleTimeout;
    Uint32				naptGreIdleTimeout;
    Uint32				naptIpsecIdleTimeout;
    Uint32				naptHttpIdleTimeout;
    Uint32				naptTcpFinTimeout;
//    Uint32				naptSessionLimit;
//    Uint32				naptUdpSessionLimit;
//    Uint32				naptIcmpSessionLimit;
//    Uint32				naptTcpSessionLimit;
    Uint32				naptTxPktLimit;
    Uint32				naptRxPktLimit;
    Uint32				naptTxOctetsLimit;
    Uint32				naptRxOctetsLimit;
    natAddrPoolMap			natPool[MAX_NAT_IFF_ENTRIES];
    Boolean                             natReRouting;
    IpAddress                           natReRoutingAddresse;
    Boolean				natAllowNoneNaptPkt;
}
#if ( USERIF & CLI )
__PACK__
#endif
NatProfile;
#line 284 "mibnat.mdf"

#endif /* MIBNAT_H */

# endif /* OLDNAT */

# if !(OLDNAT)

/*
 * Notice: file generated by MIBMAKE from mibnat.mdf
 * DO NOT EDIT THIS FILE!!!  Edit mibnat.mdf
 */

/*
 * 	$Id: mibnat.h,v 1.1.1.1 2011/08/17 11:11:56 brwang Exp $
 *
 *      Copyright (c) 1995 UTT Technologies, Inc.
 *      All rights reserved.
 *      Use of copyright notice does not imply publication.
 *
 *
 *                      CONFIDENTIAL INFORMATION
 *                      ------------------------
 *      This Document contains Confidential Information or Trade Secrets,
 *      or both, which are the property of UTT Technologies, Inc.
 *      This document may not be copied, reproduced, reduced to any
 *      electronic medium or machine readable form or otherwise duplicated
 *      and the information herein may not be used, disseminated or
 *      otherwise disclosed, except with the prior written consent of
 *      UTT Technologies, Inc.
 */


#if ! defined( MIBNAT_H )
#define MIBNAT_H

    /* NAPT TIMEOUT */
    /* UDP fast times out in 30 seconds */
#  define NAPT_UDPFAST_TIMEOUT		(1 * 30)
    /* DNS times out in 1 minute */
#  define NAPT_UDPDNS_TIMEOUT		(1 * 60)
    /* Non-DNS UDP translations time out after 5 minutes */
#  define NAPT_UDPNONDNS_TIMEOUT	(5 * 60)
    /* TCP translations time out after idle time 12 hours */
#  define NAPT_TCP_TIMEOUT		(12*60*60)
    /* HTTP port over TCP translations time out after 10 minutes */
#  define NAPT_TCP_HTTP_TIMEOUT		(10 * 60)
    /* After FIN or RST is seen in the stream of this port, 
     * time out after 1 minutes 
     */
#  define NAPT_TCP_FINRST_TIMEOUT       (1 * 60)

    /* This file contains the internal representation of the nat profile
     * (MIB_PROF_NAT). The name of this profile is stored in the global
     * variable mibProfNat.
     */

extern const char* const		mibProfNat;

extern ConstPtr
mibFactoryNatProfile( MibProfileType	mibType,
		       ConstPtr		mibIndex,
		       Int		mibIndexLen );

#define MAX_NAT_FILTER    			2

#define MAX_NAT_OPENHOST    			6

//modify by cyh 061013 for min session count,old value is 100
#define MIN_NAT_PERUSER_SESSION_LIMIT	        0
#undef  MIN_NAT_PERUSER_SESSION_LIMIT	        
#define MIN_NAT_PERUSER_SESSION_LIMIT	        0
#define DEFAULT_NAT_PERUSER_SESSION_LIMIT	min(2500,MAX_NAT_TABLE_ENTRY)
#define DEFAULT_NAT_PERUSER_UDP_SESSION_LIMIT	min(2200,MAX_NAT_TABLE_ENTRY)
#define DEFAULT_NAT_PERUSER_ICMP_SESSION_LIMIT	min(100,MAX_NAT_TABLE_ENTRY)
#define DEFAULT_NAT_PERUSER_TCP_SESSION_LIMIT	min(2200,MAX_NAT_TABLE_ENTRY)
//#define DEFAULT_NAT_AGER_TIMER		617
//#define DEFAULT_NAT_AGER_TIMER		317
#define DEFAULT_NAT_AGER_TIMER			217
#define MAX_NAT_AGER_TIMER		 	36107	
    /*
     * The field number used to index this profile
    */

#define MIB_PROF_NAT_INDEX	1


    /*
     * StaticMapProtocol:
     *
     * Protocol field for static map entry
     *
     *  SM_TCP_PROT static map tcp protocol.
     *
     *  SM_UDP_PROT static map udp protocol.
     */
typedef enum StaticMapProtocol {
     SM_NONE_PROT,
     SM_TCP_PROT,
     SM_UDP_PROT,
     SM_ICMP_PROT,
     SM_IGMP_PROT,
     SM_IPINIP_PROT,
     SM_GRE_PROT,
     SM_ESP_PROT,
     SM_AH_PROT,
     SM_OSPF_PROT
} StaticMapProtocol;

typedef enum enNatAction {
	NAT_DISABLE,
	NAT_BiDIRECTION,
	NAT_INSIDE,
	NAT_OUTSIDE,
	MAX_NAT_ACTION
} natAction;

typedef enum en_natMethodType {
     NAT_EASY =  0x1,
     NAT_ONE2ONE = 0x2,
     NAT_PASSTHROUGH = 0x4,
     NAT_DST =   0x8
} NatMethod;

typedef struct st_nat_iff {
  char      	name[MAX_PROFILE_NAME_LENGTH + 1];    /* pool name */ 
  Boolean   	active;
  Uint32	weight;			    /* weight value for load balance */
  NatMethod	natMethod;                  /* easyip/one2one/passthrough */
  IpAddress 	globalIp;                   /* global ip address start */
  IpAddress 	internalIpFrom;             /* local ip address start */
  IpAddress 	internalIpTo;               /* local ip address end */
  IpAddress 	defaultServer;              /* default server */
  char      	profile[MAX_PROFILE_NAME_LENGTH + 1]; /* bind to a natProfile */
  Word          filterActive;
  char          inAclProfile[MAX_PROFILE_NAME_LENGTH + 1];
  char          outAclProfile[MAX_PROFILE_NAME_LENGTH + 1];
} NatBinding; 

static __inline__ Bool
validStaticMapProtocol (int x)
{
    switch (x) {
    case SM_TCP_PROT:
    case SM_UDP_PROT:
    case SM_ICMP_PROT:
    case SM_IGMP_PROT:
    case SM_IPINIP_PROT:
    case SM_GRE_PROT:
    case SM_ESP_PROT:
    case SM_AH_PROT:
    case SM_OSPF_PROT:
  
        return TRUE;
    default:
        return FALSE;
    }
}

    /*
     * StaticMapEntry:
     *
     * A StaticMapEntry defines a particular static mapping. The static mapping
     * is used for input Wan processing.
     *
     *  active When TRUE, this filter entry has been defined and properly
     *                                  initialized. When FALSE, this entry
     *                                  should be skipped
     *
     *  destPort The destPort represents the destination port number from
     *                                  TCP/UDP packets from the Wan to the
     *                                  Lan.
     *
     *  protocol The protocol represents the protocol type
     *
     *  localPort The localPort represents the local port number for machines
     *                                  on the Lan side.
     *
     *  localAddress The localAddress represents the local IP Address of
     *                                  machines on the Lan side.
     *
     *  name The name of static map.
     *
     */

typedef struct staticMapEntry {
    Boolean                             active;
    Word                                destPort;
    StaticMapProtocol                   protocol;
    Word                                localPort;
#if ( MDF_IP == FYES )
    IpAddress                           localAddress;
#endif /* ( MDF_IP == FYES ) */
    char				name[MAX_PROFILE_NAME_LENGTH + 1];
    Uint16				destPortRange;
    IpAddress				destAddress;
    Uint16				destAddressRange;
    char				binding[MAX_PROFILE_NAME_LENGTH + 1];
    Boolean                             autoLocalIp;

/* dynamic parameters */
    Boolean				islocal;
    int					bid;
}
#if ( USERIF & CLI )
__PACK__
#endif
StaticMapEntry;

    /*
     * NatProfile:
     *
     * A NatProfile contains configuration information for NAT.
     *
     *  natRouting A boolean. When set to TRUE it translates all the lan
     *                                  addresses to dynamicaly assigned
     *                                  internet address.
     *
     *  natProfile The profile to use for NAT Routing.
     *
     *  natLan Which NAT Lan option is to be use.
     *
     *  staticMaps A table of static mappings applied to incoming Wan NAT
     *                                  packets.
     *
     *  DefaultServer The LAN address of the Default Server on the Lan side
     *
     *  FrameRelayAddress The Frame Relay user assigned IP address
     *
     *  StickyIp A Boolen. When set to TRUE enables the sticky IP address
     *                                  feature - the router will try to retain
     *                                  the last IP address it got from the
     *                                  host by negotiating it with the host.
     *
     *  StickyTimeout A number. Represents the number of minutes the router
     *                                  will try to request the sticky IP
     *                                  address counting from the end of the
     *                                  last session.
     */

typedef struct st_natProfile {
#if ( MDF_NAT == FYES )
    char                                Name[ MAX_PROFILE_NAME_LENGTH + 1 ];
    Boolean                             enableNatRouting;
#endif /* ( MDF_NAT == FYES ) */
#if ( MDF_NAT == FYES )
    char                                natProfileName[ MAX_PROFILE_NAME_LENGTH + 1 ];
#endif /* ( MDF_NAT == FYES ) */
#if ( MDF_NAPT_LAN == FYES )
    StaticMapEntry                      staticMaps[ MAX_STATIC_MAP_ENTRIES ];
#endif /* ( MDF_NAPT_LAN == FYES ) */
#if ( MDF_NAPT_LAN == FYES )
    IpAddress                           DefaultServer;
#endif /* ( MDF_NAPT_LAN == FYES ) */
#if ( MDF_FRAME_RELAY == FYES )
    IpAddress                           FrameRelayAddress;
#endif /* ( MDF_FRAME_RELAY == FYES ) */
#if ( MDF_NAPT_LAN == FYES )
    Boolean                             StickyIp;
#endif /* ( MDF_NAPT_LAN == FYES ) */
#if ( MDF_NAPT_LAN == FYES )
    Word                                StickyTimeout;
#endif /* ( MDF_NAPT_LAN == FYES ) */
	/* Add:Ast@20030106 */
	/* a tcp port, normally 1720 */
    Word				H323SignallingPort;
	/* a udp port, normally 1719 */
    Word				H323RasPort;
	/* we can disable a spoofing nat route here */
    Boolean				createSpoofRoute;
    Uint32				naptAgerTimer;
    Uint32				naptTcpIdleTimeout;
    Uint32				naptIcmpIdleTimeout;
    Uint32				naptUdpIdleTimeout;
    Uint32				naptFastUdpIdleTimeout;
    Uint32				naptGreIdleTimeout;
    Uint32				naptIpsecIdleTimeout;
    Uint32				naptHttpIdleTimeout;
    Uint32				naptTcpFinTimeout;
//    Uint32				naptSessionLimit;
//    Uint32				naptUdpSessionLimit;
//    Uint32				naptIcmpSessionLimit;
//    Uint32				naptTcpSessionLimit;
    Uint32				naptTxPktLimit;
    Uint32				naptRxPktLimit;
    Uint32				naptTxOctetsLimit;
    Uint32				naptRxOctetsLimit;
    NatBinding				natBinding[MAX_NAT_IFF_ENTRIES];
    Boolean                             natReRouting;
    IpAddress                           natReRoutingAddresse;
    Boolean				natAllowNoneNaptPkt;
    Boolean				natHostSpanIf;
    Boolean        			natIcmpEchoEnabled;
    Boolean        			natIdpLogEnabled;
# if ( IP_IDP == FYES )
    Boolean        			natDoSLogEnabled;
    Boolean        			natDDoSLogEnabled;
    Boolean        			natArpSpoofEnabled;
    Boolean        			natIpSpoofEnabled;
    Boolean        			natMacSpoofEnabled;
    Boolean        			natMacDoSEnabled;
    Boolean        			natMacDDoSEnabled;
    Boolean        			natBcastDoSEnabled;
# endif /* ( IP_IDP == FYES */

#if (ID_BIND == FYES)
    Boolean				natIdBindEnabled;
#endif
    Uint16				natGportFrom;
    Uint16				natGportTo;
    Boolean        			natSTUN;
    Boolean        			natUdpSpanIf;
    Boolean        			natMulticastForward;
    Byte				natDipFollow;
}
#if ( USERIF & CLI )
__PACK__
#endif
NatProfile;


/*
 *ConnectionLimintProfile:
 *
 * 连接限制配置参数
 *
 *   indexName	系统自定义的index
 *  
 *   enable	
 *  
 *   srcFrom	起始ip地址
 *  
 *   srcEnd	结束ip地址
 *  
 *   natSession	nat会话数
 *  
 *   natUdpSession    nat udp 会话数
 *  
 *   natTcpSession    nat Tcp 会话数
 *  
 *   natIcmpSession   nat Icmp 会话数
 *  
 *   remark	备注
 *  
 *
 */

typedef struct{
    char indexName[MAX_INDEX_NAME_LEN+1];
    Boolean enable;
    Boolean lively;
    IpAddress srcFrom;
    IpAddress srcEnd;
    Uint32 natSession;
    Uint32 natUdpSession;
    Uint32 natTcpSession;
    Uint32 natIcmpSession;
    char remark[MAX_REMARK_LENGTH+1];
}ConnectionLimitProfile;


#endif /* MIBNAT_H */

# endif /* !(OLDNAT) */
