    /*
     * Notice: file generated by MIBMAKE from mibbase1.mdf
     * DO NOT EDIT THIS FILE!!!  Edit mibbase1.mdf
     */
/*
 * $Id: mibbase1.h,v 1.1.1.1 2011/08/17 11:11:56 brwang Exp $
 *
 *      Copyright (c) 1995 UTT Technologies, Inc.
 *      All rights reserved.
 *      Use of copyright notice does not imply publication.
 *
 *
 *                      CONFIDENTIAL INFORMATION
 *                      ------------------------
 *      This Document contains Confidential Information or Trade Secrets,
 *      or both, which are the property of UTT Technologies, Inc.
 *      This document may not be copied, reproduced, reduced to any
 *      electronic medium or machine readable form or otherwise duplicated
 *      and the information herein may not be used, disseminated or
 *      otherwise disclosed, except with the prior written consent of
 *      UTT Technologies, Inc.
 */


#if ! defined( MIBBASE1_H )
# define MIBBASE1_H

    /*
     * This module returns the versions of everything in the world.  It also
     * verifies compatibility with the security PAL and all of the system
     * components at startup, using the information found in daughter.h.
     *
     * The security PAL goes away in MBPLUS based hardware, replaced by a
     * security EEPROM.  EEPROM values and access are defined in secprom.{h,c}.
     * The construct `#if defined MB4 is used' to separate the two types of
     * hardware this code runs on.
     */
extern const char* const		mibProfBase1;

# define BUILD_STR_SIZE 80



    /*
     * ManufacturerType:
     *
     * Those manufacturers that we recognize today are enumerated below. These
     * are the values directly read from the security PAL.
     *
     *  DBA_TEST_MFG
     *
     *  DBA_UTT_MFG
     *
     *  DBA_PICTURETEL_MFG
     *
     *  DBA_NUMBER_OF_MFG
     */
typedef enum ManufacturerType {
    DBA_TEST_MFG,
    DBA_UTT_MFG,
    DBA_PICTURETEL_MFG,
    DBA_NUMBER_OF_MFG
} ManufacturerType;


static __inline__ Bool
validManufacturerType (int x)
{
    switch (x) {
    case DBA_TEST_MFG:
    case DBA_UTT_MFG:
    case DBA_PICTURETEL_MFG:
    case DBA_NUMBER_OF_MFG:
        return TRUE;
    default:
        return FALSE;
    }
}

    /*
     * NetworkIfType:
     *
     * The network interface type is one of the enumerations below. Simple
     * enough. Read from the security security prom as well as from the
     * hardware fab itself.
     *
     *  MB4_BRI_DOMESTIC_BOARD Standard BRI
     *
     *  MB4_PRI_T1_BOARD
     *
     *  MB4_PRI_E1_BOARD
     *
     *  MB4_DPNSS_BOARD
     *
     *  MB4_BRI_DOMESTIC_BOARD Standard BRI
     *
     *  MB4_S56_2_BOARD 2 wire S56
     *
     *  MB4_S56_4_BOARD 4 wire S56
     *
     *  MB4_BRI_DOMESTIC_BOARD Standard BRI
     *
     *  MB4_BRI_DOMESTIC_BOARD Standard BRI
     *
     *  MB4_BRI_DOMESTIC_BOARD Standard BRI
     *
     *  NUMBER_OF_NETWORK_IF_TYPES
     */
typedef enum NetworkIfType {
#if ( PLATFORM & MPORT )
    MB4_BRI_DOMESTIC_BOARD,
#endif /* ( PLATFORM & MPORT ) */
#if ( PLATFORM & MPORT )
    MB4_PRI_T1_BOARD,
#endif /* ( PLATFORM & MPORT ) */
#if ( PLATFORM & MPORT )
    MB4_PRI_E1_BOARD,
#endif /* ( PLATFORM & MPORT ) */
#if ( PLATFORM & MPORT )
    MB4_DPNSS_BOARD,
#endif /* ( PLATFORM & MPORT ) */
#if ( PLATFORM & (P50 | PDSL) )
    MB4_S56_2_BOARD,
#endif /* ( PLATFORM & (P50 | PDSL) ) */
#if ( PLATFORM & (P50 | PDSL) )
    MB4_S56_4_BOARD,
#endif /* ( PLATFORM & (P50 | PDSL) ) */
#if ( PLATFORM == P25 )
    MB4_BRI_DOMESTIC_BOARD,
#endif /* ( PLATFORM == P25 ) */
#if ( PLATFORM & ( M200 ))
    MB4_BRI_DOMESTIC_BOARD,
#endif /* ( PLATFORM & ( M200 )) */
    NUMBER_OF_NETWORK_IF_TYPES
} NetworkIfType;


static __inline__ Bool
validNetworkIfType (int x)
{
    switch (x) {
#if ( PLATFORM & MPORT )
    case MB4_BRI_DOMESTIC_BOARD:
#endif /* ( PLATFORM & MPORT ) */
#if ( PLATFORM & MPORT )
    case MB4_PRI_T1_BOARD:
#endif /* ( PLATFORM & MPORT ) */
#if ( PLATFORM & MPORT )
    case MB4_PRI_E1_BOARD:
#endif /* ( PLATFORM & MPORT ) */
#if ( PLATFORM & MPORT )
    case MB4_DPNSS_BOARD:
#endif /* ( PLATFORM & MPORT ) */
#if ( PLATFORM & (P50 | PDSL) )
    case MB4_BRI_DOMESTIC_BOARD:
#endif /* ( PLATFORM & (P50 | PDSL) ) */
#if ( PLATFORM & (P50 | PDSL) )
    case MB4_S56_2_BOARD:
#endif /* ( PLATFORM & (P50 | PDSL) ) */
#if ( PLATFORM & (P50 | PDSL) )
    case MB4_S56_4_BOARD:
#endif /* ( PLATFORM & (P50 | PDSL) ) */
#if ( PLATFORM == P25 )
    case MB4_BRI_DOMESTIC_BOARD:
#endif /* ( PLATFORM == P25 ) */
#if ( PLATFORM & ( M200 ))
    case MB4_BRI_DOMESTIC_BOARD:
#endif /* ( PLATFORM & ( M200 )) */
    case NUMBER_OF_NETWORK_IF_TYPES:
        return TRUE;
    default:
        return FALSE;
    }
}

    /*
     * HostInterfaceType:
     *
     * We support four flavors of host interface, given in the following
     * enumeration.
     *
     *  HOST_INTERFACE_V35
     *
     *  HOST_INTERFACE_RS449
     *
     *  HOST_INTERFACE_ANY
     *
     *  HOST_INTERFACE_MAX
     */
typedef enum HostInterfaceType {
    HOST_INTERFACE_V35,
    HOST_INTERFACE_RS449,
    HOST_INTERFACE_ANY,
    HOST_INTERFACE_MAX
} HostInterfaceType;


static __inline__ Bool
validHostInterfaceType (int x)
{
    switch (x) {
    case HOST_INTERFACE_V35:
    case HOST_INTERFACE_RS449:
    case HOST_INTERFACE_ANY:
    case HOST_INTERFACE_MAX:
        return TRUE;
    default:
        return FALSE;
    }
}

    /*
     * SystemVersion:
     *
     * The basic system information, which better not change when the system is
     * restarted are in this structure. They are defined in one or more of the
     * following locations: SYSTEM ROM (the one we're running) SECURITY PAL
     * (the one in the daughter board right now) HARDWARE FAB/ASSEMBLY The
     * values are relatively obvious, but are defined below
     *
     *  shelfNumber The shelf number of this unit.
     *
     *  romType The ROM Type compiled into the system code.
     *
     *  romVersion The Software version compiled into the system code.
     *
     *  romRevision The Software revision compiled into the system code.
     *
     *  romLevel The Software level compiled into the system code.
     *
     *  buildString This string should be different for every build. It is used
     *                                  to detect when the build is different
     *                                  from the one that built NVRAM, so that
     *                                  it can be rebuilt. It gets stored in
     *                                  NVRAM when it is built.
     *
     *  motherboardFab The fab level read from the mother board.
     *
     *  motherboardAssembly The assembly level read from the mother board.
     *
     *  manufacturer The manufacturing code read from the security pal.
     *
     *  networkIfType The type of network interface read from the security
     *                                  prom, and verified with the hardware.
     *
     *  numberOfNetInterfaces The number of interfaces read from the security
     *                                  pal.
     *
     *  hostInterfaceType The type of host interface, as determined from the
     *                                  motherboard assembly level.
     *
     *  numberOfHostInterfaces The number of host ports supported, as read from
     *                                  the security pal.
     *
     *  unitType The type of unit.
     *
     *  rs366Enabled Indicaiton as to whether to allow RS-366 dialing, as read
     *                                  from the security pal.
     *
     *  dChannelEnabled Indication as to whether to allow D-Channel signaling,
     *                                  as read from the security pal.
     *
     *  autoDBAEnabled Indication as to whether to allow bandwidth utilization
     *                                  monitoring, as read from the security
     *                                  pal.
     *
     *  bondingEnabled Yes if BONDING is enabled independently of having full
     *                                  N-By enabled (i.e. BONDING but not
     *                                  AIM).
     *
     *  aimEnabled Yes if AIM is enabled independently of BONDING being
     *                                  enabled.
     *
     *  v25bisEnabled Indication as to whether to allow V.25bis dialing on the
     *                                  host interfaces.
     *
     *  x21Enabled Enable X.21.
     *
     *  switchedEnabled True if this unit can make switched calls. When false
     *                                  we limit use to nailed up channels.
     *
     *  mrateEnabled True if this unit can make DWS calls.
     *
     *  pbxEnabled Yes if the unit supports T1/PRI conversion (i.e., has the
     *                                  signaling DSP).
     *
     *  pcbusEnabled Yes if the unit has a one slot PC-BUS for modem, network,
     *                                  whatever, card.
     *
     *  bridgingEnabled Yes if bridging is supported on this unit. Only
     *                                  meaningful with the ETHERNET feature.
     *
     *  pipeHxEnabled Yes if the unit is limited to talking to a single LAN
     *                                  workstation, the feature that defines
     *                                  the Pipeline 50 HX / P25FX.
     *
     *  frameRelayEnabled Yes if frame relay is allowed on this unit. This is
     *                                  ALWAYS true for Pipe 50 family.
     *
     *  ipRoutingEnabled Yes if IP routing is enabled.
     *
     *  ipxRoutingEnabled Yes if IPX routing is enabled.
     *
     *  maxLinkClientEnabled True if this server is licensed for support of the
     *                                  MaxLink (PPP) client.
     *
     *  dataCallEnabled Yes if data call is supported on ISDN lines.
     *
     *  dualSlotT1Enabled On MAX400x, yes if second pair of T1 (DUAL_SLOT_T1)
     *                                  is enabled; on MAX1800, yes if only 4
     *                                  (out of the 8) BRI ports are enabled
     *
     *  r2SignalingEnabled Yes if R2 signaling is enabled.
     *
     *  serialNumber The system serial number, as read from the security pal.
     *
     *  hwRevLevel The H/W revision level as read from the security PROM.
     *
     *  defaultDivisor The default serial port divisor for the unit.
     *
     *  countriesEnabled A bitset of the countries that are enabled to be used
     *                                  in this system. The individual bits
     *                                  within this value are defined above.
     *
     *  domesticEnabled Yes if the unit may operate domestically, FALSE
     *                                  otherwise.
     *
     *  maxSoftwareVersion The maximum software revision allowed on this unit.
     *
     *  modemTSDialout Yes if modem outdial from terminal server is enabled.
     *                                  Also must be Yes for Modem Assist to be
     *                                  supported.
     *
     *  pipePxEnabled Yes if the unit is P25 and has NAT enabled.
     *
     *  firewallsEnabled Yes if secure access option is enabled. Must be yes
     *                                  for IPsec to be enabled.
     *
     *  serialPortT1_CSU_Enabled Yes if this server is licensed for support of
     *                                  the 'Serial Port T1-CSU' option.
     *
     *  pipePotsEnabled Yes if POTS option is enabled.
     *
     *  forceMultibandPlatformSimulation Yes if 'Force Multiband Platform
     *                                  Simulation' option is enabled.
     *
     *  ipsec Yes if IP security option is enabled.
     *
     *  k56SlotCardOnly Yes if only K56 slot card is allowed in the removable
     *                                  slots.
     *
     *  networkManagementEnabled Yes if network management option is enabled.
     *
     *  advancedAgentEnabled Deprecated per EOIs 16227 (MAX) and 16228 (TNT)
     *
     *  phsSupport Yes if PHS support is enabled.
     *
     *  sonOfValetEnabled Yes if Selectools is enabled.
     *
     *  routeProtocolsDisabled Yes if IPX, AppleTalk, Bridging protocols are
     *                                  not allowed.
     *
     *  maxdaxEnabled Enabled if the MAXDAX option (Net-to-Net functionality)
     *                                  is licensed.
     *
     *  tntAdslEnabled Yes if ADSL cards are enabled, and Modem card are
     *                                  disabled.
     *
     *  tntSdslEnabled Yes if SDSL, and ADSL cards are enabled, and Modem card
     *                                  are disabled.
     *
     *  tntIdslEnabled Yes if IDSL, and ADSL cards are enabled, and Modem card
     *                                  are disabled.
     *
     *  voipEnabled Yes if Voice Over IP allowed.
     *
     *  ss7XcomEnabled Enabled if XCOM SS7 Gateway to NAS Messaging Interface
     *                                  is licensed.
     *
     *  ss7AsgEnabled Enabled if UTT Signaling Gateway interface is licensed.
     *
     *  atmpEnabled Enabled if the ATMP tunnel protocol is licensed.
     *
     *  l2tpEnabled Enabled if the L2TP tunnel protocol is licensed.
     *
     *  pptpEnabled Enabled if the PPTP tunnel protocol is licensed.
     *
     *  ipinipEnabled Enabled if IP-in-IP is licensed.
     *
     *  aodiEnabled Enabled if AODI has been licensed.
     *
     *  vRouterEnabled Enabled if Virtual Router is licensed.
     *
     *  maddModemEnabled Enabled if the modems on the MADD card heve been
     *                                  licenced.
     */
typedef struct systemVersion {
    char                                name[MAX_PROFILE_NAME_LENGTH+1];
    Boolean                             active;
#if ( PLATFORM & TNT )
    Uint32                              shelfNumber;
#endif /* ( PLATFORM & TNT ) */
#if ( ! ( PLATFORM & TNT ))
    Word                                romType;
#endif /* ( ! ( PLATFORM & TNT )) */
    Word                                romVersion;
    Word                                romRevision;
#if ( PLATFORM & TNT )
    char                                romLevel[ 4 ];
#endif /* ( PLATFORM & TNT ) */
#if ( ! ( PLATFORM & TNT ))
    char                                buildString[ BUILD_STR_SIZE ];
#endif /* ( ! ( PLATFORM & TNT )) */
#if ( ! ( PLATFORM & TNT ))
    Word                                motherboardFab;
#endif /* ( ! ( PLATFORM & TNT )) */
#if ( ! ( PLATFORM & TNT ))
    Word                                motherboardAssembly;
#endif /* ( ! ( PLATFORM & TNT )) */
    ManufacturerType                    manufacturer;
#if ( ! ( PLATFORM & TNT ))
    NetworkIfType                       networkIfType;
#endif /* ( ! ( PLATFORM & TNT )) */
#if ( ! ( PLATFORM & TNT ))
    Word                                numberOfNetInterfaces;
#endif /* ( ! ( PLATFORM & TNT )) */
#if ( ! ( PLATFORM & TNT ))
    HostInterfaceType                   hostInterfaceType;
#endif /* ( ! ( PLATFORM & TNT )) */
#if ( ! ( PLATFORM & TNT ))
    Word                                numberOfHostInterfaces;
#endif /* ( ! ( PLATFORM & TNT )) */
#if ( ! ( PLATFORM & TNT ))
    Word                                unitType;
#endif /* ( ! ( PLATFORM & TNT )) */
#if ( ! ( PLATFORM & TNT ))
    Boolean                             rs366Enabled;
#endif /* ( ! ( PLATFORM & TNT )) */
    Boolean                             dChannelEnabled;
#if ( ! ( PLATFORM & TNT ))
    Boolean                             autoDBAEnabled;
#endif /* ( ! ( PLATFORM & TNT )) */
#if ( ! ( PLATFORM & TNT ))
    Boolean                             bondingEnabled;
#endif /* ( ! ( PLATFORM & TNT )) */
    Boolean                             aimEnabled;
#if ( ! ( PLATFORM & TNT ))
    Boolean                             v25bisEnabled;
#endif /* ( ! ( PLATFORM & TNT )) */
#if ( ! ( PLATFORM & TNT ))
    Boolean                             x21Enabled;
#endif /* ( ! ( PLATFORM & TNT )) */
    Boolean                             switchedEnabled;
    Boolean                             mrateEnabled;
    Boolean                             pbxEnabled;
#if ( ! ( PLATFORM & TNT ))
    Boolean                             pcbusEnabled;
#endif /* ( ! ( PLATFORM & TNT )) */
#if ( ! ( PLATFORM & TNT ))
    Boolean                             bridgingEnabled;
#endif /* ( ! ( PLATFORM & TNT )) */
#if ( ! ( PLATFORM & TNT ))
    Boolean                             pipeHxEnabled;
#endif /* ( ! ( PLATFORM & TNT )) */
    Boolean                             frameRelayEnabled;
#if ( PLATFORM & P25 )
    Boolean                             ipRoutingEnabled;
#endif /* ( PLATFORM & P25 ) */
#if ( PLATFORM & P25 )
    Boolean                             ipxRoutingEnabled;
#endif /* ( PLATFORM & P25 ) */
    Boolean                             maxLinkClientEnabled;
    Boolean                             dataCallEnabled;
#if ( ! ( PLATFORM & TNT ))
    Boolean                             dualSlotT1Enabled;
#endif /* ( ! ( PLATFORM & TNT )) */
#if ( MDF_R2 == FYES )
    Boolean                             r2SignalingEnabled;
#endif /* ( MDF_R2 == FYES ) */
    unsigned long                       serialNumber;
    char                                hwRevLevel[ 4 ];
#if ( ! ( PLATFORM & TNT ))
    Word                                defaultDivisor;
#endif /* ( ! ( PLATFORM & TNT )) */
    unsigned long                       countriesEnabled;
    Boolean                             domesticEnabled;
#if ( ! ( PLATFORM & TNT ))
    Word                                maxSoftwareVersion;
#endif /* ( ! ( PLATFORM & TNT )) */
#if ( MDF_LMODEM_TSDIALOUT == FYES )
    Boolean                             modemTSDialout;
#endif /* ( MDF_LMODEM_TSDIALOUT == FYES ) */
#if ( ! ( PLATFORM & TNT ))
    Boolean                             pipePxEnabled;
#endif /* ( ! ( PLATFORM & TNT )) */
#if ( MDF_FIREWALLS == FYES )
    Boolean                             firewallsEnabled;
#endif /* ( MDF_FIREWALLS == FYES ) */
#if ( ! ( PLATFORM & TNT ))
    Boolean                             serialPortT1_CSU_Enabled;
#endif /* ( ! ( PLATFORM & TNT )) */
#if ( PLATFORM & (P50 | PDSL) )
    Boolean                             pipePotsEnabled;
#endif /* ( PLATFORM & (P50 | PDSL) ) */
#if ( PLATFORM & MPORT )
    Boolean                             forceMultibandPlatformSimulation;
#endif /* ( PLATFORM & MPORT ) */
#if ( MDF_IPSEC == FYES )
    IpsecType                           ipsec;
#endif /* ( MDF_IPSEC == FYES ) */
#if ( ! ( PLATFORM & TNT ))
    Boolean                             k56SlotCardOnly;
#endif /* ( ! ( PLATFORM & TNT )) */
    Boolean                             networkManagementEnabled;
#if ( 0 )
    Boolean                             advancedAgentEnabled;
#endif /* ( 0 ) */
    Boolean                             phsSupport;
#if ( MDF_SON_OF_VALET == FYES )
    Boolean                             sonOfValetEnabled;
#endif /* ( MDF_SON_OF_VALET == FYES ) */
#if (( PLATFORM & ( MPORT | M800 )) || ( Q_TNT ))
    Boolean                             routeProtocolsDisabled;
#endif /* (( PLATFORM & ( MPORT | M800 )) || ( Q_TNT )) */
#if ( MAXDAX == FYES )
    Boolean                             maxdaxEnabled;
#endif /* ( MAXDAX == FYES ) */
#if ( PLATFORM & TNT )
    Boolean                             tntAdslEnabled;
#endif /* ( PLATFORM & TNT ) */
#if ( PLATFORM & TNT )
    Boolean                             tntSdslEnabled;
#endif /* ( PLATFORM & TNT ) */
#if ( PLATFORM & TNT )
    Boolean                             tntIdslEnabled;
#endif /* ( PLATFORM & TNT ) */
#if ( PLATFORM & MPORT )
    Boolean                             voipEnabled;
#endif /* ( PLATFORM & MPORT ) */
#if ( MDF_SS7GW_NMI == FYES )
    Boolean                             ss7XcomEnabled;
#endif /* ( MDF_SS7GW_NMI == FYES ) */
#if ( MDF_SS7ASG == FYES )
    Boolean                             ss7AsgEnabled;
#endif /* ( MDF_SS7ASG == FYES ) */
#if (( PLATFORM & ( MPORT | M800 )) || ( Q_TNT ))
    Boolean                             atmpEnabled;
#endif /* (( PLATFORM & ( MPORT | M800 )) || ( Q_TNT )) */
#if (( PLATFORM & ( MPORT | M800 )) || ( Q_TNT ))
    Boolean                             l2tpEnabled;
#endif /* (( PLATFORM & ( MPORT | M800 )) || ( Q_TNT )) */
#if (( PLATFORM & ( MPORT | M800 )) || ( Q_TNT ))
    Boolean                             pptpEnabled;
#endif /* (( PLATFORM & ( MPORT | M800 )) || ( Q_TNT )) */
#if ( MDF_IPINIP == FYES )
    Boolean                             ipinipEnabled;
#endif /* ( MDF_IPINIP == FYES ) */
#if (( X25B == FYES ) && ( M_M_FRAMING == FYES ))
    Boolean                             aodiEnabled;
#endif /* (( X25B == FYES ) && ( M_M_FRAMING == FYES )) */
#if ( MDF_VROUTER == FYES )
    Boolean                             vRouterEnabled;
#endif /* ( MDF_VROUTER == FYES ) */
    Boolean                             maddModemEnabled;
}
#if ( USERIF & CLI )
__PACK__
#endif
SystemVersion;

#endif /* MIBBASE1_H */

