    /*
     * Notice: file generated by MIBMAKE from mibfrmrl.mdf
     * DO NOT EDIT THIS FILE!!!  Edit mibfrmrl.mdf
     */
#line 3 "mibfrmrl.mdf"
/*
 * $Id: mibfrmrl.h,v 1.1.1.1 2011/08/17 11:11:56 brwang Exp $
 *
 *      Copyright (c) 1995 UTT Technologies, Inc.
 *      All rights reserved.
 *      Use of copyright notice does not imply publication.
 *
 *
 *                      CONFIDENTIAL INFORMATION
 *                      ------------------------
 *      This Document contains Confidential Information or Trade Secrets,
 *      or both, which are the property of UTT Technologies, Inc.
 *      This document may not be copied, reproduced, reduced to any
 *      electronic medium or machine readable form or otherwise duplicated
 *      and the information herein may not be used, disseminated or
 *      otherwise disclosed, except with the prior written consent of
 *      UTT Technologies, Inc.
 */

#line 25 "mibfrmrl.mdf"

#if ! defined( MIBFRMRL_H )
# define MIBFRMRL_H

#include "mibsct.h"


    /* This file contains the internal representation of the frame relay
     * profile (MIB_PROF_FRAME_RELAY). The name of this profile is stored in the
     * global variable mibProfFrameRelay.
     */
extern const char* const		mibProfFrameRelay;

    /*
     * Function to create the factory instance of a frame-relay profile.
     */
extern ConstPtr
mibFactoryFrameRelayProfile( MibProfileType	mibType,
		             ConstPtr		mibIndex,
		             Int		mibIndexLen );

    /*
     * The field number of the index to this profile.
     */
#define MIB_FRAME_RELAY_INDEX_FIELD	1


    /*
     * FRLinkMgmtType:
     *
     * Describes the link management protocol between the frame relay switch
     * and the Pipeline.
     *
     *  DNONE No link management is used.
     *
     *  T1_617D Link management protocol used is ANSI T1.617.
     *
     *  Q_933A Link management protocol used is CCITT Q.933 Annex A
     */

#if ( MDF_FRAME_RELAY == FYES )

typedef enum FRLinkMgmtType {
#line 88 "mibfrmrl.mdf"
    DNONE,
#line 91 "mibfrmrl.mdf"
    T1_617D,
#line 94 "mibfrmrl.mdf"
    Q_933A
} FRLinkMgmtType;

#endif /* ( MDF_FRAME_RELAY == FYES ) */

#if ( MDF_FRAME_RELAY == FYES )



static __inline__ Bool
validFRLinkMgmtType (int x)
{
    switch (x) {
#line 88 "mibfrmrl.mdf"
    case DNONE:
#line 91 "mibfrmrl.mdf"
    case T1_617D:
#line 94 "mibfrmrl.mdf"
    case Q_933A:
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* ( MDF_FRAME_RELAY == FYES ) */

    /*
     * FRLinkType:
     *
     * Describes the datalink type.
     *
     *  FR_TYPE_DTE Datalink is DTE type
     *
     *  FR_TYPE_DCE Datalink is DCE type
     *
     *  FR_TYPE_NNI Datalink is NNI type
     */

#if ( MDF_FRAME_RELAY == FYES )

typedef enum FRLinkType {
#line 104 "mibfrmrl.mdf"
    FR_TYPE_DTE,
#line 107 "mibfrmrl.mdf"
    FR_TYPE_DCE,
#line 110 "mibfrmrl.mdf"
    FR_TYPE_NNI
} FRLinkType;

#endif /* ( MDF_FRAME_RELAY == FYES ) */

#if ( MDF_FRAME_RELAY == FYES )



static __inline__ Bool
validFRLinkType (int x)
{
    switch (x) {
#line 104 "mibfrmrl.mdf"
    case FR_TYPE_DTE:
#line 107 "mibfrmrl.mdf"
    case FR_TYPE_DCE:
#line 110 "mibfrmrl.mdf"
    case FR_TYPE_NNI:
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* ( MDF_FRAME_RELAY == FYES ) */

    /*
     * FRLinkStatusDlci:
     *
     * List of DLCIs that may be used for link status handshaking.
     *
     *  FR_DLCI_0 dlci 0
     *
     *  FR_DLCI_1023 dlci 1023
     */

#if ( MDF_FRAME_RELAY == FYES )

typedef enum FRLinkStatusDlci {
#line 121 "mibfrmrl.mdf"
    FR_DLCI_0 = 0,
#line 124 "mibfrmrl.mdf"
    FR_DLCI_1023 = 1023
} FRLinkStatusDlci;

#endif /* ( MDF_FRAME_RELAY == FYES ) */

#if ( MDF_FRAME_RELAY == FYES )



static __inline__ Bool
validFRLinkStatusDlci (int x)
{
    switch (x) {
#line 121 "mibfrmrl.mdf"
    case FR_DLCI_0:
#line 124 "mibfrmrl.mdf"
    case FR_DLCI_1023:
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* ( MDF_FRAME_RELAY == FYES ) */

    /*
     * FrDataLinkState:
     *
     * The data link is in one of the states enumerated below.
     *
     *  FR_DATALINK_INACTIVE The data link is not active end-to-end.
     *
     *  FR_DATALINK_CLOSED The data link has been shut down and will be invalid
     *                                  after reporting this state. See below
     *                                  for caues of going to the closed state.
     *
     *  FR_DATALINK_ACTIVE The data link is active and end-to-end data is in
     *                                  process.
     *
     *  FR_DATALINK_NUMBER_OF_STATES The number of states in this enumeration.
     */
typedef enum FrDataLinkState {
#line 134 "mibfrmrl.mdf"
    FR_DATALINK_INACTIVE,
#line 137 "mibfrmrl.mdf"
    FR_DATALINK_CLOSED,
#line 142 "mibfrmrl.mdf"
    FR_DATALINK_ACTIVE,
#line 145 "mibfrmrl.mdf"
    FR_DATALINK_NUMBER_OF_STATES
} FrDataLinkState;


static __inline__ Bool
validFrDataLinkState (int x)
{
    switch (x) {
#line 134 "mibfrmrl.mdf"
    case FR_DATALINK_INACTIVE:
#line 137 "mibfrmrl.mdf"
    case FR_DATALINK_CLOSED:
#line 142 "mibfrmrl.mdf"
    case FR_DATALINK_ACTIVE:
#line 145 "mibfrmrl.mdf"
    case FR_DATALINK_NUMBER_OF_STATES:
        return TRUE;
    default:
        return FALSE;
    }
}

    /*
     * FrDlciState:
     *
     * The states of a DLCI, as it concerns the higher layer, is defined below.
     * The only state that is meaningful to the higher layer, in effect, is
     * FR_DLCI_DATA_TRANSFER. All other states mean the end-to-end data doesn't
     * exist...
     *
     *  FR_DLCI_INACTIVE The DLCI is not active end-to-end. No data tranfer
     *                                  valid.
     *
     *  FR_DLCI_CLOSED The DLCI has been closed either through the data link
     *                                  being shut down, or through the
     *                                  Terminate function.
     *
     *  FR_DLCI_DATA_TRANSFER The DLCI is active and end-to-end data is in
     *                                  process.
     *
     *  FR_DLCI_NUMBER_OF_STATES The number of DLCI states in this enumeration.
     */
typedef enum FrDlciState {
#line 175 "mibfrmrl.mdf"
    FR_DLCI_INACTIVE,
#line 179 "mibfrmrl.mdf"
    FR_DLCI_CLOSED,
#line 183 "mibfrmrl.mdf"
    FR_DLCI_DATA_TRANSFER,
#line 186 "mibfrmrl.mdf"
    FR_DLCI_NUMBER_OF_STATES
} FrDlciState;


static __inline__ Bool
validFrDlciState (int x)
{
    switch (x) {
#line 175 "mibfrmrl.mdf"
    case FR_DLCI_INACTIVE:
#line 179 "mibfrmrl.mdf"
    case FR_DLCI_CLOSED:
#line 183 "mibfrmrl.mdf"
    case FR_DLCI_DATA_TRANSFER:
#line 186 "mibfrmrl.mdf"
    case FR_DLCI_NUMBER_OF_STATES:
        return TRUE;
    default:
        return FALSE;
    }
}

    /*
     * FrameRelayProfile:
     *
     * The frame relay profile information:
     *
     *  frName Name of the frame-relay profile.
     *
     *  active Indicates whether this profile is to be included in the frame
     *                                  relay table.
     *
     *  nailedUpGroup nailed group number.
     *
     *  nailedMode Specifies whether it is a nailed or switched link.
     *
     *  calledNumberType The 'type' of number given in the field 'phone-number'
     *                                  -- national, international, etc..
     *
     *  switchedCallType Type of bearer channel capability to set up for each
     *                                  switched call in the session.
     *
     *  phoneNumber The phonenumber of the named host.
     *
     *  billingNumber A number used for billing purposes.
     *
     *  transitNumber The string for use in the 'transit network ie' for PRI
     *                                  calling when going through a LEC.
     *
     *  linkMgmt Type of link management protocol to use to the frame relay
     *                                  switch.
     *
     *  callByCallID Id for the call-by-call signalling for PRI.
     *
     *  frType Datalink link management type (DTE, DCE, or NNI).
     *
     *  n391Val Interval for requesting status report.
     *
     *  n392Val Error threshold count.
     *
     *  n393Val Monitered events count.
     *
     *  t391Val Timer for link integrity verification.
     *
     *  t392Val Timer for status enquiry.
     *
     *  n201 The Minimum Receive Unit for this link.
     *
     *  dceN392Val Error threshold count.
     *
     *  dceN393Val Monitered events count.
     *
     *  frLinkUp Indicates whether to bring up and keep up the datalink
     *                                  automagically, without requiring a
     *                                  DLCI.
     *
     *  linkStatusDlci Dlci number to use for link management (0 or 1023).
     */

#if ( MDF_FRAME_RELAY == FYES )

typedef struct st_frameRelayProfile {
#line 269 "mibfrmrl.mdf"
//  char                                frName[ MAX_FR_RELAY_NAME_LEN + 1 ];
#line 273 "mibfrmrl.mdf"
    char                                name[MAX_PROFILE_NAME_LENGTH+1];
    Boolean                             active;
#line 278 "mibfrmrl.mdf"
    Word                                nailedUpGroup;
#line 282 "mibfrmrl.mdf"
    NailedMode                          nailedMode;
#line 286 "mibfrmrl.mdf"
    int                                 calledNumberType;
#line 291 "mibfrmrl.mdf"
    SwitchedCallType                    switchedCallType;
#line 296 "mibfrmrl.mdf"
    char                                phoneNumber[ MAX_PHONE_NUMBER_LENGTH + 1 ];
#line 300 "mibfrmrl.mdf"
    char                                billingNumber[ MAX_BILLING_NUMBER_LENGTH + 1 ];
#line 304 "mibfrmrl.mdf"
    char                                transitNumber[ MAX_TRANSIT_NUMBER_LENGTH + 2 ];
#line 309 "mibfrmrl.mdf"
    FRLinkMgmtType                      linkMgmt;
#line 313 "mibfrmrl.mdf"
    Word                                callByCallID;
#line 317 "mibfrmrl.mdf"
    FRLinkType                          frType;
#line 321 "mibfrmrl.mdf"
    Word                                n391Val;
#line 325 "mibfrmrl.mdf"
    Word                                n392Val;
#line 329 "mibfrmrl.mdf"
    Word                                n393Val;
#line 333 "mibfrmrl.mdf"
    Word                                t391Val;
#line 337 "mibfrmrl.mdf"
    Word                                t392Val;
#line 341 "mibfrmrl.mdf"
    Word                                n201;
#line 345 "mibfrmrl.mdf"
    Word                                dceN392Val;
#line 349 "mibfrmrl.mdf"
    Word                                dceN393Val;
#line 353 "mibfrmrl.mdf"
#if ( 0 )
    Boolean                             frLinkUp;
#endif /* ( 0 ) */
#line 360 "mibfrmrl.mdf"
    FRLinkStatusDlci                    linkStatusDlci;
}
#if ( USERIF & CLI )
__PACK__
#endif
FrameRelayProfile;

#endif /* ( MDF_FRAME_RELAY == FYES ) */
#line 367 "mibfrmrl.mdf"

#if ( FRAME_RELAY == FYES )
    /*
     * Function that does the same as mibFactoryFrameRelayProfile,
     * but in a format known to lots of working code.
     */
extern const FrameRelayProfile*
buildFactoryFrameRelayProfile( void );

extern Bool
validFRDLParms( const FrameRelayProfile*  frProfile,
		      char*			message,
		      Int*			messageLen );

#endif /* FRAME_RELAY */

#line 635 "mibfrmrl.mdf"

#endif /* MIBFRMRL_H */

