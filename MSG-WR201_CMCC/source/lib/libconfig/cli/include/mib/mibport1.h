    /*
     * Notice: file generated by MIBMAKE from mibport1.mdf
     * DO NOT EDIT THIS FILE!!!  Edit mibport1.mdf
     */
#line 2 "mibport1.mdf"
/*
 * $Id: mibport1.h,v 1.1.1.1 2011/08/17 11:11:56 brwang Exp $
 *
 *      Copyright (c) 1995 UTT Technologies, Inc.
 *      All rights reserved.
 *      Use of copyright notice does not imply publication.
 *
 *
 *                      CONFIDENTIAL INFORMATION
 *                      ------------------------
 *      This Document contains Confidential Information or Trade Secrets,
 *      or both, which are the property of UTT Technologies, Inc.
 *      This document may not be copied, reproduced, reduced to any
 *      electronic medium or machine readable form or otherwise duplicated
 *      and the information herein may not be used, disseminated or
 *      otherwise disclosed, except with the prior written consent of
 *      UTT Technologies, Inc.
 */

#line 24 "mibport1.mdf"

#if ! defined( MIBPORT1_H )
#define MIBPORT1_H

    /* This file contains the internal representation of the port1 profile
     * (MIB_PROF_PORT). The name of this profile is stored in the global
     * variable mibProfPort1.
     */

extern const char* const		mibProfPort1;

#define MAX_PORT_ANSWER_NUMBER	MAX_PHONE_NUMBER_LENGTH


    /*
     * PortIdleAction:
     *
     * If we want to dial automatically when things are idle (including when we
     * power-on) then the idle action must be set as defined below. That's
     * about all it is to it. Otherwise, we follow the guidelines in the
     * answer/originate/clear enumerations below.
     *
     *  PORT_IDLE_NONE
     *
     *  PORT_IDLE_CALL
     */
typedef enum PortIdleAction {
#line 62 "mibport1.mdf"
    PORT_IDLE_NONE,
#line 63 "mibport1.mdf"
    PORT_IDLE_CALL
} PortIdleAction;


static __inline__ Bool
validPortIdleAction (int x)
{
    switch (x) {
#line 62 "mibport1.mdf"
    case PORT_IDLE_NONE:
#line 63 "mibport1.mdf"
    case PORT_IDLE_CALL:
        return TRUE;
    default:
        return FALSE;
    }
}

    /*
     * PortDial:
     *
     * The call originatation mode is one of the enumerations below:
     *
     *  PORT_DIAL_TERMINAL Dial from the terminal.
     *
     *  PORT_DIAL_DTR Dial on DTR.
     *
     *  PORT_DIAL_RS_366 Dial via standard RS-366.
     *
     *  PORT_DIAL_RS_366X Dial via extended RS-366.
     *
     *  PORT_DIAL_V25BIS Dial via V.25bis.
     *
     *  PORT_DIAL_V25BIS_C Dial via V.25bis with cisco control leads.
     *
     *  PORT_DIAL_X21 Dial via standard X.21.
     *
     *  PORT_DIAL_X21X Dial via extended X.21.
     *
     *  PORT_DIAL_X21_PTEL Dial via standard X.21 and PictureTel I-Lead.
     *
     *  NUMBER_OF_PORT_DIAL
     */
typedef enum PortDial {
#line 86 "mibport1.mdf"
    PORT_DIAL_TERMINAL,
#line 89 "mibport1.mdf"
    PORT_DIAL_DTR,
#line 92 "mibport1.mdf"
    PORT_DIAL_RS_366,
#line 95 "mibport1.mdf"
    PORT_DIAL_RS_366X,
#line 98 "mibport1.mdf"
    PORT_DIAL_V25BIS,
#line 101 "mibport1.mdf"
    PORT_DIAL_V25BIS_C,
#line 104 "mibport1.mdf"
    PORT_DIAL_X21,
#line 107 "mibport1.mdf"
    PORT_DIAL_X21X,
#line 110 "mibport1.mdf"
    PORT_DIAL_X21_PTEL,
#line 113 "mibport1.mdf"
    NUMBER_OF_PORT_DIAL
} PortDial;


static __inline__ Bool
validPortDial (int x)
{
    switch (x) {
#line 86 "mibport1.mdf"
    case PORT_DIAL_TERMINAL:
#line 89 "mibport1.mdf"
    case PORT_DIAL_DTR:
#line 92 "mibport1.mdf"
    case PORT_DIAL_RS_366:
#line 95 "mibport1.mdf"
    case PORT_DIAL_RS_366X:
#line 98 "mibport1.mdf"
    case PORT_DIAL_V25BIS:
#line 101 "mibport1.mdf"
    case PORT_DIAL_V25BIS_C:
#line 104 "mibport1.mdf"
    case PORT_DIAL_X21:
#line 107 "mibport1.mdf"
    case PORT_DIAL_X21X:
#line 110 "mibport1.mdf"
    case PORT_DIAL_X21_PTEL:
#line 113 "mibport1.mdf"
    case NUMBER_OF_PORT_DIAL:
        return TRUE;
    default:
        return FALSE;
    }
}

    /*
     * PortAnswer:
     *
     * The call answer mode is one of the enumerations below:
     *
     *  PORT_ANSWER_AUTO Auto Answer.
     *
     *  PORT_ANSWER_DTR Answer only when DTR is active.
     *
     *  PORT_ANSWER_DTR_RING Answer when DTR goes active after notifying port
     *                                  of incoming call by raising RI.
     *
     *  PORT_ANSWER_V25BIS Answer under control of V.25bis.
     *
     *  PORT_ANSWER_V25BIS_C Answer under control of V.25bis cisco ctl leads.
     *
     *  PORT_ANSWER_TERMINAL Answer when the user says to answer.
     *
     *  PORT_ANSWER_NONE Outgoing port -- reject all incoming calls
     *                                  immediately.
     *
     *  PORT_ANSWER_X21 Answer under control of X.21.
     *
     *  PORT_ANSWER_AUTO_MANUAL Auto answer from a MB perspective, but don't
     *                                  tell the host until we are about to go
     *                                  on-line. Then go ahead and raise RI and
     *                                  let them 'choose' whether to answer. If
     *                                  they don't, then let the call die...
     *
     *  NUMBER_OF_PORT_ANSWER
     */
typedef enum PortAnswer {
#line 135 "mibport1.mdf"
    PORT_ANSWER_AUTO,
#line 138 "mibport1.mdf"
    PORT_ANSWER_DTR,
#line 141 "mibport1.mdf"
    PORT_ANSWER_DTR_RING,
#line 145 "mibport1.mdf"
    PORT_ANSWER_V25BIS,
#line 148 "mibport1.mdf"
    PORT_ANSWER_V25BIS_C,
#line 151 "mibport1.mdf"
    PORT_ANSWER_TERMINAL,
#line 154 "mibport1.mdf"
    PORT_ANSWER_NONE,
#line 157 "mibport1.mdf"
    PORT_ANSWER_X21,
#line 160 "mibport1.mdf"
    PORT_ANSWER_AUTO_MANUAL,
#line 165 "mibport1.mdf"
    NUMBER_OF_PORT_ANSWER
} PortAnswer;


static __inline__ Bool
validPortAnswer (int x)
{
    switch (x) {
#line 135 "mibport1.mdf"
    case PORT_ANSWER_AUTO:
#line 138 "mibport1.mdf"
    case PORT_ANSWER_DTR:
#line 141 "mibport1.mdf"
    case PORT_ANSWER_DTR_RING:
#line 145 "mibport1.mdf"
    case PORT_ANSWER_V25BIS:
#line 148 "mibport1.mdf"
    case PORT_ANSWER_V25BIS_C:
#line 151 "mibport1.mdf"
    case PORT_ANSWER_TERMINAL:
#line 154 "mibport1.mdf"
    case PORT_ANSWER_NONE:
#line 157 "mibport1.mdf"
    case PORT_ANSWER_X21:
#line 160 "mibport1.mdf"
    case PORT_ANSWER_AUTO_MANUAL:
#line 165 "mibport1.mdf"
    case NUMBER_OF_PORT_ANSWER:
        return TRUE;
    default:
        return FALSE;
    }
}

    /*
     * PortClear:
     *
     * The call is cleared through on of the enumerations below:
     *
     *  PORT_CLEAR_DTR_ACTIVE
     *
     *  PORT_CLEAR_DTR_INACTIVE
     *
     *  PORT_CLEAR_RTS_ACTIVE
     *
     *  PORT_CLEAR_RTS_INACTIVE
     *
     *  PORT_CLEAR_TERMINAL
     *
     *  NUMBER_OF_PORT_CLEAR
     */
typedef enum PortClear {
#line 188 "mibport1.mdf"
    PORT_CLEAR_DTR_ACTIVE,
#line 189 "mibport1.mdf"
    PORT_CLEAR_DTR_INACTIVE,
#line 190 "mibport1.mdf"
    PORT_CLEAR_RTS_ACTIVE,
#line 191 "mibport1.mdf"
    PORT_CLEAR_RTS_INACTIVE,
#line 192 "mibport1.mdf"
    PORT_CLEAR_TERMINAL,
#line 194 "mibport1.mdf"
    NUMBER_OF_PORT_CLEAR
} PortClear;


static __inline__ Bool
validPortClear (int x)
{
    switch (x) {
#line 188 "mibport1.mdf"
    case PORT_CLEAR_DTR_ACTIVE:
#line 189 "mibport1.mdf"
    case PORT_CLEAR_DTR_INACTIVE:
#line 190 "mibport1.mdf"
    case PORT_CLEAR_RTS_ACTIVE:
#line 191 "mibport1.mdf"
    case PORT_CLEAR_RTS_INACTIVE:
#line 192 "mibport1.mdf"
    case PORT_CLEAR_TERMINAL:
#line 194 "mibport1.mdf"
    case NUMBER_OF_PORT_CLEAR:
        return TRUE;
    default:
        return FALSE;
    }
}

    /*
     * Port366Escape:
     *
     * This enumeration lists the possible RS-366 escape characters for RS-366
     * dialing extensions.
     *
     *  ESC_366_STAR
     *
     *  ESC_366_POUND
     *
     *  ESC_366_5
     *
     *  ESC_366_6
     *
     *  ESC_366_7
     *
     *  ESC_366_9
     *
     *  ESC_366_0
     *
     *  ESC_366_00
     *
     *  NUMBER_ESC_366
     */
typedef enum Port366Escape {
#line 217 "mibport1.mdf"
    ESC_366_STAR,
#line 218 "mibport1.mdf"
    ESC_366_POUND,
#line 219 "mibport1.mdf"
    ESC_366_5,
#line 220 "mibport1.mdf"
    ESC_366_6,
#line 221 "mibport1.mdf"
    ESC_366_7,
#line 222 "mibport1.mdf"
    ESC_366_9,
#line 223 "mibport1.mdf"
    ESC_366_0,
#line 224 "mibport1.mdf"
    ESC_366_00,
#line 225 "mibport1.mdf"
    NUMBER_ESC_366
} Port366Escape;


static __inline__ Bool
validPort366Escape (int x)
{
    switch (x) {
#line 217 "mibport1.mdf"
    case ESC_366_STAR:
#line 218 "mibport1.mdf"
    case ESC_366_POUND:
#line 219 "mibport1.mdf"
    case ESC_366_5:
#line 220 "mibport1.mdf"
    case ESC_366_6:
#line 221 "mibport1.mdf"
    case ESC_366_7:
#line 222 "mibport1.mdf"
    case ESC_366_9:
#line 223 "mibport1.mdf"
    case ESC_366_0:
#line 224 "mibport1.mdf"
    case ESC_366_00:
#line 225 "mibport1.mdf"
    case NUMBER_ESC_366:
        return TRUE;
    default:
        return FALSE;
    }
}

    /*
     * PortEarlyDCD:
     *
     * The possibilities for the earlyDCD is to either set it on outbound,
     * inbound, or both. Apparently, the BT dialer needs both and the BT codec
     * needs incoming only.
     *
     *  EARLY_DCD_NONE
     *
     *  EARLY_DCD_ANSWER
     *
     *  EARLY_DCD_ORIGINATE
     *
     *  EARLY_DCD_BOTH
     */
typedef enum PortEarlyDCD {
#line 250 "mibport1.mdf"
    EARLY_DCD_NONE,
#line 251 "mibport1.mdf"
    EARLY_DCD_ANSWER,
#line 252 "mibport1.mdf"
    EARLY_DCD_ORIGINATE,
#line 253 "mibport1.mdf"
    EARLY_DCD_BOTH
} PortEarlyDCD;


static __inline__ Bool
validPortEarlyDCD (int x)
{
    switch (x) {
#line 250 "mibport1.mdf"
    case EARLY_DCD_NONE:
#line 251 "mibport1.mdf"
    case EARLY_DCD_ANSWER:
#line 252 "mibport1.mdf"
    case EARLY_DCD_ORIGINATE:
#line 253 "mibport1.mdf"
    case EARLY_DCD_BOTH:
        return TRUE;
    default:
        return FALSE;
    }
}

    /*
     * PortProfile:
     *
     *
     *  name Ports can be named, e.g. CODEC, Router, etc. The name is provided
     *                                  by the user. It is a standard null
     *                                  terminated ASCII string.
     *
     *  lastModificationTime
     *
     *  portAnswerNumber1 The way in which calls are answered.
     *
     *  portAnswerNumber2 The way in which calls are answered.
     *
     *  portAnswerNumber3 The way in which calls are answered.
     *
     *  portAnswerNumber4 The way in which calls are answered.
     *
     *  portIdleAction What to do when a port goes idle.
     *
     *  portDial The way in which calls are originated.
     *
     *  portAnswer
     *
     *  portClear The way in which calls are cleared, as given above.
     *
     *  portMinPriBW Minimum priority bandwidth allocated to this port. Part of
     *                                  IDBM.
     *
     *  portTerminalTiming Terminal timing enabled for this port?
     *
     *  port366Escape RS-366 dialing escape character.
     *
     *  earlyDCD If and when to perform early DCD on the host port.
     *
     *  portDS0MinReset For billing-cap features related to this port, the
     *                                  duration for the billing cap reset or
     *                                  disabled if apprpriate.
     *
     *  maxPortDS0Mins The maximum number of minutes that can be billed to this
     *                                  port in the duration set above. If the
     *                                  number exceeds the value set, all
     *                                  switched-calls will be cleared by the
     *                                  system.
     *
     *  maxCallDurationTimer The maximum length of time for a call to be active
     *                                  on this port. If a call is up longer
     *                                  than this time, the call is cleared
     *                                  automatically. This is all part of the
     *                                  no-surprises phone bill feature set.
     *
     *  dialPlan
     *
     *  trunkGroupsNA
     *
     *  portPassword Port password used to authenticate DBA call's password.
     *                                  Authentication is automatic if port
     *                                  password is not defined.
     */
typedef struct portProfile {
#line 274 "mibport1.mdf"
    Byte                                name[ MAX_NAME_LEN + 1 ];
#line 279 "mibport1.mdf"
    unsigned long                       lastModificationTime;
#line 282 "mibport1.mdf"
    char                                portAnswerNumber1[ MAX_PORT_ANSWER_NUMBER + 1 ];
#line 286 "mibport1.mdf"
    char                                portAnswerNumber2[ MAX_PORT_ANSWER_NUMBER + 1 ];
#line 290 "mibport1.mdf"
    char                                portAnswerNumber3[ MAX_PORT_ANSWER_NUMBER + 1 ];
#line 294 "mibport1.mdf"
    char                                portAnswerNumber4[ MAX_PORT_ANSWER_NUMBER + 1 ];
#line 298 "mibport1.mdf"
    PortIdleAction                      portIdleAction;
#line 302 "mibport1.mdf"
    PortDial                            portDial;
#line 306 "mibport1.mdf"
    PortAnswer                          portAnswer;
#line 309 "mibport1.mdf"
    PortClear                           portClear;
#line 313 "mibport1.mdf"
#if defined NDEF
    Word                                portMinPriBW;
#endif /* defined NDEF */
#line 318 "mibport1.mdf"
    Boolean                             portTerminalTiming;
#line 322 "mibport1.mdf"
    Port366Escape                       port366Escape;
#line 326 "mibport1.mdf"
    PortEarlyDCD                        earlyDCD;
#line 330 "mibport1.mdf"
    DS0MinReset                         portDS0MinReset;
#line 335 "mibport1.mdf"
    DS0Minutes                          maxPortDS0Mins;
#line 341 "mibport1.mdf"
    DS0Minutes                          maxCallDurationTimer;
#line 347 "mibport1.mdf"
#if ( PLATFORM & MPORT )
    int                                 dialPlan;
#endif /* ( PLATFORM & MPORT ) */
#line 351 "mibport1.mdf"
#if ( PLATFORM & MPORT )
    Boolean                             trunkGroupsNA;
#endif /* ( PLATFORM & MPORT ) */
#line 355 "mibport1.mdf"
#if ( PLATFORM & MPORT )
    char                                portPassword[ MAX_PORTPW_LEN + 1 ];
#endif /* ( PLATFORM & MPORT ) */
}
#if ( USERIF & CLI )
__PACK__
#endif
PortProfile;
#line 384 "mibport1.mdf"

#endif /* MIBPORT1_H */

