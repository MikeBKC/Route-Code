    /*
     * Notice: file generated by MIBMAKE from mibglob.mdf
     * DO NOT EDIT THIS FILE!!!  Edit mibglob.mdf
     */
/*
 *	$Id: mibglob.h,v 1.1.1.1 2011/08/17 11:11:56 brwang Exp $
 *
 *      Copyright (c) 1995 UTT Technologies, Inc.
 *      All rights reserved.
 *      Use of copyright notice does not imply publication.
 *
 *
 *                      CONFIDENTIAL INFORMATION
 *                      ------------------------
 *      This Document contains Confidential Information or Trade Secrets,
 *      or both, which are the property of UTT Technologies, Inc.
 *      This document may not be copied, reproduced, reduced to any
 *      electronic medium or machine readable form or otherwise duplicated
 *      and the information herein may not be used, disseminated or
 *      otherwise disclosed, except with the prior written consent of
 *      UTT Technologies, Inc.
 */


#if ! defined( MIBGLOB_H )
# define MIBGLOB_H

# include "mibgen.h"

    /* This file contains the internal representation of profiles and enums
     *  used by others profiles.
     */

extern const char* const		mibProfGlob;

typedef LongWord DS0Minutes;


extern const MibFieldComplexParams	slotNumberParams;
extern const MibFieldComplexParams	relativePortNumberParams;
extern const MibFieldComplexParams	rectangularPortNumberParams;
extern const MibFieldComplexParams	routeIdParams;
extern const MibFieldEnumParams		switchedCallTypeParams;
extern const MibFieldEnumParams		ds0ChannelUsageParams;
extern const MibFieldEnumParams		networkSwitchTypeParams;
extern const MibFieldEnumParams		controlPortBitRateParams;
extern const MibFieldEnumParams		configurationSourceParams;
extern const MibFieldEnumParams		loadTypeParams;
extern const MibFieldEnumParams		codeSubTypeParams;
extern const MibFieldEnumParams		flashDeviceParams;
extern const MibFieldEnumParams		thirdPromptSequenceParams;

# if (( NETIF & DPNSS ) || ( MDF_DPNSS_SIGNALING == FYES ))
extern const MibFieldEnumParams		dpnssBooleanParams;
# endif /* (( NETIF & DPNSS ) || ( MDF_DPNSS_SIGNALING == FYES )) */

# if NETIF & ( DPNSS | T1 | E1 )
extern const MibFieldEnumParams		t1ClockSourceParams;
# endif /* ( DPNSS | T1 | E1  ) */

extern const MibFieldEnumParams		ds0MinResetParams;

# if ( MDF_ETHERNET == FYES )
extern const MibFieldEnumParams		routingModeParams;
extern const MibFieldEnumParams		nailedModeParams;
# endif /* ( MDF_ETHERNET == FYES ) */

# define NAILED_GROUP_DEFAULT            1
extern const MibFieldNumberParams	nailedGroupParams;

extern const MibFieldEnumParams		menuTypeParams;
extern const MibFieldEnumParams		subAddressModeParams;

extern const MibFieldEnumParams		historyWeighTypeParams;
extern const MibFieldComplexParams	timePeriodParametersParams;

extern const MibFieldEnumParams		slotCardTypeParams;

# if ( NETIF & ( T1  ))
extern const MibFieldEnumParams		idleModeParams;
extern const MibFieldEnumParams		dataSenseParams;
# endif /* ( NETIF & T1  ) */

# if ( PLATFORM == TNT ) && ( NETIF & ( T1 | E1 ) )
extern const MibFieldEnumParams		clockPriorityParams;
# endif


    /*
     * A maximum number of filters per filter profile are defined,
     * both to bound the time spent applying filters and to simplify
     * filter entry given our user interface.  The number selected is
     * arbitrary and likely to changes given real world requirements.
     */

//We'll eat up all the memory when this value is too large.
//For bv flatform, it is not endurable. Ast@20030403

#if defined ( LIMITED_MEM_SIZE )
#define MAX_FILTER_ENTRIES      100
#else
#if ( VPN128 == FYES )  && (( HOST_512 == FYES ) || ( HOST_2K == FYES ))
#define MAX_FILTER_ENTRIES      300
#elif ( VPN256 == FYES ) && ( HOST_2K == FYES )
#define MAX_FILTER_ENTRIES      1024
#elif ( HOST_2K == FYES )

#if (NE4000 == FYES)
#define MAX_FILTER_ENTRIES      300
#else
#define MAX_FILTER_ENTRIES      200
#endif

# else 
#define MAX_FILTER_ENTRIES      100
# endif
#endif

    /*
     *	There is an entry for the special port of PORT_NUMBER_ANY.
     */
# if ( VPN128 == FYES )
# define MAX_SPECIAL_PORTS	80
#elif ( VPN256 == FYES )
//# define MAX_SPECIAL_PORTS	128
# define MAX_SPECIAL_PORTS	256

/*
 * added by llliu@080620 for PPPoE-Server
 */
#elif ( PPPOE256 == FYES )

#if (NE4000 == FYES)
# define MAX_SPECIAL_PORTS	405
#else
# define MAX_SPECIAL_PORTS	256
#endif

#elif ( PPPOE128 == FYES )
# define MAX_SPECIAL_PORTS	128

#elif ( PPPOE64 == FYES )
# define MAX_SPECIAL_PORTS	64


# else
# define MAX_SPECIAL_PORTS	1
# endif


    /*
     *	These are enum index OFFSETS used in rate tables in mibinses.mdf.
     */
# define MIB_SETENTRY   		2   /* as opposed to FALSE/TRUE */


    /*
     * The basic parameters surrounding the characteristics of a slot are
     * defined below.  They are fixed based on the hardware characteristcs
     * of the physical unit.  This is the maximum number of slot -- in some
     * cases the actual number will be less.
     */
# if PLATFORM & ( P50 | PDSL )

	/* network slot plus ether slots is total slot number */
#  define NUMBER_OF_SLOTS	(NUM_OF_ETHER_SLOTS + 1)

# elif ( PLATFORM & ( MPORT ))

#  if ( PLATFORM & M4000 )
#   define NUMBER_OF_SLOTS	11
#  elif ( PLATFORM & M6000 )
#   define NUMBER_OF_SLOTS	13
#  elif ( PLATFORM & ( M1800 | M2000 ) )
#   define NUMBER_OF_SLOTS	5
#  elif ( PLATFORM & P220 )
#   define NUMBER_OF_SLOTS	2
#  endif

# elif ( PLATFORM == TNT )

#  if ( TNT_CARD & SHELF_CARD )
#   if ( Q_TKO )
#    define NUMBER_OF_SLOTS      40
#   else
#    define NUMBER_OF_SLOTS      16
#   endif /* Q_TKO */
#  else
#   define NUMBER_OF_SLOTS      1
#  endif

# elif ( PLATFORM == P25 )

#  define NUMBER_OF_SLOTS	4

# elif ( PLATFORM == P15 )

#  define NUMBER_OF_SLOTS	3

# elif ( PLATFORM & ( M200 ))

#  define NUMBER_OF_SLOTS	9

# else
#  error Unknown PLATFORM
# endif

    /*
     *	MAX_SERIAL_PORTS:	The maximum number of serial ports, e.g.
     *				V.35, RS-449, etc, ports supported by this
     *				unit. This varies from platform to platform.
     *
     *				*Legacy code*  on the MAX family this also
     *				includes BRI cards which have 8 ports per
     *				slot.
     *
     *	MAX_ETHER_PORTS:	The maximum number of ethernet sessions
     *				supported by this device. This number varies
     *				by both platform and network interface.
     *
     *	MAX_LMODEM_PORTS:	The maximum number of lan modem sessions
     *				supported by this device.  Varies by
     *				platform and network interfacd within
     *				platform.
     *
     *	MAX_POTS_PORTS:		The maximum number of Plain Old Telephone
     *				Service (POTS) sessions supported by this
     * 				device.
     *
     *	MAX_FR_PORTS:		The maximum number of Frame Relay ports.
     *				Each physical frame relay connection uses
     *				up a port in addition to a port per DLCI.
     *				The DLCI ports do not use additional HDLC
     *				controllers so are not counted as part of
     *				MAX_ETHER_PORTS.
     *
     * MAX_X25_PORTS:		The maximum number of X.25 ports.
     *				Each physical X.25 connection uses
     *				up a port in addition to a port per LCN.
     *				The LCN ports do not use additional HDLC
     *				controllers so are not counted as part of
     *				MAX_ETHER_PORTS.
     *
     *  MAX_SWAN_PORTS:		The maximum number of serial wan ports.
     *
     *  MAX_IMODEM_PORTS:	The maximum number of ISDN modem ports.
     *				Each IMODEM connection (B-channel) uses
     *				a port.
     */
# if ( PLATFORM == TNT )
#  include "mibitems.h"

#  if ( TNT_CARD & SHELF_CARD )
	/* Note: for the shelf, these numbers are _not_ used to calculate
	 * the value of PORT_ARRAY_SIZE.
	 */
#   define MAX_SERIAL_PORTS     38
#   define MAX_ETHER_PORTS      120
#   define MAX_SWAN_PORTS       0
#   define MAX_IMODEM_PORTS     0
#   define MAX_LMODEM_PORTS     0
#   define MAX_POTS_PORTS       0
#   define MAX_FR_PORTS         31
#   define MAX_X25_PORTS        31
#  elif ( TNT_CARD & DIGI_MODEM_TYPE_CARD )
#   define MAX_SERIAL_PORTS     0
#   define MAX_ETHER_PORTS      NUM_PHYSICAL_DEVICES
#   define MAX_SWAN_PORTS       0
#   define MAX_IMODEM_PORTS     0
#   define MAX_LMODEM_PORTS     MAX_ETHER_PORTS
#   define MAX_POTS_PORTS       0
#   define MAX_FR_PORTS         0
#   define MAX_X25_PORTS        0
#  elif ( TNT_CARD & ( ANALOG_MODEM_CARD | ANALOG_MODEM2_CARD ) )
#   define MAX_SERIAL_PORTS     0
#   define MAX_ETHER_PORTS      NUM_PHYSICAL_DEVICES
#   define MAX_SWAN_PORTS       0
#   define MAX_IMODEM_PORTS     0
#   define MAX_LMODEM_PORTS     MAX_ETHER_PORTS
#   define MAX_POTS_PORTS       0
#   define MAX_FR_PORTS         0
#   define MAX_X25_PORTS        0
#  elif ( TNT_CARD & ( T1_CARD | E1_CARD | T3_CARD ) )
#   define MAX_SERIAL_PORTS     1
#   define MAX_ETHER_PORTS      0
#   define MAX_SWAN_PORTS       0
#   define MAX_IMODEM_PORTS     0
#   define MAX_LMODEM_PORTS     0
#   define MAX_POTS_PORTS       0
#   define MAX_FR_PORTS         0
#   define MAX_X25_PORTS        0
#  elif ( TNT_CARD & ( UNCHAN_T1_CARD | UNCHAN_E1_CARD ) )
#   define MAX_SERIAL_PORTS     0
#   define MAX_ETHER_PORTS      NUM_PHYSICAL_DEVICES
#   define MAX_SWAN_PORTS       0
#   define MAX_IMODEM_PORTS     0
#   define MAX_LMODEM_PORTS     0
#   define MAX_POTS_PORTS       0
#   if (Q_TNT_UNCHAN_T1_CARD)
#    define MAX_FR_PORTS      (NUM_PHYSICAL_DEVICES + UNCHAN_T1_VIRTUAL_DEVICES)
#   else
#    define MAX_FR_PORTS      (NUM_PHYSICAL_DEVICES + UNCHAN_E1_VIRTUAL_DEVICES)
#   endif
#   define MAX_X25_PORTS        0
#  elif ( Q_TNT_HDLC_TYPE_CARD )
#   define MAX_SERIAL_PORTS     0
#   define MAX_ETHER_PORTS      (NUM_CHANS_PER_PHYSICAL * NUM_PHYSICAL_DEVICES)
#   define MAX_SWAN_PORTS       0
#   define MAX_IMODEM_PORTS     0
#   define MAX_LMODEM_PORTS     0
#   define MAX_POTS_PORTS       0
#   define MAX_FR_PORTS         ((NUM_CHANS_PER_PHYSICAL * NUM_PHYSICAL_DEVICES) \
				+ HDLC_VIRTUAL_DEVICES)
#   define MAX_X25_PORTS        0
#  elif ( Q_TNT_ETHER_CARD || Q_TNT_ETHER2_CARD )
#   define MAX_SERIAL_PORTS     0
#   define MAX_ETHER_PORTS      4
#   define MAX_SWAN_PORTS       0
#   define MAX_IMODEM_PORTS     0
#   define MAX_LMODEM_PORTS     0
#   define MAX_POTS_PORTS       0
#   define MAX_FR_PORTS         0
#   define MAX_X25_PORTS        0
#  elif ( Q_TNT_SWAN_CARD )
#   define MAX_SERIAL_PORTS     0
#   define MAX_ETHER_PORTS      NUM_PHYSICAL_DEVICES
#   define MAX_SWAN_PORTS       NUM_PHYSICAL_DEVICES
#   define MAX_IMODEM_PORTS     0
#   define MAX_LMODEM_PORTS     0
#   define MAX_POTS_PORTS       0
#   define MAX_FR_PORTS         (NUM_PHYSICAL_DEVICES + SWAN_VIRTUAL_DEVICES)
#   define MAX_X25_PORTS        0
#  elif ( Q_TNT_SDSL_CARD )
#   define MAX_SERIAL_PORTS     0
#   define MAX_ETHER_PORTS      NUM_PHYSICAL_DEVICES
#   define MAX_SWAN_PORTS       0
#   define MAX_IMODEM_PORTS     0
#   define MAX_LMODEM_PORTS     0
#   define MAX_POTS_PORTS       0
#   define MAX_FR_PORTS         (NUM_PHYSICAL_DEVICES + SDSL_VIRTUAL_DEVICES)
#   define MAX_X25_PORTS        0
#   define MAX_SDSL_PORTS       NUM_PHYSICAL_DEVICES
#  elif ( Q_TNT_ADSL_CAP_CARD )
#   define MAX_SERIAL_PORTS     0
#   define MAX_ETHER_PORTS      NUM_PHYSICAL_DEVICES
#   define MAX_SWAN_PORTS       0
#   define MAX_IMODEM_PORTS     0
#   define MAX_LMODEM_PORTS     0
#   define MAX_POTS_PORTS       0
#   define MAX_FR_PORTS         (NUM_PHYSICAL_DEVICES + CADSL_VIRTUAL_DEVICES)
#   define MAX_X25_PORTS        0
#   define MAX_SDSL_PORTS       NUM_PHYSICAL_DEVICES
#  elif ( Q_TNT_ADSL_DMT_CARD )
#   define MAX_SERIAL_PORTS     0
#   define MAX_ETHER_PORTS      NUM_PHYSICAL_DEVICES
#   define MAX_SWAN_PORTS       0
#   define MAX_IMODEM_PORTS     0
#   define MAX_LMODEM_PORTS     0
#   define MAX_POTS_PORTS       0
#   define MAX_FR_PORTS         (NUM_PHYSICAL_DEVICES + DADSL_VIRTUAL_DEVICES)
#   define MAX_X25_PORTS        0
#   define MAX_SDSL_PORTS       NUM_PHYSICAL_DEVICES
#  elif ( TNT_CARD == UDS3_CARD )
#   define MAX_SERIAL_PORTS     0
#   define MAX_ETHER_PORTS      NUM_PHYSICAL_DEVICES
#   define MAX_SWAN_PORTS       0
#   define MAX_IMODEM_PORTS     0
#   define MAX_LMODEM_PORTS     0
#   define MAX_POTS_PORTS       0
#   define MAX_FR_PORTS         (NUM_PHYSICAL_DEVICES + UDS3_VIRTUAL_DEVICES)
#   define MAX_X25_PORTS        0
#   define MAX_SDSL_PORTS       NUM_PHYSICAL_DEVICES
#  elif ( TNT_CARD == HSSI_CARD )
#   define MAX_SERIAL_PORTS     0
#   define MAX_ETHER_PORTS      0
#   define MAX_SWAN_PORTS       0
#   define MAX_IMODEM_PORTS     0
#   define MAX_LMODEM_PORTS     0
#   define MAX_POTS_PORTS       0
#   define MAX_FR_PORTS         0
#   define MAX_X25_PORTS        0
#  elif ( Q_TNT_IDSL_CARD )
#   define MAX_SERIAL_PORTS     0
#   define MAX_ETHER_PORTS      (NUM_CHANS_PER_PHYSICAL * NUM_PHYSICAL_DEVICES)
#   define MAX_SWAN_PORTS       0
#   define MAX_IMODEM_PORTS     0
#   define MAX_LMODEM_PORTS     0
#   define MAX_POTS_PORTS       0
#   define MAX_FR_PORTS         (NUM_PHYSICAL_DEVICES + IDSL_VIRTUAL_DEVICES)
#   define MAX_X25_PORTS        0
#  elif ( Q_STNGR_DMT_ADSL_CARD )
#   define MAX_SERIAL_PORTS     0
#   define MAX_ETHER_PORTS      NUM_PHYSICAL_DEVICES
#   define MAX_SWAN_PORTS       0
#   define MAX_IMODEM_PORTS     0
#   define MAX_LMODEM_PORTS     0
#   define MAX_POTS_PORTS       0
#   define MAX_FR_PORTS         (NUM_PHYSICAL_DEVICES + DADSL_VIRTUAL_DEVICES)
#   define MAX_X25_PORTS        0
#   define MAX_SDSL_PORTS       NUM_PHYSICAL_DEVICES
#  elif ( TNT_CARD == DS3_ATM_CARD )
#   define MAX_SERIAL_PORTS     0
#   define MAX_ETHER_PORTS      (NUM_PHYSICAL_DEVICES + DS3_ATM_VIRTUAL_DEVICES)
#   define MAX_SWAN_PORTS       0
#   define MAX_IMODEM_PORTS     0
#   define MAX_LMODEM_PORTS     0
#   define MAX_POTS_PORTS       0
#   define MAX_FR_PORTS         0
#   define MAX_X25_PORTS        0
#   define MAX_SDSL_PORTS       0
#  elif ( Q_TNT_SDSL70_CARD )
#   define MAX_SERIAL_PORTS     0
#   define MAX_ETHER_PORTS      (NUM_CHANS_PER_PHYSICAL * NUM_PHYSICAL_DEVICES)
#   define MAX_SWAN_PORTS       0
#   define MAX_IMODEM_PORTS     0
#   define MAX_LMODEM_PORTS     0
#   define MAX_POTS_PORTS       0
#   define MAX_FR_PORTS         (NUM_PHYSICAL_DEVICES + SDSL70_VIRTUAL_DEVICES)
#   define MAX_X25_PORTS        0
#   define MAX_SDSL_PORTS       NUM_PHYSICAL_DEVICES
#  else
#   error Unknown TNT_CARD
#  endif

# elif ( PLATFORM & MPORT )
#  if ( PLATFORM & P220 )
#   define MAX_SERIAL_PORTS	1
#   define MAX_ETHER_PORTS	4
#   define MAX_SWAN_PORTS	1
#   define MAX_LMODEM_PORTS	0
#   define MAX_POTS_PORTS	0
#   define MAX_IMODEM_PORTS     0
#   define MAX_FR_PORTS		2 /* CAG_DEBUG really? */
#   define MAX_X25_PORTS		1
#  else	/* P220 */
#   define MAX_SERIAL_PORTS	50
#   if ( ( PLATFORM & M4000 ) && ( T_ONLINE != FYES ) )
#    define MAX_ETHER_PORTS	100
#   else
#    define MAX_ETHER_PORTS	120
#   endif
#   define MAX_SWAN_PORTS	1
    /*
     * Even though the MAX supports digital modems, we need not add any
     * more slots in the port array as adding a digital modem takes away
     * from either a serial slot or an HDLC slot which reduces one of
     * the other numbers.
     */
#   define MAX_LMODEM_PORTS	0
#   define MAX_POTS_PORTS	0
#   define MAX_IMODEM_PORTS     0
#   define MAX_FR_PORTS		31
#   define MAX_X25_PORTS	31
#  endif	/* P220 */

# elif ( PLATFORM & (P50 | PDSL) )
#  define MAX_SERIAL_PORTS	0
# if ( VPN128 == FYES )
#  define MAX_ETHER_PORTS	NUM_OF_ETHER_SLOTS	
#elif ( VPN256 == FYES )
#  define MAX_ETHER_PORTS	NUM_OF_ETHER_SLOTS
# else
#  define MAX_ETHER_PORTS	NUM_OF_ETHER_SLOTS
# endif
#  define MAX_LMODEM_PORTS	0
#  if (MDF_POTS == FYES)
#   define MAX_POTS_PORTS	2
#  else
#   define MAX_POTS_PORTS	0
#  endif
#  define MAX_FR_PORTS		4
#  define MAX_X25_PORTS		4
#  define MAX_SWAN_PORTS	1
#  define MAX_IMODEM_PORTS      0

# elif ( PLATFORM == P25 )
#  define MAX_SERIAL_PORTS	0
#  define MAX_ETHER_PORTS	2
#  define MAX_LMODEM_PORTS	0
#  define MAX_POTS_PORTS	2
#  define MAX_FR_PORTS		0
#  define MAX_X25_PORTS		0
#  define MAX_SWAN_PORTS	0
#  define MAX_IMODEM_PORTS      0

# elif ( PLATFORM == P15 )
#  define MAX_SERIAL_PORTS	0
#  define MAX_ETHER_PORTS	0
#  define MAX_LMODEM_PORTS	0
#  define MAX_POTS_PORTS	2
#  define MAX_FR_PORTS		0
#  define MAX_X25_PORTS		0
#  define MAX_SWAN_PORTS	0
#  define MAX_IMODEM_PORTS      2

# elif ( PLATFORM & ( M200 ))
#  define MAX_SERIAL_PORTS	0
#  define MAX_ETHER_PORTS	9
#  define MAX_LMODEM_PORTS	0
#  define MAX_POTS_PORTS	0
#  define MAX_FR_PORTS		0
#  define MAX_X25_PORTS		0
#  define MAX_SWAN_PORTS	0
#  define MAX_IMODEM_PORTS      0

# else
#  errror Unknown PLATFORM
# endif


# if ( ( PLATFORM == TNT ) && ( TNT_CARD & SHELF_CARD ) )
	/*
	 * For the shelf, this number of ports applies to the global
	 * system resources.  The totality of these resources is
	 * the maximum number of physical ports, plus logical ports (those
	 * that do not consume a physical resource).  The maximum number
	 * of logical ports is scaled to the expected practical capacity
	 * of the system, but is essentially a guess.
	 */
	/*  maximum number of used DS0s on TNT backplane (covers the E1 case). */
#  define MAX_SYSTEM_DS0			( 28 * 30 )
	/* A guess of number of logical ports (DLCIs, etc.) */
#  define MAX_LOGICAL_PORTS_PER_SHELF	128
	/* RBC -- Note: this value must be bumped for multi-shelf case. */
#  define MAX_TNT_SHELVES			1

#  define PORT_ARRAY_SIZE  (  MAX_SPECIAL_PORTS \
			  + MAX_SYSTEM_DS0 \
			  + ( MAX_LOGICAL_PORTS_PER_SHELF * MAX_TNT_SHELVES ) )

# elif Q_TNT_XDSL_CARD
#  define PORT_ARRAY_SIZE		(   MAX_SPECIAL_PORTS \
				  + NUMBER_OF_SLOTS \
				  + MAX_SERIAL_PORTS \
				  + MAX_ETHER_PORTS \
				  + MAX_LMODEM_PORTS \
				  + MAX_POTS_PORTS \
				  + MAX_SWAN_PORTS \
				  + MAX_FR_PORTS \
				  + MAX_X25_PORTS \
				  + MAX_SDSL_PORTS\
				  + MAX_IMODEM_PORTS )
# elif Q_TNT_DS3_ATM_CARD
#  define PORT_ARRAY_SIZE		(   MAX_SPECIAL_PORTS \
				  + NUMBER_OF_SLOTS \
				  + MAX_SERIAL_PORTS \
				  + MAX_ETHER_PORTS \
				  + MAX_LMODEM_PORTS \
				  + MAX_POTS_PORTS \
				  + MAX_SWAN_PORTS \
				  + MAX_X25_PORTS \
				  + MAX_SDSL_PORTS\
				  + MAX_IMODEM_PORTS )
# else
#  define PORT_ARRAY_SIZE		(   MAX_SPECIAL_PORTS \
				  + NUMBER_OF_SLOTS \
				  + MAX_SERIAL_PORTS \
				  + MAX_ETHER_PORTS \
				  + MAX_LMODEM_PORTS \
				  + MAX_POTS_PORTS \
				  + MAX_SWAN_PORTS \
				  + MAX_FR_PORTS \
				  + MAX_X25_PORTS \
				  + MAX_IMODEM_PORTS )
# endif /* TNT && SHELF_CARD */

//
// zhz, move to mibfld.h
//


#define MAX_INDEX_NAME_LEN			4		/* 实例名长度 */
#define MAX_REMARK_LENGTH			30		/* 备注长度 */

# if ( NETIF & ( S56_2 | IFDSL | S56_4 | S56_4A ) )

#  if ( PLATFORM & MPORT )
#   define S56_MAX_DSL_PER_SLOT			4
#  elif ( PLATFORM & (P50 | PDSL) )
#   define S56_MAX_DSL_PER_SLOT			2
#  elif ( PLATFORM & P25 )
#   define S56_MAX_DSL_PER_SLOT			2
#  elif ( PLATFORM & TNT )
#   define S56_MAX_DSL_PER_SLOT			4
#  else
#   error Unknown PLATFORM
#  endif

#  define S56_B_CHANNELS_PER_DSL		1

# endif /* ( NETIF & ( S56_2 | IFDSL | S56_4 | S56_4A ) ) */

# if ( NETIF & DPNSS )

#  if ( PLATFORM & MPORT )
#   define DPNSS_MAX_DSL_PER_SLOT		2
#  elif (PLATFORM & TNT )
#   define DPNSS_MAX_DSL_PER_SLOT		2
#  elif ! ( PLATFORM & ( P50 | PDSL | P25 )
#   error Unknown PLATFORM
#  endif

#  define DPNSS_B_CHANNELS_PER_DSL		32

# endif /* ( NETIF & DPNSS ) */

    /*
     * If the number / group is a group and not a number, then the mask
     * will be or'ed in to indicate it as such.  This mask is used to
     * allow the same Word field to hold both the number and the group.
     *
     * This bit mask is used by this module and elsewhere.
     */
# define NUM_GROUP_GROUP_MASK	0x8000

# if ( MDF_OSPF == FYES )
extern const MibFieldEnumParams	         auTypeParams;
# endif /* ( MDF_OSPF == FYES ) */


    /*
     * NetworkSwitchType:
     *
     * The switch types are enumerated below:
     *
     *  SWITCH_PRI_ATT The PRI Switch Types supported today are enumerated
     *                                  below.
     *
     *  SWITCH_PRI_NTI
     *
     *  SWITCH_PRI_GLOBAND
     *
     *  SWITCH_PRI_JAPAN
     *
     *  SWITCH_PRI_VN3
     *
     *  SWITCH_PRI_1TR6
     *
     *  SWITCH_PRI_NET5
     *
     *  SWITCH_PRI_DANISH
     *
     *  SWITCH_PRI_AUSTRAL
     *
     *  SWITCH_PRI_NAT_ISDN_2
     *
     *  SWITCH_DPNSS_ISDX The Dpnss and DASS 2 Switch Types supported today are
     *                                  enumerated below.
     *
     *  SWITCH_DPNSS_ISLX
     *
     *  SWITCH_DPNSS_MERCURY
     *
     *  SWITCH_DASS2
     *
     *  SWITCH_BRI_UNKNOWN The BRI Switch Type Unknown is supported for Auto
     *                                  SPID.
     *
     *  SWITCH_BRI_ATT_5ESS The BRI Switch Types supported today are enumerated
     *                                  below. All of the lines within a
     *                                  network interface must come from the
     *                                  same switch, due to synchronization
     *                                  limitations of the network interface
     *                                  hardware.
     *
     *  SWITCH_BRI_NTI_DMS100
     *
     *  SWITCH_BRI_NISDN_1
     *
     *  SWITCH_BRI_VN2
     *
     *  SWITCH_BRI_BTNR_191
     *
     *  SWITCH_BRI_NET3
     *
     *  SWITCH_BRI_NET3_PTP
     *
     *  SWITCH_BRI_KDD
     *
     *  SWITCH_BRI_BELGIAN
     *
     *  SWITCH_BRI_AUSTRAL
     *
     *  SWITCH_BRI_SWISS
     *
     *  SWITCH_BRI_GERMAN_1TR6
     *
     *  SWITCH_BRI_DUTCH_1TR6
     *
     *  SWITCH_CAS The CAS switch type is used with R2.
     *
     *  SWITCH_BRI_IDSL
     */
typedef enum NetworkSwitchType {
    SWITCH_PRI_ATT,
    SWITCH_PRI_NTI,
    SWITCH_PRI_GLOBAND,
    SWITCH_PRI_JAPAN,
    SWITCH_PRI_VN3,
    SWITCH_PRI_1TR6,
    SWITCH_PRI_NET5,
    SWITCH_PRI_DANISH,
    SWITCH_PRI_AUSTRAL,
    SWITCH_PRI_NAT_ISDN_2,
    SWITCH_DPNSS_ISDX,
    SWITCH_DPNSS_ISLX,
    SWITCH_DPNSS_MERCURY,
    SWITCH_DASS2,
    SWITCH_BRI_UNKNOWN,
    SWITCH_BRI_ATT_5ESS,
    SWITCH_BRI_NTI_DMS100,
    SWITCH_BRI_NISDN_1,
    SWITCH_BRI_VN2,
    SWITCH_BRI_BTNR_191,
    SWITCH_BRI_NET3,
    SWITCH_BRI_NET3_PTP,
    SWITCH_BRI_KDD,
    SWITCH_BRI_BELGIAN,
    SWITCH_BRI_AUSTRAL,
    SWITCH_BRI_SWISS,
    SWITCH_BRI_GERMAN_1TR6,
    SWITCH_BRI_DUTCH_1TR6,
    SWITCH_CAS,
    SWITCH_BRI_IDSL
} NetworkSwitchType;


static __inline__ Bool
validNetworkSwitchType (int x)
{
    switch (x) {
    case SWITCH_PRI_ATT:
    case SWITCH_PRI_NTI:
    case SWITCH_PRI_GLOBAND:
    case SWITCH_PRI_JAPAN:
    case SWITCH_PRI_VN3:
    case SWITCH_PRI_1TR6:
    case SWITCH_PRI_NET5:
    case SWITCH_PRI_DANISH:
    case SWITCH_PRI_AUSTRAL:
    case SWITCH_PRI_NAT_ISDN_2:
    case SWITCH_DPNSS_ISDX:
    case SWITCH_DPNSS_ISLX:
    case SWITCH_DPNSS_MERCURY:
    case SWITCH_DASS2:
    case SWITCH_BRI_UNKNOWN:
    case SWITCH_BRI_ATT_5ESS:
    case SWITCH_BRI_NTI_DMS100:
    case SWITCH_BRI_NISDN_1:
    case SWITCH_BRI_VN2:
    case SWITCH_BRI_BTNR_191:
    case SWITCH_BRI_NET3:
    case SWITCH_BRI_NET3_PTP:
    case SWITCH_BRI_KDD:
    case SWITCH_BRI_BELGIAN:
    case SWITCH_BRI_AUSTRAL:
    case SWITCH_BRI_SWISS:
    case SWITCH_BRI_GERMAN_1TR6:
    case SWITCH_BRI_DUTCH_1TR6:
    case SWITCH_CAS:
    case SWITCH_BRI_IDSL:
        return TRUE;
    default:
        return FALSE;
    }
}

    /*
     * DpnssBoolean:
     *
     * Enumerate the FALSE/TRUE values used in dpnssl3/l2.
     *
     *  DPNSS_FALSE
     *
     *  DPNSS_TRUE
     */

#if (( NETIF & DPNSS ) || ( MDF_DPNSS_SIGNALING == FYES ))

typedef enum DpnssBoolean {
    DPNSS_FALSE,
    DPNSS_TRUE
} DpnssBoolean;

#endif /* (( NETIF & DPNSS ) || ( MDF_DPNSS_SIGNALING == FYES )) */

#if (( NETIF & DPNSS ) || ( MDF_DPNSS_SIGNALING == FYES ))



static __inline__ Bool
validDpnssBoolean (int x)
{
    switch (x) {
    case DPNSS_FALSE:
    case DPNSS_TRUE:
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* (( NETIF & DPNSS ) || ( MDF_DPNSS_SIGNALING == FYES )) */

    /*
     * T1ClockSource:
     *
     * Each T1 trunk may be selectable as a clock source for the unit. If a
     * particular trunk is not usable as a clock source, then this enumeration
     * allows the user to disable it. This is necessary for unclocked circuits
     * to the network.
     *
     *  T1_CLK_USABLE The T1 line can be used as the master clock source.
     *
     *  T1_CLK_SLAVE_ONLY The T1 line can not be used as the master clock
     *                                  source.
     */

#if NETIF & ( DPNSS | T1 | E1 )

typedef enum T1ClockSource {
    T1_CLK_USABLE,
    T1_CLK_SLAVE_ONLY
} T1ClockSource;

#endif /* NETIF & ( DPNSS | T1 | E1 ) */

#if NETIF & ( DPNSS | T1 | E1 )



static __inline__ Bool
validT1ClockSource (int x)
{
    switch (x) {
    case T1_CLK_USABLE:
    case T1_CLK_SLAVE_ONLY:
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* NETIF & ( DPNSS | T1 | E1 ) */

    /*
     * ClockPriority:
     *
     * The user can assign clock priorities to T1 lines, so that specific T1
     * lines can be selected as clock sources.
     *
     *  PRIORITY_1 Highest priority. A line with this priority will be selected
     *                                  over lines with lower priorities. If
     *                                  more than one line has the highest
     *                                  priority, the first one to become
     *                                  available will be the source.
     *
     *  PRIORITY_2 Second highest clock priority.
     *
     *  PRIORITY_3 Last clock priority.
     *
     *  INVALID_PRIORITY Value used to indicate priority has not been set.
     */

#if ( PLATFORM == TNT ) && ( NETIF & ( T1 | E1 ) )

typedef enum ClockPriority {
    PRIORITY_1 = 1,
    PRIORITY_2,
    PRIORITY_3,
    INVALID_PRIORITY
} ClockPriority;

#endif /* ( PLATFORM == TNT ) && ( NETIF & ( T1 | E1 ) ) */

#if ( PLATFORM == TNT ) && ( NETIF & ( T1 | E1 ) )



static __inline__ Bool
validClockPriority (int x)
{
    switch (x) {
    case PRIORITY_1:
    case PRIORITY_2:
    case PRIORITY_3:
    case INVALID_PRIORITY:
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* ( PLATFORM == TNT ) && ( NETIF & ( T1 | E1 ) ) */

    /*
     * DS0MinReset:
     *
     * This enumeration lists the choices for reseting the DS0 minute counter
     * per port.
     *
     *  NO_DS0_MIN_RESET
     *
     *  DAILY_DS0_MIN_RESET
     *
     *  MONTHLY_DS0_MIN_RESET
     */
typedef enum DS0MinReset {
    NO_DS0_MIN_RESET,
    DAILY_DS0_MIN_RESET,
    MONTHLY_DS0_MIN_RESET
} DS0MinReset;


static __inline__ Bool
validDS0MinReset (int x)
{
    switch (x) {
    case NO_DS0_MIN_RESET:
    case DAILY_DS0_MIN_RESET:
    case MONTHLY_DS0_MIN_RESET:
        return TRUE;
    default:
        return FALSE;
    }
}

    /*
     * MenuType:
     *
     * The PLUS/Max will support three user interfaces, hopefully using the
     * same code/mechanisms. They are:
     *
     *  MENU_STANDARD The standard VT-100 user interface.
     *
     *  MENU_LIMITED The simplified VT-100 user interface.
     *
     *  MENU_MIF The UTT Machine interface.
     *
     *  NUMBER_OF_MENU_TYPES
     */
typedef enum MenuType {
    MENU_STANDARD,
#if ( PLATFORM & ( MPORT ) )
    MENU_LIMITED,
#endif /* ( PLATFORM & ( MPORT ) ) */
    MENU_MIF,
    NUMBER_OF_MENU_TYPES
} MenuType;


static __inline__ Bool
validMenuType (int x)
{
    switch (x) {
    case MENU_STANDARD:
#if ( PLATFORM & ( MPORT ) )
    case MENU_LIMITED:
#endif /* ( PLATFORM & ( MPORT ) ) */
    case MENU_MIF:
    case NUMBER_OF_MENU_TYPES:
        return TRUE;
    default:
        return FALSE;
    }
}

    /*
     * HistoryWeighType:
     *
     * We have several different algorithms that the user can select from in
     * order to determine the current weighted line utilization. Those
     * algorithms are enumerated here, but documented reasonably well in the
     * product specification.
     *
     *  HISTORY_CONSTANT_WEIGHING
     *
     *  HISTORY_LINEAR_WEIGHING
     *
     *  HISTORY_EXPONENTIAL_WEIGHING
     *
     *  HISTORY_NUMBER_OF_WEIGHING
     */
typedef enum HistoryWeighType {
    HISTORY_CONSTANT_WEIGHING,
    HISTORY_LINEAR_WEIGHING,
    HISTORY_EXPONENTIAL_WEIGHING,
    HISTORY_NUMBER_OF_WEIGHING
} HistoryWeighType;


static __inline__ Bool
validHistoryWeighType (int x)
{
    switch (x) {
    case HISTORY_CONSTANT_WEIGHING:
    case HISTORY_LINEAR_WEIGHING:
    case HISTORY_EXPONENTIAL_WEIGHING:
    case HISTORY_NUMBER_OF_WEIGHING:
        return TRUE;
    default:
        return FALSE;
    }
}

    /*
     * NailedMode:
     *
     * The nailed mode specifies if any part a connection uses nailed (leased)
     * channels. The choices are:
     *
     *  NAILED_MODE_OFF No nailed channels are used.
     *
     *  NAILED_MODE_FT1 Only nailed channels are used.
     *
     *  NAILED_MODE_FT1_MPP A mixture of nailed and switched channels are used.
     *                                  Requires the CallMgmtType to be
     *                                  CALL_MGMT_MPP.
     *
     *  PERM_SW_MODE A permanent switched channel is used.
     *
     *  NAILED_MODE_FT1_BO Similar to NAILED_MODE_MPP but allows switched calls
     *                                  to be made even when the nailed
     *                                  channels are down -- backup and
     *                                  overflow.
     *
     *  NAILED_MODE_DCHANNEL D-channel call type
     *
     *  NAILED_MODE_AODI AO/DI call type
     */
typedef enum NailedMode {
    NAILED_MODE_OFF,
    NAILED_MODE_FT1,
    NAILED_MODE_FT1_MPP,
#if ( MDF_PERM_SWITCHED == FYES )
    PERM_SW_MODE,
#endif /* ( MDF_PERM_SWITCHED == FYES ) */
    NAILED_MODE_FT1_BO,
#if ( MDF_X25_DCHAN == FYES )
    NAILED_MODE_DCHANNEL,
#endif /* ( MDF_X25_DCHAN == FYES ) */
#if ( MDF_X25B == FYES )
    NAILED_MODE_AODI
#endif /* ( MDF_X25B == FYES ) */
} NailedMode;


static __inline__ Bool
validNailedMode (int x)
{
    switch (x) {
    case NAILED_MODE_OFF:
    case NAILED_MODE_FT1:
    case NAILED_MODE_FT1_MPP:
#if ( MDF_PERM_SWITCHED == FYES )
    case PERM_SW_MODE:
#endif /* ( MDF_PERM_SWITCHED == FYES ) */
    case NAILED_MODE_FT1_BO:
#if ( MDF_X25_DCHAN == FYES )
    case NAILED_MODE_DCHANNEL:
#endif /* ( MDF_X25_DCHAN == FYES ) */
#if ( MDF_X25B == FYES )
    case NAILED_MODE_AODI:
#endif /* ( MDF_X25B == FYES ) */
        return TRUE;
    default:
        return FALSE;
    }
}

    /*
     * TimePeriodUse:
     *
     * The possible values for the time period use parameter.
     *
     *  TIME_PERIOD_DISABLED
     *
     *  TIME_PERIOD_ENABLED
     *
     *  TIME_PERIOD_SHUTDOWN
     */
typedef enum TimePeriodUse {
    TIME_PERIOD_DISABLED,
    TIME_PERIOD_ENABLED,
    TIME_PERIOD_SHUTDOWN
} TimePeriodUse;


static __inline__ Bool
validTimePeriodUse (int x)
{
    switch (x) {
    case TIME_PERIOD_DISABLED:
    case TIME_PERIOD_ENABLED:
    case TIME_PERIOD_SHUTDOWN:
        return TRUE;
    default:
        return FALSE;
    }
}

    /*
     * SlotCardType:
     *
     * The slots that are supported by this software are enumerated below. As
     * other types of cards are added, the number of values in this enumeration
     * are extended.
     *
     *  SLOT_CARD_NO_CARD No card is installed in the slot, or the slot does
     *                                  not physically exist in the unit.
     *
     *  SLOT_CARD_DUAL_SYS_T1 A motherboard resident dual-T1 system slot card.
     *                                  On MAX2000, the second port provides a
     *                                  'serial port T1-CSU'. On other systems
     *                                  it has the ability to perform drop and
     *                                  insert or dual-network. This card does
     *                                  not support T1 switching.
     *
     *  SLOT_CARD_DUAL_SLOT_T1 T1/E1 slot card -- supports T1 switching.
     *
     *  SLOT_CARD_SYS_BRI A BRI 3/8 system slot card (for MBPLUS, SOS and P50 |
     *                                  PDSL PLATFORM's, MPORT platform does
     *                                  not have a BRI system card).
     *
     *  SLOT_CARD_SYS_BRI_MAX1800 A BRI-8 network 'slot card' which resides on
     *                                  the system motherboard and acts as the
     *                                  user side.
     *
     *  SLOT_CARD_SLOT_BRI_TE A BRI-8 network slot card which acts as the user
     *                                  side.
     *
     *  SLOT_CARD_SLOT_BRI_NT A BRI-8 network slot card which acts as the
     *                                  network side and is connected to user's
     *                                  BRI equipment.
     *
     *  SLOT_CARD_SLOT_BRI_LT A BRIU-8 or 32-IDSL network slot card which acts
     *                                  as the line termination side and is
     *                                  connected to user's BRI/U equipment.
     *
     *  SLOT_CARD_S56_4 A S56 (pseudo?) 4 wire network slot card. This includes
     *                                  both HT Communications and UTT
     *                                  versions.
     *
     *  SLOT_CARD_S56_2 A S56 (pseudo?) 2 wire network slot card.
     *
     *  SLOT_CARD_DUAL_AIM A dual-AIM slot card. This is the equivalence of a
     *                                  Multiband Plus motherboard. It has two
     *                                  N-by capable ports and a palmtop port.
     *
     *  SLOT_CARD_MRM_AIM
     *
     *  SLOT_CARD_AIM6 A host slot card having six host ports, all of which are
     *                                  N-by capable. It does not have a
     *                                  palmtop port.
     *
     *  SLOT_CARD_ETHER An Ethernet slot card. On the MAX this card contains
     *                                  TSS, Spyder, and Intel '596 ethernet
     *                                  chip set. On the PLUS it is a clone of
     *                                  an NE2000 PC ethernet card. On the SOS
     *                                  this is a pseudo slot card containing a
     *                                  Spyder and 596.
     *
     *  SLOT_CARD_ETHER_DATA A MAX Ethernet helper slot card. This card
     *                                  contains a TSS and Spyder, but uses the
     *                                  Ethernet chip set of a SLOT_CARD_ETHER.
     *                                  It is used to add another 32 HDLC
     *                                  channels to an existing Ethernet slot.
     *
     *  SLOT_CARD_LAN_MODEM A LAN (HDLC) digital modem slot card on a MAX,
     *                                  providing a data path from the system
     *                                  backplane through digital modems and
     *                                  HDLC/async channels to system memory.
     *                                  It has 8 digital modems, a TSS, and 4
     *                                  SCAs providing 8 serial channels.
     *
     *  SLOT_CARD_PROG_MODEM Same as above, but V.34 with programable firmware
     *                                  support.
     *
     *  SLOT_CARD_12PROG_MODEM Same as above, but with 12 modems.
     *
     *  SLOT_CARD_8DIG_MODEM A slot card with 8 all digital modems.
     *
     *  SLOT_CARD_12DIG_MODEM A slot card with 12 all digital modems.
     *
     *  SLOT_CARD_16DIG_MODEM A slot card with 16 all digital modems.
     *
     *  SLOT_CARD_8DIG_2M_MODEM A slot card with 8 all digital modems with 2M
     *                                  of code memory.
     *
     *  SLOT_CARD_12DIG_2M_MODEM A slot card with 12 all digital modems with 2M
     *                                  of code memory.
     *
     *  SLOT_CARD_16DIG_2M_MODEM A slot card with 16 all digital modems with 2M
     *                                  of code memory.
     *
     *  SLOT_CARD_SERIAL_WAN A pseudo slot card on the MAX-HP, MAX1800 and
     *                                  MAX2000 containing a high speed HDLC
     *                                  controller (SCA) connected to a
     *                                  V.35-like port.
     *
     *  SLOT_CARD_V35 A daughter card on the P50 interfacing a high speed
     *                                  serial data from a V.35 port to SCCs.
     *
     *  SLOT_CARD_PRIMARY_NAILED_56
     *
     *  SLOT_CARD_PRIMARY_NAILED_T1
     *
     *  SLOT_CARD_DUAL_POTS A (virtual) slot card containing two Plain Old
     *                                  Telephone Service (POTS) ports.
     *
     *  SLOT_CARD_8V32_PHS Slot card with hardware to support the V.32 PHS
     *                                  protocol.
     *
     *  SLOT_CARD_12V32_PHS Slot card with hardware to support the V.32 PHS
     *                                  protocol.
     *
     *  SLOT_CARD_16V32_PHS Slot card with hardware to support the V.32 PHS
     *                                  protocol.
     *
     *  SLOT_CARD_V110 Slot card with hardware to support the V.110 srate
     *                                  adaption protocol.
     *
     *  SLOT_CARD_ATMODEM PC CARD (PCMCIA) Modem, for use in the MAX200.
     *
     *  SLOT_CARD_SYS_SERIAL_T1_CSU A T1 network 'slot card' which resides on
     *                                  the system motherboard directly
     *                                  connected to the second port of the
     *                                  SWAN, providing a 'serial port T1-CSU'.
     *
     *  SLOT_CARD_IMODEM On the P15 this is a pseudo slot card containing a
     *                                  ISDN modem interface.
     *
     *  SLOT_CARD_8VDSP Slot card with hardware to support the VDSP VOIP
     *                                  protocol.
     *
     *  SLOT_CARD_12VDSP Slot card with hardware to support the VDSP VOIP
     *                                  protocol.
     *
     *  SLOT_CARD_16VDSP Slot card with hardware to support the VDSP VOIP
     *                                  protocol.
     *
     *  SLOT_CARD_SLOT_BRI_TE_U A BRI-8 network slot card which acts as the
     *                                  user side.
     *
     *  SLOT_CARD_DS3_ATM DS3-ATM I/O card for the stinger 100.
     *
     *  SLOT_CARD_UDS3 Unchannelized DS3 I/O card for the stinger 100.
     *
     *  SLOT_NUMBER_OF_CARDS
     */
typedef enum SlotCardType {
    SLOT_CARD_NO_CARD,
#if ( NETIF & ( T1 | E1 | DPNSS ))
    SLOT_CARD_DUAL_SYS_T1,
#endif /* ( NETIF & ( T1 | E1 | DPNSS )) */
#if ( NETIF & ( T1 | E1 | DPNSS ))
    SLOT_CARD_DUAL_SLOT_T1,
#endif /* ( NETIF & ( T1 | E1 | DPNSS )) */
#if ( NETIF & BRI )
    SLOT_CARD_SYS_BRI,
#endif /* ( NETIF & BRI ) */
#if ( PLATFORM & M1800 )
    SLOT_CARD_SYS_BRI_MAX1800,
#endif /* ( PLATFORM & M1800 ) */
#if ( NETIF & BRI )
    SLOT_CARD_SLOT_BRI_TE,
#endif /* ( NETIF & BRI ) */
#if ( NETIF & BRI )
    SLOT_CARD_SLOT_BRI_NT,
#endif /* ( NETIF & BRI ) */
#if (( NETIF & BRI ) && ( ( PLATFORM & MPORT ) || Q_TNT ))
    SLOT_CARD_SLOT_BRI_LT,
#endif /* (( NETIF & BRI ) && ( ( PLATFORM & MPORT ) || Q_TNT )) */
#if ( NETIF & ( S56_4 | S56_4A ))
    SLOT_CARD_S56_4,
#endif /* ( NETIF & ( S56_4 | S56_4A )) */
#if ( NETIF & (S56_2 | IFDSL) )
    SLOT_CARD_S56_2,
#endif /* ( NETIF & (S56_2 | IFDSL) ) */
#if (( PLATFORM & MPORT ) && ( AIM == FYES )) || ( PLATFORM & TNT )
    SLOT_CARD_DUAL_AIM,
#endif /* (( PLATFORM & MPORT ) && ( AIM == FYES )) || ( PLATFORM & TNT ) */
#if (( PLATFORM & MPORT ) && ( AIM == FYES )) || ( PLATFORM & TNT )
    SLOT_CARD_MRM_AIM,
#endif /* (( PLATFORM & MPORT ) && ( AIM == FYES )) || ( PLATFORM & TNT ) */
#if (( PLATFORM & MPORT ) && ( AIM == FYES )) || ( PLATFORM & TNT )
    SLOT_CARD_AIM6,
#endif /* (( PLATFORM & MPORT ) && ( AIM == FYES )) || ( PLATFORM & TNT ) */
#if ( MDF_ETHERNET == FYES )
    SLOT_CARD_ETHER,
#endif /* ( MDF_ETHERNET == FYES ) */
#if (( MDF_ETHERNET == FYES ) && ( PLATFORM & ( MPORT | TNT )))
    SLOT_CARD_ETHER_DATA,
#endif /* (( MDF_ETHERNET == FYES ) && ( PLATFORM & ( MPORT | TNT ))) */
#if ( MDF_LMODEM == FYES )
    SLOT_CARD_LAN_MODEM,
#endif /* ( MDF_LMODEM == FYES ) */
#if ( MDF_LMODEM == FYES )
    SLOT_CARD_PROG_MODEM,
#endif /* ( MDF_LMODEM == FYES ) */
#if ( MDF_PARALLEL_MODEMS == FYES )
    SLOT_CARD_12PROG_MODEM,
#endif /* ( MDF_PARALLEL_MODEMS == FYES ) */
#if ( MDF_DIGITAL_MODEMS == FYES )
    SLOT_CARD_8DIG_MODEM,
#endif /* ( MDF_DIGITAL_MODEMS == FYES ) */
#if ( MDF_DIGITAL_MODEMS == FYES )
    SLOT_CARD_12DIG_MODEM,
#endif /* ( MDF_DIGITAL_MODEMS == FYES ) */
#if ( MDF_DIGITAL_MODEMS == FYES )
    SLOT_CARD_16DIG_MODEM,
#endif /* ( MDF_DIGITAL_MODEMS == FYES ) */
#if ( MDF_DIGITAL_MODEMS == FYES )
    SLOT_CARD_8DIG_2M_MODEM,
#endif /* ( MDF_DIGITAL_MODEMS == FYES ) */
#if ( MDF_DIGITAL_MODEMS == FYES )
    SLOT_CARD_16DIG_2M_MODEM,
#endif /* ( MDF_DIGITAL_MODEMS == FYES ) */
#if ( MDF_SERIAL_WAN == FYES )
    SLOT_CARD_SERIAL_WAN,
#endif /* ( MDF_SERIAL_WAN == FYES ) */
#if ( MDF_V35 == FYES )
    SLOT_CARD_V35,
#endif /* ( MDF_V35 == FYES ) */
#if ( MDF_PRIMARY_NAILED_56 == FYES )
    SLOT_CARD_PRIMARY_NAILED_56,
#endif /* ( MDF_PRIMARY_NAILED_56 == FYES ) */
#if ( MDF_PRIMARY_NAILED_T1 == FYES )
    SLOT_CARD_PRIMARY_NAILED_T1,
#endif /* ( MDF_PRIMARY_NAILED_T1 == FYES ) */
#if ( MDF_POTS == FYES )
    SLOT_CARD_DUAL_POTS,
#endif /* ( MDF_POTS == FYES ) */
#if ( MDF_V32_PHS == FYES )
    SLOT_CARD_8V32_PHS,
#endif /* ( MDF_V32_PHS == FYES ) */
#if ( MDF_V32_PHS == FYES )
    SLOT_CARD_12V32_PHS,
#endif /* ( MDF_V32_PHS == FYES ) */
#if ( MDF_V32_PHS == FYES )
    SLOT_CARD_16V32_PHS,
#endif /* ( MDF_V32_PHS == FYES ) */
#if ( MDF_V110 == FYES )
    SLOT_CARD_V110,
#endif /* ( MDF_V110 == FYES ) */
#if ( PLATFORM & ( M200 ))
    SLOT_CARD_ATMODEM,
#endif /* ( PLATFORM & ( M200 )) */
#if ( PLATFORM & ( M2000 | P220 ) )
    SLOT_CARD_SYS_SERIAL_T1_CSU,
#endif /* ( PLATFORM & ( M2000 | P220 ) ) */
#if ( MDF_IMODEM == FYES )
    SLOT_CARD_IMODEM,
#endif /* ( MDF_IMODEM == FYES ) */
#if ( MDF_VOIP == FYES )
    SLOT_CARD_8VDSP,
#endif /* ( MDF_VOIP == FYES ) */
#if ( MDF_VOIP == FYES )
    SLOT_CARD_12VDSP,
#endif /* ( MDF_VOIP == FYES ) */
#if ( MDF_VOIP == FYES )
    SLOT_CARD_16VDSP,
#endif /* ( MDF_VOIP == FYES ) */
#if ( NETIF & BRI )
    SLOT_CARD_SLOT_BRI_TE_U,
#endif /* ( NETIF & BRI ) */
#if ( NETIF & DS3ATM_IF )
    SLOT_CARD_DS3_ATM,
#endif /* ( NETIF & DS3ATM_IF ) */
#if ( NETIF & UDS3 )
    SLOT_CARD_UDS3,
#endif /* ( NETIF & UDS3 ) */
    SLOT_NUMBER_OF_CARDS
} SlotCardType;


static __inline__ Bool
validSlotCardType (int x)
{
    switch (x) {
    case SLOT_CARD_NO_CARD:
#if ( NETIF & ( T1 | E1 | DPNSS ))
    case SLOT_CARD_DUAL_SYS_T1:
#endif /* ( NETIF & ( T1 | E1 | DPNSS )) */
#if ( NETIF & ( T1 | E1 | DPNSS ))
    case SLOT_CARD_DUAL_SLOT_T1:
#endif /* ( NETIF & ( T1 | E1 | DPNSS )) */
#if ( NETIF & BRI )
    case SLOT_CARD_SYS_BRI:
#endif /* ( NETIF & BRI ) */
#if ( PLATFORM & M1800 )
    case SLOT_CARD_SYS_BRI_MAX1800:
#endif /* ( PLATFORM & M1800 ) */
#if ( NETIF & BRI )
    case SLOT_CARD_SLOT_BRI_TE:
#endif /* ( NETIF & BRI ) */
#if ( NETIF & BRI )
    case SLOT_CARD_SLOT_BRI_NT:
#endif /* ( NETIF & BRI ) */
#if (( NETIF & BRI ) && ( ( PLATFORM & MPORT ) || Q_TNT ))
    case SLOT_CARD_SLOT_BRI_LT:
#endif /* (( NETIF & BRI ) && ( ( PLATFORM & MPORT ) || Q_TNT )) */
#if ( NETIF & ( S56_4 | S56_4A ))
    case SLOT_CARD_S56_4:
#endif /* ( NETIF & ( S56_4 | S56_4A )) */
#if ( NETIF & (S56_2 | IFDSL) )
    case SLOT_CARD_S56_2:
#endif /* ( NETIF & (S56_2 | IFDSL) ) */
#if (( PLATFORM & MPORT ) && ( AIM == FYES )) || ( PLATFORM & TNT )
    case SLOT_CARD_DUAL_AIM:
#endif /* (( PLATFORM & MPORT ) && ( AIM == FYES )) || ( PLATFORM & TNT ) */
#if (( PLATFORM & MPORT ) && ( AIM == FYES )) || ( PLATFORM & TNT )
    case SLOT_CARD_MRM_AIM:
#endif /* (( PLATFORM & MPORT ) && ( AIM == FYES )) || ( PLATFORM & TNT ) */
#if (( PLATFORM & MPORT ) && ( AIM == FYES )) || ( PLATFORM & TNT )
    case SLOT_CARD_AIM6:
#endif /* (( PLATFORM & MPORT ) && ( AIM == FYES )) || ( PLATFORM & TNT ) */
#if ( MDF_ETHERNET == FYES )
    case SLOT_CARD_ETHER:
#endif /* ( MDF_ETHERNET == FYES ) */
#if (( MDF_ETHERNET == FYES ) && ( PLATFORM & ( MPORT | TNT )))
    case SLOT_CARD_ETHER_DATA:
#endif /* (( MDF_ETHERNET == FYES ) && ( PLATFORM & ( MPORT | TNT ))) */
#if ( MDF_LMODEM == FYES )
    case SLOT_CARD_LAN_MODEM:
#endif /* ( MDF_LMODEM == FYES ) */
#if ( MDF_LMODEM == FYES )
    case SLOT_CARD_PROG_MODEM:
#endif /* ( MDF_LMODEM == FYES ) */
#if ( MDF_PARALLEL_MODEMS == FYES )
    case SLOT_CARD_12PROG_MODEM:
#endif /* ( MDF_PARALLEL_MODEMS == FYES ) */
#if ( MDF_DIGITAL_MODEMS == FYES )
    case SLOT_CARD_8DIG_MODEM:
#endif /* ( MDF_DIGITAL_MODEMS == FYES ) */
#if ( MDF_DIGITAL_MODEMS == FYES )
    case SLOT_CARD_12DIG_MODEM:
#endif /* ( MDF_DIGITAL_MODEMS == FYES ) */
#if ( MDF_DIGITAL_MODEMS == FYES )
    case SLOT_CARD_16DIG_MODEM:
#endif /* ( MDF_DIGITAL_MODEMS == FYES ) */
#if ( MDF_DIGITAL_MODEMS == FYES )
    case SLOT_CARD_8DIG_2M_MODEM:
#endif /* ( MDF_DIGITAL_MODEMS == FYES ) */
#if ( MDF_DIGITAL_MODEMS == FYES )
    case SLOT_CARD_12DIG_2M_MODEM:
#endif /* ( MDF_DIGITAL_MODEMS == FYES ) */
#if ( MDF_DIGITAL_MODEMS == FYES )
    case SLOT_CARD_16DIG_2M_MODEM:
#endif /* ( MDF_DIGITAL_MODEMS == FYES ) */
#if ( MDF_SERIAL_WAN == FYES )
    case SLOT_CARD_SERIAL_WAN:
#endif /* ( MDF_SERIAL_WAN == FYES ) */
#if ( MDF_V35 == FYES )
    case SLOT_CARD_V35:
#endif /* ( MDF_V35 == FYES ) */
#if ( MDF_PRIMARY_NAILED_56 == FYES )
    case SLOT_CARD_PRIMARY_NAILED_56:
#endif /* ( MDF_PRIMARY_NAILED_56 == FYES ) */
#if ( MDF_PRIMARY_NAILED_T1 == FYES )
    case SLOT_CARD_PRIMARY_NAILED_T1:
#endif /* ( MDF_PRIMARY_NAILED_T1 == FYES ) */
#if ( MDF_POTS == FYES )
    case SLOT_CARD_DUAL_POTS:
#endif /* ( MDF_POTS == FYES ) */
#if ( MDF_V32_PHS == FYES )
    case SLOT_CARD_8V32_PHS:
#endif /* ( MDF_V32_PHS == FYES ) */
#if ( MDF_V32_PHS == FYES )
    case SLOT_CARD_12V32_PHS:
#endif /* ( MDF_V32_PHS == FYES ) */
#if ( MDF_V32_PHS == FYES )
    case SLOT_CARD_16V32_PHS:
#endif /* ( MDF_V32_PHS == FYES ) */
#if ( MDF_V110 == FYES )
    case SLOT_CARD_V110:
#endif /* ( MDF_V110 == FYES ) */
#if ( PLATFORM & ( M200 ))
    case SLOT_CARD_ATMODEM:
#endif /* ( PLATFORM & ( M200 )) */
#if ( PLATFORM & ( M2000 | P220 ) )
    case SLOT_CARD_SYS_SERIAL_T1_CSU:
#endif /* ( PLATFORM & ( M2000 | P220 ) ) */
#if ( MDF_IMODEM == FYES )
    case SLOT_CARD_IMODEM:
#endif /* ( MDF_IMODEM == FYES ) */
#if ( MDF_VOIP == FYES )
    case SLOT_CARD_8VDSP:
#endif /* ( MDF_VOIP == FYES ) */
#if ( MDF_VOIP == FYES )
    case SLOT_CARD_12VDSP:
#endif /* ( MDF_VOIP == FYES ) */
#if ( MDF_VOIP == FYES )
    case SLOT_CARD_16VDSP:
#endif /* ( MDF_VOIP == FYES ) */
#if ( NETIF & BRI )
    case SLOT_CARD_SLOT_BRI_TE_U:
#endif /* ( NETIF & BRI ) */
#if ( NETIF & DS3ATM_IF )
    case SLOT_CARD_DS3_ATM:
#endif /* ( NETIF & DS3ATM_IF ) */
#if ( NETIF & UDS3 )
    case SLOT_CARD_UDS3:
#endif /* ( NETIF & UDS3 ) */
    case SLOT_NUMBER_OF_CARDS:
        return TRUE;
    default:
        return FALSE;
    }
}

    /*
     * IdleMode:
     *
     * When idle the MAC layer can send either flags or all ones (marking). The
     * choices are defined by the IdleMode enumeration and are selected when
     * the MAC sub-layer is started.
     *
     *  MARK_IDLE
     *
     *  FLAG_IDLE
     *
     *  NUMBER_OF_IDLE_MODE
     */
typedef enum IdleMode {
    MARK_IDLE,
    FLAG_IDLE,
    NUMBER_OF_IDLE_MODE
} IdleMode;


static __inline__ Bool
validIdleMode (int x)
{
    switch (x) {
    case MARK_IDLE:
    case FLAG_IDLE:
    case NUMBER_OF_IDLE_MODE:
        return TRUE;
    default:
        return FALSE;
    }
}

    /*
     * DataSense:
     *
     * Data can be sent normal or inverted. Support for this may be provided by
     * the MAC hardware. DataSense is used to pass the requested mode when a
     * channel is started.
     *
     *  DATA_NORMAL
     *
     *  DATA_INV
     *
     *  NUMBER_OF_DATA_SENSE
     */
typedef enum DataSense {
    DATA_NORMAL,
    DATA_INV,
    NUMBER_OF_DATA_SENSE
} DataSense;


static __inline__ Bool
validDataSense (int x)
{
    switch (x) {
    case DATA_NORMAL:
    case DATA_INV:
    case NUMBER_OF_DATA_SENSE:
        return TRUE;
    default:
        return FALSE;
    }
}

    /*
     * SubAddressMode:
     *
     * Define the values for selection of subaddressing mode.
     *
     *  NO_SUBADDRESS Subaddressing is not used.
     *
     *  ROUTING_SUBADDRESS Subaddressing is used to route the call, in the case
     *                                  of MAX and Pipeline where multiple
     *                                  interfaces are available.
     *
     *  TERMSEL_SUBADDRESS Subaddressing is used to accept/ignore the call,
     *                                  i.e. to select a specific terminal on a
     *                                  multidrop line.
     */
typedef enum SubAddressMode {
    NO_SUBADDRESS,
    ROUTING_SUBADDRESS,
    TERMSEL_SUBADDRESS
} SubAddressMode;


static __inline__ Bool
validSubAddressMode (int x)
{
    switch (x) {
    case NO_SUBADDRESS:
    case ROUTING_SUBADDRESS:
    case TERMSEL_SUBADDRESS:
        return TRUE;
    default:
        return FALSE;
    }
}

    /*
     * The complex condition that determines if 57600 is enabled
     * for a particular unit.
     */
# define ENABLE_57600	( PLATFORM & ( P50 | PDSL | TNT | MPORT | M800 ) )


    /*
     * ControlPortBitRate:
     *
     * The following bit rates are supported for the control port.
     *
     *  CONTROL_PORT_BIT_RATE_300 300 bits per second
     *
     *  CONTROL_PORT_BIT_RATE_1200 1200 bits per second
     *
     *  CONTROL_PORT_BIT_RATE_2400 2400 bits per second
     *
     *  CONTROL_PORT_BIT_RATE_4800 4800 bits per second
     *
     *  CONTROL_PORT_BIT_RATE_9600 9600 bits per second
     *
     *  CONTROL_PORT_BIT_RATE_19200 19200 bits per second
     *
     *  CONTROL_PORT_BIT_RATE_38400 38400 bits per second
     *
     *  CONTROL_PORT_BIT_RATE_57600 57600 bits per second
     */
typedef enum ControlPortBitRate {
    CONTROL_PORT_BIT_RATE_300,
    CONTROL_PORT_BIT_RATE_1200,
    CONTROL_PORT_BIT_RATE_2400,
    CONTROL_PORT_BIT_RATE_4800,
    CONTROL_PORT_BIT_RATE_9600,
#if PLATFORM & ( P50 | PDSL | TNT )
    CONTROL_PORT_BIT_RATE_19200,
#endif /* PLATFORM & ( P50 | PDSL | TNT ) */
    CONTROL_PORT_BIT_RATE_38400,
#if ENABLE_57600
    CONTROL_PORT_BIT_RATE_57600
#endif /* ENABLE_57600 */
} ControlPortBitRate;


static __inline__ Bool
validControlPortBitRate (int x)
{
    switch (x) {
    case CONTROL_PORT_BIT_RATE_300:
    case CONTROL_PORT_BIT_RATE_1200:
    case CONTROL_PORT_BIT_RATE_2400:
    case CONTROL_PORT_BIT_RATE_4800:
    case CONTROL_PORT_BIT_RATE_9600:
#if PLATFORM & ( P50 | PDSL | TNT )
    case CONTROL_PORT_BIT_RATE_19200:
#endif /* PLATFORM & ( P50 | PDSL | TNT ) */
    case CONTROL_PORT_BIT_RATE_38400:
#if ENABLE_57600
    case CONTROL_PORT_BIT_RATE_57600:
#endif /* ENABLE_57600 */
        return TRUE;
    default:
        return FALSE;
    }
}

    /*
     * ConfigurationSource:
     *
     * The following are possible sources of code and and configuration.
     *
     *  CONFIG_SRC_NETWORK i.e., via TFTP.
     *
     *  CONFIG_SRC_CONSOLE i.e., via a CLI session.
     */
typedef enum ConfigurationSource {
    CONFIG_SRC_NETWORK,
    CONFIG_SRC_CONSOLE
} ConfigurationSource;


static __inline__ Bool
validConfigurationSource (int x)
{
    switch (x) {
    case CONFIG_SRC_NETWORK:
    case CONFIG_SRC_CONSOLE:
        return TRUE;
    default:
        return FALSE;
    }
}

    /*
     * LoadType:
     *
     * The possible values for the load-type of the CLI load command.
     *
     *  LOAD_TYPE_CONFIG A configuration script.
     *
     *  LOAD_TYPE_BOOT_SR A boot load for the shelf-router.
     *
     *  LOAD_TYPE_SR A run-time code load for the shelf-router.
     *
     *  LOAD_TYPE_TAR A tar file containing binary images.
     *
     *  LOAD_TYPE_8T1 A code load for the T1 card.
     *
     *  LOAD_TYPE_HDLC A code load for the HDLC card.
     *
     *  LOAD_TYPE_ENET A code load for the ethernet card.
     *
     *  LOAD_TYPE_MODEM A code load for the modem card.
     *
     *  LOAD_TYPE_SWAN A code load for the serial WAN card.
     *
     *  LOAD_TYPE_8E1 A code load for the E1 card.
     *
     *  LOAD_TYPE_ANALOG_MODEM A code load for the analog modem card --
     *                                  obsoleted. Replaced by amdm.
     *
     *  LOAD_TYPE_SDSL A code load for the SDSL card.
     *
     *  LOAD_TYPE_CAP_ADSL A code load for the CAP ADSL card.
     *
     *  LOAD_TYPE_DMT_ADSL A code load for the DMT ADSL card.
     *
     *  LOAD_TYPE_T3 A code load for the T3 card.
     *
     *  LOAD_TYPE_HSSI A code load for the HSSI card.
     *
     *  LOAD_TYPE_UNCHAN_T1 A code load for the unchannelized T1 card.
     *
     *  LOAD_TYPE_MODEM_56K A code load for the 56k modem card.
     *
     *  LOAD_TYPE_IDSL A code load for the IDSL card.
     *
     *  LOAD_TYPE_UNCHAN_E1 A code load for the unchannelized E1 card.
     *
     *  LOAD_TYPE_ANALOG_MODEM2 A code load for the analog modem card.
     *
     *  LOAD_TYPE_ROUTER A code load for the (proposed) dedicated router card.
     *
     *  LOAD_TYPE_CSMX A code load for the csm/x based modem card.
     *
     *  LOAD_TYPE_HDLC2 A code load for the HDLC2 card.
     *
     *  LOAD_TYPE_UDS3 A code load for the unchannelized DS3 card.
     *
     *  LOAD_TYPE_DS3_ATM A code load for the DS3 ATM card.
     *
     *  LOAD_TYPE_ENET2 A code load for the ethernet2 card.
     *
     *  LOAD_TYPE_SDSL70_DATA A code load for the SDSL data card.
     *
     *  LOAD_TYPE_SDSL70_VOICE A code load for the SDSL voice card.
     *
     *  LOAD_TYPE_MADD A code load for the madd card.
     */
typedef enum LoadType {
    LOAD_TYPE_CONFIG,
    LOAD_TYPE_BOOT_SR,
    LOAD_TYPE_SR,
    LOAD_TYPE_TAR,
    LOAD_TYPE_8T1,
    LOAD_TYPE_HDLC,
    LOAD_TYPE_ENET,
    LOAD_TYPE_MODEM,
    LOAD_TYPE_SWAN,
    LOAD_TYPE_8E1,
    LOAD_TYPE_ANALOG_MODEM,
    LOAD_TYPE_SDSL,
    LOAD_TYPE_CAP_ADSL,
    LOAD_TYPE_DMT_ADSL,
    LOAD_TYPE_T3,
    LOAD_TYPE_HSSI,
    LOAD_TYPE_UNCHAN_T1,
    LOAD_TYPE_MODEM_56K,
    LOAD_TYPE_IDSL,
    LOAD_TYPE_UNCHAN_E1,
    LOAD_TYPE_ANALOG_MODEM2,
    LOAD_TYPE_ROUTER,
    LOAD_TYPE_CSMX,
    LOAD_TYPE_HDLC2,
    LOAD_TYPE_UDS3,
    LOAD_TYPE_DS3_ATM,
    LOAD_TYPE_ENET2,
    LOAD_TYPE_SDSL70_DATA,
    LOAD_TYPE_SDSL70_VOICE,
    LOAD_TYPE_MADD
} LoadType;


static __inline__ Bool
validLoadType (int x)
{
    switch (x) {
    case LOAD_TYPE_CONFIG:
    case LOAD_TYPE_BOOT_SR:
    case LOAD_TYPE_SR:
    case LOAD_TYPE_TAR:
    case LOAD_TYPE_8T1:
    case LOAD_TYPE_HDLC:
    case LOAD_TYPE_ENET:
    case LOAD_TYPE_MODEM:
    case LOAD_TYPE_SWAN:
    case LOAD_TYPE_8E1:
    case LOAD_TYPE_ANALOG_MODEM:
    case LOAD_TYPE_SDSL:
    case LOAD_TYPE_CAP_ADSL:
    case LOAD_TYPE_DMT_ADSL:
    case LOAD_TYPE_T3:
    case LOAD_TYPE_HSSI:
    case LOAD_TYPE_UNCHAN_T1:
    case LOAD_TYPE_MODEM_56K:
    case LOAD_TYPE_IDSL:
    case LOAD_TYPE_UNCHAN_E1:
    case LOAD_TYPE_ANALOG_MODEM2:
    case LOAD_TYPE_ROUTER:
    case LOAD_TYPE_CSMX:
    case LOAD_TYPE_HDLC2:
    case LOAD_TYPE_UDS3:
    case LOAD_TYPE_DS3_ATM:
    case LOAD_TYPE_ENET2:
    case LOAD_TYPE_SDSL70_DATA:
    case LOAD_TYPE_SDSL70_VOICE:
    case LOAD_TYPE_MADD:
        return TRUE;
    default:
        return FALSE;
    }
}

    /*
     * CodeSubType:
     *
     * The possible values for the load-subtype of the CLI load command.
     *
     *  CSUB_NORMAL Normal, non-diagnostic load.
     *
     *  CSUB_DEBUG A debugging load.
     *
     *  CSUB_BOOT A boot load (sensible only for the shelf-router).
     *
     *  CSUB_DIAG A diagnostic load.
     *
     *  CSUB_NTYPES The number of subtypes supported.
     */
typedef enum CodeSubType {
    CSUB_NORMAL,
    CSUB_DEBUG,
    CSUB_BOOT,
    CSUB_DIAG,
    CSUB_NTYPES
} CodeSubType;


static __inline__ Bool
validCodeSubType (int x)
{
    switch (x) {
    case CSUB_NORMAL:
    case CSUB_DEBUG:
    case CSUB_BOOT:
    case CSUB_DIAG:
    case CSUB_NTYPES:
        return TRUE;
    default:
        return FALSE;
    }
}

    /*
     * FlashDevice:
     *
     * The following are possible targets for storing code loads.
     *
     *  FLASH_DEVICE_ON_BOARD The flash resident on the shelf-controller card.
     *
     *  FLASH_DEVICE_CARD_UPPER A flash card in the upper PCMIA slot.
     *
     *  FLASH_DEVICE_CARD_LOWER A flash card in the lower PCMIA slot.
     */
typedef enum FlashDevice {
    FLASH_DEVICE_ON_BOARD,
    FLASH_DEVICE_CARD_UPPER = 1,
    FLASH_DEVICE_CARD_LOWER = 2
} FlashDevice;


static __inline__ Bool
validFlashDevice (int x)
{
    switch (x) {
    case FLASH_DEVICE_ON_BOARD:
    case FLASH_DEVICE_CARD_UPPER:
    case FLASH_DEVICE_CARD_LOWER:
        return TRUE;
    default:
        return FALSE;
    }
}

    /*
     * TimePeriodParameters:
     *
     * Within each time-period (frequently, only one will be used), we need to
     * know what the parameters are. I think the following structure enumerates
     * those parameters for the DBA session that are variable based on the
     * time-period.
     *
     *  timePeriodInUse Like the other sub-structures above, the number of
     *                                  time-periods actually used is variable.
     *                                  Therefore, this is an indication within
     *                                  each structure of usage.
     *
     *  startingTime Each time period has a starting time, and an ending time
     *                                  (which is implicit by the next starting
     *                                  time specified in another structure).
     *                                  The starting time is specified
     *                                  internally as the number of seconds
     *                                  after midnight, where midnight itself
     *                                  has a value of zero.
     *
     *  minimumChannelCount The smallest number of channels to use during this
     *                                  time period.
     *
     *  maximumChannelCount The maximum number of channels to use during this
     *                                  time period.
     *
     *  targetUtilization The percentage utilization to aim for. This is used
     *                                  as a parameter to the bandwidth
     *                                  heuristics.
     */
typedef struct timePeriodParameters {
    TimePeriodUse                       timePeriodInUse;
    unsigned long                       startingTime;
    Word                                minimumChannelCount;
    Word                                maximumChannelCount;
    Percentage                          targetUtilization;
}
#if ( USERIF & CLI )
#endif
TimePeriodParameters;

    /*
     * SlotNumber:
     *
     * We use a SlotNumber to identify a particular slot in the system. A
     * SlotNumber is simply an integer, encapsulated in a structure for type
     * safety. A SlotNumber can represent three notions: o A physical slot in
     * the sytem, in which case its value is in the range
     * FIRST_SLOT_NUMBER..LAST_SLOT_NUMBER. Note that this value is NOT the
     * actual memory region of the slot. The memory region for a slot is
     * computed by subtracting FIRST_SLOT_NUMBER from the SlotNumber value. o
     * Any slot, in which case its value is SLOT_NUMBER_ANY. o No slot, in
     * which case its value is SLOT_NUMBER_NONE. The encapsulated value within
     * a SlotNumber which represents a physical slot (i.e., not SLOT_NUMBER_ANY
     * or SLOT_NUMBER_NONE), may be used, with suitable adjustment for the
     * value of FIRST_SLOT_NUMBER, as an index to an array of slot-related
     * information -- see SLOT_INDEX below.
     *
     *  slotNumber
     *
     *  shelfNumber TNT is a multi shelf system. To minimise the changes
     *                                  required to existing code the shelf
     *                                  number is added to this structure as it
     *                                  will almost always be needed when a
     *                                  slot number is needed.
     */
typedef struct slotnumber {
    Word                                slotNumber;
#if ( PLATFORM & TNT )
    Word                                shelfNumber;
#endif /* ( PLATFORM & TNT ) */
}
#if ( USERIF & CLI )
#endif
SlotNumber;

    /*
     * RelativePortNumber:
     *
     * When we are just interested in knowing the number of a host port within
     * its slot, we use a RelativePortNumber. As above, a RelativePortNumber is
     * simply a number, encapsulated in a structure for type safety. A
     * RelativePortNumber can represent three notions: o A physical port on a
     * slot, in which case its value is in the range
     * PORT_NUMBER_FIRST..MAX_PORTS_PER_SLOT. o Any port, in which case its
     * value is PORT_NUMBER_ANY. o No port, in which case its value is
     * PORT_NUMBER_NONE. As above, the encapsulated value within a
     * RelativePortNumber, except for PORT_NUMBER_NONE, is suitable for use as
     * an index to an array of information about the ports on a single slot
     * (again taking into account the one-based numbering and PORT_NUMBER_ANY).
     *
     *  relativePortNumber
     */
typedef struct st_relativePortNumber {
    Word                                relativePortNumber;
}
#if ( USERIF & CLI )
#endif
RelativePortNumber;

    /*
     * RectangularPortNumber:
     *
     * Occasionally it is more useful to identify a host port by its slot and
     * port number within its slot rather than by its number within all ports
     * in the system. For this form, we use a RectangularPortNumber, which
     * contains the SlotNumber and RelativePortNumber of the port. A
     * RectangularPortNumber can represent three notions: o A physical port on
     * the system, in which case the value of the slot number is in the range
     * FIRST_SLOT_NUMBER..LAST_SLOT_NUMBER and the value of the relative port
     * number is in the range PORT_NUMBER_FIRST..MAX_PORTS_PER_SLOT. o Any port
     * on a particular slot, in which case the value of the slot number is in
     * the range FIRST_SLOT_NUMBER..LAST_SLOT_NUMBER and the value of the
     * relative port number is PORT_NUMBER_ANY. o Any port, in which case the
     * value of the slot number is SLOT_NUMBER_ANY and the value of the
     * relative port number is PORT_NUMBER_ANY. The following notions CANNOT be
     * represented: o A particular port on any slot. o No port. Note that a
     * LinearPortNumber can be converted to a RectangularPortNumber and vice
     * versa, with some limitations, as described below. A
     * RectangularPortNumber should not be used except when a LinearPortNumber
     * will not do, for example: o When it is necessary to physically store the
     * slot number and relative port number in memory, so that they can be
     * pointed to, as is done in the user interface code.
     *
     *  slotNumber
     *
     *  relativePortNumber
     */
typedef struct rectangularPortNumber {
    SlotNumber                          slotNumber;
    RelativePortNumber                  relativePortNumber;
}
#if ( USERIF & CLI )
#endif
RectangularPortNumber;

    /*
     * RouteID:
     *
     * A RouteID is allocatedfor any active Route in the system. When a route
     * is destroyed, the RouteID is invalidated, and cannot be used.
     *
     *  id
     */
typedef struct _RouteID {
    Word                                id;
}
#if ( USERIF & CLI )
#endif
RouteID;

    /*
     * ThirdPromptSequence:
     *
     * Where the third-prompt appears in the login sequence: either before or
     * after user name & password.
     *
     *  THIRD_PROMPT_LAST
     *
     *  THIRD_PROMPT_FIRST
     */
typedef enum ThirdPromptSequence {
    THIRD_PROMPT_LAST,
    THIRD_PROMPT_FIRST
} ThirdPromptSequence;


static __inline__ Bool
validThirdPromptSequence (int x)
{
    switch (x) {
    case THIRD_PROMPT_LAST:
    case THIRD_PROMPT_FIRST:
        return TRUE;
    default:
        return FALSE;
    }
}

    /*
     * AuType:
     *
     * These constants values are mandated by the OSPF-IGP specifications.
     *
     *  OSPF_AUTH_TYPE_NONE No authentication.
     *
     *  OSPF_AUTH_TYPE_SIMPLE Simple authentication.
     *
     *  OSPF_AUTH_TYPE_MD5 MD5 authentication.
     */

#if ( MDF_OSPF == FYES )

typedef enum AuType {
    OSPF_AUTH_TYPE_NONE = 0,
    OSPF_AUTH_TYPE_SIMPLE,
    OSPF_AUTH_TYPE_MD5
} AuType;

#endif /* ( MDF_OSPF == FYES ) */

#if ( MDF_OSPF == FYES )



static __inline__ Bool
validAuType (int x)
{
    switch (x) {
    case OSPF_AUTH_TYPE_NONE:
    case OSPF_AUTH_TYPE_SIMPLE:
    case OSPF_AUTH_TYPE_MD5:
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* ( MDF_OSPF == FYES ) */

    /*
     * dataIdleMode:
     *
     * When can send either flags or all ones (marking). The
     *
     * MARK_TX:		tx idleLimit
     * MARK_RX:		rx idleLimit
     * MARK_RX_TX:	rx/tx idleLimit
     * MARK_NONE:	disable idleLimit
     * NUMBER_OF_IDLE_MODE
     */
typedef enum en_dataIdleMode {
    MARK_TX = 		0x1,
    MARK_RX = 		0x2,
    MARK_RX_TX = 	0x4,
    MARK_NONE =		0x8,
    NUMBER_OF_DATA_IDLE_MODE	= 0x100
} dataIdleMode;




#endif /* MIBGLOB_H */

