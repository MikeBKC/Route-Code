    /*
     * Notice: file generated by MIBMAKE from mibname.mdf
     * DO NOT EDIT THIS FILE!!!  Edit mibname.mdf
     */
#line 2 "mibname.mdf"
/*
 * SCCS ID:	$Id: mibname.h,v 1.1.1.1 2011/08/17 11:11:56 brwang Exp $
 *
 *      Copyright (c) 1995 UTT Technologies, Inc.
 *      All rights reserved.
 *      Use of copyright notice does not imply publication.
 *
 *
 *                      CONFIDENTIAL INFORMATION
 *                      ------------------------
 *      This Document contains Confidential Information or Trade Secrets,
 *      or both, which are the property of UTT Technologies, Inc.
 *      This document may not be copied, reproduced, reduced to any
 *      electronic medium or machine readable form or otherwise duplicated
 *      and the information herein may not be used, disseminated or
 *      otherwise disclosed, except with the prior written consent of
 *      UTT Technologies, Inc.
 */

#line 24 "mibname.mdf"

#if ! defined( MIBNAME_H )
#define MIBNAME_H

    /* This file contains the internal representation of the name & password
     * profile (MIB_PROF_NAME_PASS). The name of this profile is stored in
     * the global variable mibProfNamePassword.
     */

#define MAX_INREF_POLICY_COUNT 2
extern const char* const		mibProfNamePassword;

typedef enum en_user_type {
  NPW_NONE 		= 0x0,
  NPW_PASSWD 		= 0x1,
  NPW_DIALER 		= 0x2,
  NPW_ARP_STATIC 	= 0x4,
#if (DHCP_PLUS == FYES)
  NPW_DHCP_STATIC       = 0x8 | NPW_ARP_STATIC,
#else
  NPW_DHCP_STATIC 	= 0x8,
#endif
  NPW_NBNS_DB		= 0x10,
  NPW_IPSSG		= 0x20,
  NPW_IKE_PSK       	= 0x40,
  NPW_IKE_FQDN       	= 0x80,
  NPW_IKE_USER_FQDN     = 0x100,
  NPW_IKE_KEYID       	= 0x200,
  NPW_IKE_IPV4ADDR      = 0x400,
  NPW_IP_HOST	        = 0x800,
  NPW_MAC_HOST		= 0x1000,
# if ( XUANLIN_ALG == FYES )
  NPW_XL_URL		= 0x2000,
# endif
#if (PPPOE_SRV == FYES)
  NPW_PPPOE_STATIC	= 0x4000,	/* added by llliu for pppoe static ip allocation */
#endif

  NPW_DHCP_AUTOBIND     = 0x8000,	/* added by jfgu@090624*/

  NPW_TYPE_MAX   	= 0x40000000L,	/* user max type */
  NPW_USER_GROUP	= 0x80000000L,  /* group, not a single user */
  NPW_NEW_TYPE 		= 0x10000000L	//add by jyshen 060904	nat user

} NPW_TYPE;

typedef enum en_user_action {
  NPW_ACTION_NONE 	= 0x0,
  NPW_ACTION_PERMIT 	= 0x1,
  NPW_ACTION_DENY 	= 0x2,
  NPW_ACTION_FORWARD 	= 0x4,
  NPW_ACTION_DROP 	= 0x8,
  NPW_ACTION_LOG	= 0x10,
  NPW_ACTION_ACCT	= 0x20,
  NPW_ACTION_TAP       	= 0x40,
  NPW_ACTION_MAX   	= 0x40000000L
} NPW_ACTION;

typedef enum en_user_speed {
  NPW_SPEED_NOLIMIT 	= 0,
  NPW_SPEED_ZERO 	= 1,
  	NPW_SPEED_64Kbit 	= 64,
  	NPW_SPEED_128Kbit 	= 128,
  	NPW_SPEED_192Kbit 	= 192,
  	NPW_SPEED_256Kbit 	= 256,
  	NPW_SPEED_384Kbit 	= 384,
  	NPW_SPEED_512Kbit 	= 512,
  	NPW_SPEED_768Kbit 	= 768,
  NPW_SPEED_1Mbit	 	= 1024,
  NPW_SPEED_1_5Mbit	 	= 1536, // jschen: allow more speed
  	NPW_SPEED_2Mbit 		= 2048,
  	NPW_SPEED_3Mbit	 	= 3072,
  	NPW_SPEED_4Mbit	 	= 4096,
  	NPW_SPEED_5Mbit	 	= 5120,
  	NPW_SPEED_6Mbit	 	= 6144,
  	NPW_SPEED_7Mbit	 	= 7168,
  	NPW_SPEED_8Mbit	 	= 8192,
  	NPW_SPEED_9Mbit	 	= 9216,
  NPW_SPEED_10Mbit        = 10240,
  	NPW_SPEED_11Mbit        = 11264,
  	NPW_SPEED_12Mbit        = 12288,
  	NPW_SPEED_13Mbit        = 13312,
  	NPW_SPEED_14Mbit        = 14336,
  	NPW_SPEED_15Mbit        = 15360,
  	NPW_SPEED_16Mbit        = 16384,
  	NPW_SPEED_17Mbit        = 17408,
  	NPW_SPEED_18Mbit        = 18432,
  	NPW_SPEED_19Mbit        = 19456,
  NPW_SPEED_20Mbit        = 20480,
  	NPW_SPEED_21Mbit        = 21504,
  	NPW_SPEED_22Mbit        = 22528,
  	NPW_SPEED_23Mbit        = 23552,
  	NPW_SPEED_24Mbit        = 24576,
  	NPW_SPEED_25Mbit        = 25600,
  	NPW_SPEED_26Mbit        = 26624,
  	NPW_SPEED_27Mbit        = 27648,
  	NPW_SPEED_28Mbit        = 28672,
  	NPW_SPEED_29Mbit        = 29696,
  NPW_SPEED_30Mbit        = 30720,
  	NPW_SPEED_31Mbit        = 31744,
  	NPW_SPEED_32Mbit        = 32768,
  	NPW_SPEED_33Mbit        = 33792,
  	NPW_SPEED_34Mbit        = 34816,
  	NPW_SPEED_35Mbit        = 35840,
  	NPW_SPEED_36Mbit        = 36864,
  	NPW_SPEED_37Mbit        = 37888,
  	NPW_SPEED_38Mbit        = 38912,
  	NPW_SPEED_39Mbit        = 39936,
  NPW_SPEED_40Mbit        = 40960,
  	NPW_SPEED_41Mbit        = 41984,
  	NPW_SPEED_42Mbit        = 43008,
  	NPW_SPEED_43Mbit        = 44032,
  	NPW_SPEED_44Mbit        = 45056,
  	NPW_SPEED_45Mbit        = 46080,
  	NPW_SPEED_46Mbit        = 47104,
  	NPW_SPEED_47Mbit        = 48128,
  	NPW_SPEED_48Mbit        = 49152,
  	NPW_SPEED_49Mbit        = 50176,
  NPW_SPEED_50Mbit        = 51200,
  	NPW_SPEED_51Mbit        = 52224,
        NPW_SPEED_52Mbit        = 53248,
        NPW_SPEED_53Mbit        = 54272,
        NPW_SPEED_54Mbit        = 55296,
        NPW_SPEED_55Mbit        = 56320,
        NPW_SPEED_56Mbit        = 57344,
        NPW_SPEED_57Mbit        = 58368,
        NPW_SPEED_58Mbit        = 59392,
        NPW_SPEED_59Mbit        = 60416,
  NPW_SPEED_60Mbit        = 61440,
        NPW_SPEED_61Mbit        = 62464,
        NPW_SPEED_62Mbit        = 63488,
        NPW_SPEED_63Mbit        = 64512,
        NPW_SPEED_64Mbit        = 65536,
        NPW_SPEED_65Mbit        = 66560,
        NPW_SPEED_66Mbit        = 67584,
        NPW_SPEED_67Mbit        = 68608,
        NPW_SPEED_68Mbit        = 69632,
        NPW_SPEED_69Mbit        = 70656,
  NPW_SPEED_70Mbit        = 71680,
        NPW_SPEED_71Mbit        = 72704,
        NPW_SPEED_72Mbit        = 73728,
        NPW_SPEED_73Mbit        = 74752,
        NPW_SPEED_74Mbit        = 75776,
        NPW_SPEED_75Mbit        = 76800,
        NPW_SPEED_76Mbit        = 77824,
        NPW_SPEED_77Mbit        = 78848,
        NPW_SPEED_78Mbit        = 79872,
        NPW_SPEED_79Mbit        = 80896,
  NPW_SPEED_80Mbit        = 81920,
        NPW_SPEED_81Mbit        = 82944,
        NPW_SPEED_82Mbit       = 83968,
        NPW_SPEED_83Mbit        = 84992,
        NPW_SPEED_84Mbit        = 86016,
        NPW_SPEED_85Mbit        = 87040,
        NPW_SPEED_86Mbit        = 88064,
        NPW_SPEED_87Mbit        = 89088,
        NPW_SPEED_88Mbit        = 90112,
        NPW_SPEED_89Mbit        = 91136,
  NPW_SPEED_90Mbit        = 92160,
        NPW_SPEED_91Mbit        = 93184,
        NPW_SPEED_92Mbit        = 94208,
        NPW_SPEED_93Mbit        = 95232,
        NPW_SPEED_94Mbit        = 96256,
        NPW_SPEED_95Mbit        = 97280,
        NPW_SPEED_96Mbit        = 98304,
        NPW_SPEED_97Mbit        = 99328,
        NPW_SPEED_98Mbit        = 100352,
        NPW_SPEED_99Mbit        = 101376,
  NPW_SPEED_100Mbit       = 102400,
  NPW_SPEED_MAX   	= 0x40000000L
} NPW_SPEED;


#if (SWITCHFUN == FYES)   /*add by zgd*/
typedef enum en_mirr_filter{
  NPW_MON_ALL = 0,
  NPW_MON_SAMAC = 1,
  NPW_MON_DAMAC = 2
} NPW_FILTER;

typedef enum en_mirr_att{
  NPW_MIRR_NORMAL = 0,
  NPW_MIRR_MONED = 1,
  NPW_MIRR_MON = 2
} NPW_MIRRATT;

typedef enum en_mirr_dir{
  NPW_MIRR_INOUT = 0,
  NPW_MIRR_IN = 1,
  NPW_MIRR_OUT = 2
} NPW_MIRRDIR;

typedef enum en_trunk_num{
  NPW_TRUNK_NOM = 0,
  NPW_TRUNK_TK1 = 1,
  NPW_TRUNK_TK2 = 2
} NPW_TRUNKNUM;

typedef enum en_trunk_mod{
  NPW_TRUNK_SA = 0,
  NPW_TRUNK_DA = 1,
  NPW_TRUNK_SADA = 2
} NPW_TRUNKMOD;

typedef enum en_inspeed_mod{
  NPW_INSPEED_NON = 0,
  NPW_INSPEED_ALL = 1,
  NPW_INSPEED_BRO = 2,
  NPW_INSPEED_BRML = 3,
  NPW_INSPEED_DLF = 4
} NPW_INSPEEDMOD;

#if (TAGVlAN == FYES)
typedef enum en_vlan_mode{
  NPW_VLAN_NONE = 0,
  NPW_VLAN_PORT = 1,
  NPW_VLAN_TAG = 2
} NPW_VLANMODE;

typedef enum en_vlan_commode{
  NPW_VLAN_COMNONE = 0,
  NPW_VLAN_ARGENT = 1,
  NPW_VLAN_ROUTE = 2
} NPW_VLANCOMMODE;

typedef enum en_vlan_phynum{
  NPW_VLAN_LAN = 0,
  NPW_VLAN_WAN1 = 1,
  NPW_VLAN_WAN2 = 2,
  NPW_VLAN_WAN3 = 3,
  NPW_VLAN_WAN4 = 4,
} NPW_PHYNUM;

typedef enum en_vlan_type{
  NPW_VLAN_TYPNONE = 0,
  NPW_VLAN_SUPER = 1,
  NPW_VLAN_SUB = 2
} NPW_VLANTYPE;

typedef enum en_vlan_tagin{
  NPW_VLAN_EX = 0,
  NPW_VLAN_INC = 1
} NPW_VLANTAGIN;

typedef enum en_vlan_tagout{
  NPW_VLAN_TAGGED = 0,
  NPW_VLAN_UNTAG = 1
} NPW_VLANTAGOUT;
#endif

typedef enum en_pri_mod{
  NPW_PRI_NONE = 0,
  NPW_PRI_PORT = 1,
  NPW_PRI_8021P = 2,
  NPW_PRI_DSCP = 3
} NPW_PRIMODE;

typedef enum en_pri_rule{
  NPW_PRI_SCALE = 0,
  NPW_PRI_FIX = 1
} NPW_PRIRULE;

typedef enum en_pri_value{
  NPW_PRI_LOWEST = 0,
  NPW_PRI_LOWER = 1,
  NPW_PRI_HIGHER = 2,
  NPW_PRI_HIGHEST = 3
} NPW_PRIVALUE;

typedef enum en_portmac_type{
  NPW_PORTMAC_NONE = 0,
  NPW_PORTMAC_STATIC = 1,
  NPW_PORTMAC_FILTER = 2,
  NPW_PORTMAC_MULTI = 3
} NPW_PORTMACTYPE;

typedef enum en_portmac_portin{
  NPW_PORTMAC_EX = 0,
  NPW_PORTMAC_INC = 1
} NPW_PORTMACPORTIN;

# endif



typedef struct st_arpStatic {
    char                                userGroup[ MAX_PROFILE_NAME_LENGTH + 1 ];
    IpAddress				ipAddr;
    Uint8				macAddr[ETHER_ADDR_LEN];
} ArpStaticEntry;

typedef struct st_dhcpStatic {
    char                                userGroup[ MAX_PROFILE_NAME_LENGTH + 1 ];
    IpAddress				ipAddr;
    Uint8				macAddr[ETHER_ADDR_LEN];
} DhcpStaticEntry;

typedef struct st_ipssgUser {
    char                                userGroup[ MAX_PROFILE_NAME_LENGTH + 1 ];
    IpAddress                           sourceAddrFrom;
    IpAddress                           sourceAddrTo;
    IpAddress                           destAddrFrom;
    IpAddress                           destAddrTo;
} IpssgUserEntry;

typedef union un_userUnion {

} UserUnion;

#if(DHCP_PLUS == FYES)
#include "mibdhcp.h"
#endif

    /*
     * NamePasswordProfile:
     *
     * A NamePasswordProfile contains the information required for simple name
     * and password login validation. These profiles are a very small subset of
     * Connection profiles.
     *
     *  active TRUE if the name/password entry is active.
     *
     *  hostName The name of the host that is asking for validation.
     *
     *  recvPassword The password of the host that is asking for validation.
     *
     *  connProfNum Connection Profile number to use as a template
     * 
     *  connProfile Connection Profile name to use as a template;
     */

# if ( XUANLIN_ALG == FYES )
# define XL_URL_LENGTH	128
# endif
#include "mibsys1.h"

typedef struct st_namePasswordProfile {
#line 62 "mibname.mdf"
    char                                hostName[ MAX_HOST_NAME_LENGTH + 1 ];
    Boolean                             active;
    char                                description[MAX_PROFILE_NAME_LENGTH + 1];
#line 66 "mibname.mdf"

    NPW_TYPE				userType;
    NPW_TYPE				userFeature;

    NPW_ACTION				userAction;
#if(DOT1X == YES)
	Boolean				dot1x_enable;
	Boolean				dot1x_acct_enable;
	Uint32				dot1x_max_user;
	Uint32				dot1x_port;
#endif
    char                                userGroup[ MAX_PROFILE_NAME_LENGTH + 1 ];
#line 70 "mibname.mdf"
    char                                sendName[ MAX_HOST_NAME_LENGTH + 1 ];
    char                                sendPassword[ MAX_PASSWORD_LENGTH + 1 ];
    char                                recvPassword[ MAX_PASSWORD_LENGTH + 1 ];
#line 74 "mibname.mdf"
# if ( XUANLIN_ALG == FYES )
    char				xlUrl[XL_URL_LENGTH+1];
# endif
    Uint16                              connProfNum;
    char                                connProfile[ MAX_HOST_NAME_LENGTH + 1 ];

    char                                tmrgProfile[ MAX_PROFILE_NAME_LENGTH + 1 ];

    char                                inFilterProfile[ MAX_PROFILE_NAME_LENGTH + 1 ];
    char                                outFilterProfile[ MAX_PROFILE_NAME_LENGTH + 1 ];

    Uint32				ipPoolIndex;

    IpAddress				ipAddr;
    Uint8				macAddr[ETHER_ADDR_LEN];
#if(DHCP_PLUS == FYES)
    char   				RemoteID[MAX_REMOTEID_LEN];
    char   				ClientID[MAX_CLIENTID_LEN];
    char				dhcpPoolname[MAX_PROFILE_NAME_LENGTH + 1];
#endif
    char                                NbNsName[ MAX_HOST_NAME_LENGTH + 1 ];

//  Uint32				vlanId;
#if (SWITCHFUN == FYES)   /*add by zgd */
    Uint16        			vlanId;
    Uint8                               ifnumId;
#else
    Uint16        			vlanId;
#endif
    Uint32				portId;
    Uint32				switchId;
    Uint32				domainId;

    NPW_SPEED				maxRxRate;
    NPW_SPEED				maxTxRate;

    Uint32				maxRxPkt;
    Uint32				maxTxPkt;

    Uint32				maxRxSession;
    Uint32				maxRxUdpSession;
    Uint32				maxRxTcpSession;
    Uint32				maxRxIcmpSession;

    Uint32				maxTxSession;
    Uint32				maxTxUdpSession;
    Uint32				maxTxTcpSession;
    Uint32				maxTxIcmpSession;

    Uint32				maxTxQuota;
    Uint32				maxTxUdpQuota;
    Uint32				maxTxTcpQuota;
    Uint32				maxTxIcmpQuota;

    Uint32				maxRxQuota;
    Uint32				maxRxUdpQuota;
    Uint32				maxRxTcpQuota;
    Uint32				maxRxIcmpQuota;

    Uint32				maxDuration;

# if ( TC_DRR == FYES ) && 0
// zhz@20050616, added for ipCredit DRR(Deficit Round Robbin) */
    Int32                               ipMacRate;
    Uint32                              ipCreditDRR;
    Uint32                              ipCreditDRR2; // jschen: add this member for the sake of tx
    Uint32                              ipCreditDefault; 
    Uint32                              ipCreditOverflow; 
    Uint32                              ipCreditOverflowTx; // jschen: add this member, for the sake of tx. 
    Int32                               ipCreditUnderflow;
    Uint32                              ipRedDuration;
# endif /* ( TC_DRR == FYES ) */

    Uint32				rt_nextif;
    Uint32				rt_nexthop;
    Uint8				rt_macAddr[ETHER_ADDR_LEN];
#if ( MDF_VROUTER == FYES )
    char                                vRouterName[ MAX_NAME_LEN + 1 ];
    char                                interVRouterName[ MAX_NAME_LEN + 1 ];
#endif /* ( MDF_VROUTER == FYES ) */
#if ( MDF_IP == FYES )
    IpAddress                           sourceAddrFrom;
#endif /* ( MDF_IP == FYES ) */
#if ( MDF_IP == FYES )
    IpAddress                           sourceAddrTo;
#endif /* ( MDF_IP == FYES ) */
#if ( MDF_IP == FYES )
    IpAddress                           destAddrFrom;
#endif /* ( MDF_IP == FYES ) */
#if ( MDF_IP == FYES )
    IpAddress                           destAddrTo;
#endif /* ( MDF_IP == FYES ) */
Boolean                             individuation;		//add by jyshen 060904
Boolean                             group_indi;		
char 					nick[ MAX_NAME_LEN + 1 ];			//add by jyshen 060904
Uint32 					ipCreditOverflow;
Uint32 					ipCreditOverflowTx;	//jschen: added for the sake of tx
Uint32 					ipCreditDRR;		//add by jyshen 060904
Uint32 					ipCreditDRR2;		//jschen: added, for the sake of tx

//NPW_SPEED 				ingressBPS;		//add by jyshen 060904
//NPW_SPEED 				egressBPS;		//add by jyshen 060904
/*add by jyshen 060905*/
p2pCheckType			antiP2p;
Boolean				antiP2pEnabled;
IMCheckType				antiIM;
Boolean				antiQQEnabled;
Boolean				antiMsnEnabled;
Uint8                            policyName[MAX_INREF_POLICY_COUNT][MAX_PROFILE_NAME_LENGTH +1];
Uint8                            noLimitGroup[MAX_PROFILE_NAME_LENGTH +1];
Uint32                          pdbPolicy;//added by brwang for pdb can auto show in web
/*end jyshen*/
}
#if ( USERIF & CLI )
__PACK__
#endif
NamePasswordProfile;
#line 101 "mibname.mdf"

#endif /* MIBNAME_H */

