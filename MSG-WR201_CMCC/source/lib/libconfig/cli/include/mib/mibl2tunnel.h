    /*
     * Notice: file generated by MIBMAKE from mibl2tunnel.mdf
     * DO NOT EDIT THIS FILE!!!  Edit mibl2tunnel.mdf
     */
#line 3 "mibl2tunnel.mdf"
/*
 * $Id: mibl2tunnel.h,v 1.1.1.1 2011/08/17 11:11:56 brwang Exp $
 *
 *      Copyright (c) 1997 UTT Technologies, Inc.
 *      All rights reserved.
 *      Use of copyright notice does not imply publication.
 *
 *
 *                      CONFIDENTIAL INFORMATION
 *                      ------------------------
 *      This Document contains Confidential Information or Trade Secrets,
 *      or both, which are the property of UTT Technologies, Inc.
 *      This document may not be copied, reproduced, reduced to any
 *      electronic medium or machine readable form or otherwise duplicated
 *      and the information herein may not be used, disseminated or
 *      otherwise disclosed, except with the prior written consent of
 *      UTT Technologies, Inc.
 */

#line 34 "mibl2tunnel.mdf"

#if ! defined( MIBL2TUNNEL_H )
# define MIBL2TUNNEL_H

# if ( Q_L2_TUNNEL )

#  include "mibglob.h"
#  include "mibfld.h"

    /*
     * Set to FYES enables some future extensions for the Layer 2 tunnel profile.
     * It should be set to FNO for now.
     */
#  define MIB_L2TUNNEL_EXTENSIONS		FNO


/*****************************************************************/

/*
 * This file contains the internal representation of the TUNNEL-SERVER
 * profiles (MIB_PROF_TUNNEL_SERVER). The name of these profiles is stored
 * in the following global variable:
 */
extern const char * const		mibProfTunnelServer;

/*****************************************************************/

/*
 * This file contains the internal representation of the L2-TUNNEL-GLOBAL
 * profile (MIB_PROF_L2_TUNNEL_GLOBAL). The name of this profile is stored
 * in the following global variable:
 */
extern const char * const		mibProfL2TunnelGlobal;

/*****************************************************************/

    /*
     * The field number of the index to the MIB_PROF_TUNNEL_SERVER profile.
     */
#define MIB_TUNNEL_SERVER_INDEX_FIELD  	1


    /*
     * Field parameters for various fields and enums.
     */
#if ( USERIF & CLI )

extern const MibFieldEnumParams		l2tpModeParams;

#endif /* ( USERIF & CLI ) */



    /*
     * L2tpMode:
     *
     * L2TP Modes:
     *
     *  L2TP_DISABLED L2TP is disabled.
     *
     *  L2TP_LAC_MODE This unit is configured to be a L2TP Access Controller.
     *
     *  L2TP_LNS_MODE This unit is configured to be a L2TP Network Server.
     *
     *  L2TP_BOTH_MODE This unit is configured to be both a LAC and a LNS.
     */
typedef enum L2tpMode {
#line 123 "mibl2tunnel.mdf"
    L2TP_DISABLED = 0,
#line 126 "mibl2tunnel.mdf"
    L2TP_LAC_MODE = 1,
#line 129 "mibl2tunnel.mdf"
#if ( ! Q_TNT )
    L2TP_LNS_MODE = 2,
#endif /* ( ! Q_TNT ) */
#line 133 "mibl2tunnel.mdf"
#if ( ! Q_TNT )
    L2TP_BOTH_MODE = L2TP_LAC_MODE+L2TP_LNS_MODE
#endif /* ( ! Q_TNT ) */
} L2tpMode;


    /*
     * L2tpTransportMode:
     *
     * L2TP TransportModes:
     *
     *  L2TP_DISABLED L2TP is disabled.
     *
     *  L2TP_LAC_MODE This unit is configured to be a L2TP Access Controller.
     *
     *  L2TP_LNS_MODE This unit is configured to be a L2TP Network Server.
     *
     *  L2TP_BOTH_MODE This unit is configured to be both a LAC and a LNS.
     */

typedef enum _l2tpTransMode {
    L2TP_TRANS_NORMAL = 0x1,
    L2TP_TRANS_PRESERVE = 0x2,
    L2TP_TRANS_DUP = 0x4,
    L2TP_TRANS_DISCOVER = 0x8,
    L2TP_TRANS_MAX
} L2tpTransportMode;

static __inline__ Bool
validL2tpMode (int x)
{
    switch (x) {
#line 123 "mibl2tunnel.mdf"
    case L2TP_DISABLED:
#line 126 "mibl2tunnel.mdf"
    case L2TP_LAC_MODE:
#line 129 "mibl2tunnel.mdf"
#if ( ! Q_TNT )
    case L2TP_LNS_MODE:
#endif /* ( ! Q_TNT ) */
#line 133 "mibl2tunnel.mdf"
#if ( ! Q_TNT )
    case L2TP_BOTH_MODE:
#endif /* ( ! Q_TNT ) */
        return TRUE;
    default:
        return FALSE;
    }
}

typedef enum PptpMode {
    PPTP_DISABLED = 0,
    PPTP_PNS_MODE = 1,
#if ( ! Q_TNT )
    PPTP_PAC_MODE = 2,
#endif /* ( ! Q_TNT ) */
#if ( ! Q_TNT )
    PPTP_BOTH_MODE = PPTP_PNS_MODE + PPTP_PAC_MODE,
#endif /* ( ! Q_TNT ) */
} PptpMode;

    /*
     * L2TunnelBearerType:
     *
     * This enumeration indicates the bearer types allowed for the tunnel.
     *
     *  L2_TUNNEL_BEARER_ALL All calls are allowed.
     *
     *  L2_TUNNEL_BEARER_ANALOG Allow analog calls only.
     *
     *  L2_TUNNEL_BEARER_DIGITAL Allow digital calls only.
     */

#if (MIB_L2TUNNEL_EXTENSIONS == FYES)

typedef enum L2TunnelBearerType {
#line 146 "mibl2tunnel.mdf"
    L2_TUNNEL_BEARER_ALL,
#line 149 "mibl2tunnel.mdf"
    L2_TUNNEL_BEARER_ANALOG,
#line 152 "mibl2tunnel.mdf"
    L2_TUNNEL_BEARER_DIGITAL
} L2TunnelBearerType;

#endif /* (MIB_L2TUNNEL_EXTENSIONS == FYES) */

#if (MIB_L2TUNNEL_EXTENSIONS == FYES)



static __inline__ Bool
validL2TunnelBearerType (int x)
{
    switch (x) {
#line 146 "mibl2tunnel.mdf"
    case L2_TUNNEL_BEARER_ALL:
#line 149 "mibl2tunnel.mdf"
    case L2_TUNNEL_BEARER_ANALOG:
#line 152 "mibl2tunnel.mdf"
    case L2_TUNNEL_BEARER_DIGITAL:
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* (MIB_L2TUNNEL_EXTENSIONS == FYES) */

    /*
     * L2TunnelGlobal:
     *
     * This profile contains Layer 2 tunnel parameters that affect the whole
     * system.
     *
     *  pptpMode Enables or disables support for the Point to Point
     *                                  Tunneling Protocol (PPTP).
     *
     *  serverProfileRequired When set to 'YES', it requires that an enabled
     *                                  L2-TUNNEL-SERVER profile exists before
     *                                  a tunnel is created. When set to 'NO',
     *                                  if a matching profile can't be found,
     *                                  the server is assumed enabled and the
     *                                  tunnel can be created.
     *
     *  l2tpMode Layer 2 Tunneling Protocol operating mode.
     *
     *  l2tpAuthEnabled Enables or disables L2TP tunnel authentication.
     *
     *  l2tpRxWindow This value is the advertised L2TP receive window size for
     *                                  the data channel. A value of zero
     *                                  indicates that this box will ask for no
     *                                  flow control for inbound L2TP payloads.
     *
     *  maxLnsClients The maximum number of clients that this box is allowed to
     *                                  support in LNS mode.
     */

#if (( MDF_PPTP == FYES ) || ( MDF_L2TP == FYES ))

typedef struct l2TunnelGlobal {
#line 229 "mibl2tunnel.mdf"
#if ( MDF_PPTP == FYES )
    PptpMode                            pptpMode;
#endif /* ( MDF_PPTP == FYES ) */
#line 235 "mibl2tunnel.mdf"
#if ( MDF_PPTP == FYES )
    Boolean                             serverProfileRequired;
#endif /* ( MDF_PPTP == FYES ) */
#line 243 "mibl2tunnel.mdf"
#if ( MDF_L2TP == FYES )
    L2tpMode                            l2tpMode;
#endif /* ( MDF_L2TP == FYES ) */
#line 248 "mibl2tunnel.mdf"
#if ( MDF_L2TP == FYES )
    Boolean                             l2tpAuthEnabled;
#endif /* ( MDF_L2TP == FYES ) */
#line 253 "mibl2tunnel.mdf"
#if ( MDF_L2TP == FYES )
    Uint16                              l2tpRxWindow;
#endif /* ( MDF_L2TP == FYES ) */
#line 261 "mibl2tunnel.mdf"
#if ( MIB_L2TUNNEL_EXTENSIONS == FYES ) && ( MDF_L2TP == FYES )
    Uint16                              maxLnsClients;
#endif /* ( MIB_L2TUNNEL_EXTENSIONS == FYES ) && ( MDF_L2TP == FYES ) */
}
#if ( USERIF & CLI )
__PACK__
#endif
L2TunnelGlobal;

#endif /* (( MDF_PPTP == FYES ) || ( MDF_L2TP == FYES )) */

    /*
     * TunnelServer:
     *
     * A tunnel profile describes a tunnel server.
     *
     *  serverEndPoint The name of the remote tunnel endpoint. It should be the
     *                                  hostname or IP address that identifies
     *                                  the remote tunnel server, as required
     *                                  by the specific tunnel protocol.
     *                                  Usually, it matches the
     *                                  'Tunnel-Server-Endpoint' RADIUS
     *                                  attribute but it may be different.
     *
     *  enabled A tunnel server can be disabled by setting this field to 'no'.
     *
     *  sharedSecret The shared secret (password) needed to bring up an L2TP
     *                                  Control Channel with this server.
     *
     *  maxClients The maximum number of clients that this tunnel may carry.
     *
     *  validBearerType The valid call types that can be carried on this
     *                                  tunnel.
     */
typedef struct tunnelServer {
#line 282 "mibl2tunnel.mdf"
    char                                serverEndPoint[ MAX_HOST_NAME_LENGTH + 1 ];
#line 290 "mibl2tunnel.mdf"
    Boolean                             enabled;
#line 295 "mibl2tunnel.mdf"
#if ( MDF_L2TP == FYES )
    char                                sharedSecret[ MAX_PASSWORD_LENGTH + 2 ];
#endif /* ( MDF_L2TP == FYES ) */
#line 303 "mibl2tunnel.mdf"
#if ( MIB_L2TUNNEL_EXTENSIONS == FYES )
    Uint16                              maxClients;
#endif /* ( MIB_L2TUNNEL_EXTENSIONS == FYES ) */
#line 309 "mibl2tunnel.mdf"
#if ( MIB_L2TUNNEL_EXTENSIONS == FYES )
    L2TunnelBearerType                  validBearerType;
#endif /* ( MIB_L2TUNNEL_EXTENSIONS == FYES ) */
}
#if ( USERIF & CLI )
__PACK__
#endif
TunnelServer;
#line 488 "mibl2tunnel.mdf"

/*****************************************************************/
/*
 *  mibFactoryL2TunnelGlobal:
 *
 *  Creates the factory instance of the Layer 2 tunnel global options profile.
 */
extern ConstPtr
mibFactoryL2TunnelGlobal( MibProfileType	mibType,
			  ConstPtr		mibIndex,
			  Int			mibIndexLen );
/*
 *  mibFactoryTunnelServer:
 *
 *  Creates the factory instance of a tunnel profile.
 */
extern ConstPtr
mibFactoryTunnelServer( MibProfileType		mibType,
			ConstPtr		mibIndex,
			Int			mibIndexLen );

# endif /* ( Q_L2_TUNNEL ) */

#endif /* MIBL2TUNNEL_H */

