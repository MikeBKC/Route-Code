    /*
     * Notice: file generated by MIBMAKE from mibx25.mdf
     * DO NOT EDIT THIS FILE!!!  Edit mibx25.mdf
     */
#line 2 "mibx25.mdf"
/*
 * $Id: mibx25.h,v 1.1.1.1 2011/08/17 11:11:56 brwang Exp $
 *
 *      Copyright (c) 1995 UTT Technologies, Inc.
 *      All rights reserved.
 *      Use of copyright notice does not imply publication.
 *
 *
 *                      CONFIDENTIAL INFORMATION
 *                      ------------------------
 *      This Document contains Confidential Information or Trade Secrets,
 *      or both, which are the property of UTT Technologies, Inc.
 *      This document may not be copied, reproduced, reduced to any
 *      electronic medium or machine readable form or otherwise duplicated
 *      and the information herein may not be used, disseminated or
 *      otherwise disclosed, except with the prior written consent of
 *      UTT Technologies, Inc.
 */

#line 24 "mibx25.mdf"

#if ! defined( MIBX25_H )
#define MIBX25_H

    /* This file contains the internal representation of the X.25
     * profile (MIB_PROF_X25). The name of this profile is stored in the
     * global variable mibProfX25.
     */

extern const char* const		mibProfX25;


    /*
     * PktYesNoEnum:
     *
     *
     *  PKT_NO
     *
     *  PKT_YES
     */
typedef enum PktYesNoEnum {
#line 40 "mibx25.mdf"
    PKT_NO,
#line 41 "mibx25.mdf"
    PKT_YES
} PktYesNoEnum;


static __inline__ Bool
validPktYesNoEnum (int x)
{
    switch (x) {
#line 40 "mibx25.mdf"
    case PKT_NO:
#line 41 "mibx25.mdf"
    case PKT_YES:
        return TRUE;
    default:
        return FALSE;
    }
}

    /*
     * PktOptionsEnum:
     *
     * This options determines whether packet and window size (NPWS) are to be
     * negotiated, and whether addresses and facilities (AFNA) are allowed in
     * clear request. Combination of both is possible.
     *
     *  PKT_OPT_NONE
     *
     *  PKT_OPT_NPWS
     *
     *  PKT_OPT_AFNA
     *
     *  PKT_OPT_NPWS_AFNA
     */
typedef enum PktOptionsEnum {
#line 51 "mibx25.mdf"
    PKT_OPT_NONE,
#line 52 "mibx25.mdf"
    PKT_OPT_NPWS,
#line 53 "mibx25.mdf"
    PKT_OPT_AFNA,
#line 54 "mibx25.mdf"
    PKT_OPT_NPWS_AFNA
} PktOptionsEnum;


static __inline__ Bool
validPktOptionsEnum (int x)
{
    switch (x) {
#line 51 "mibx25.mdf"
    case PKT_OPT_NONE:
#line 52 "mibx25.mdf"
    case PKT_OPT_NPWS:
#line 53 "mibx25.mdf"
    case PKT_OPT_AFNA:
#line 54 "mibx25.mdf"
    case PKT_OPT_NPWS_AFNA:
        return TRUE;
    default:
        return FALSE;
    }
}

    /*
     * PktSizeNegoEnum:
     *
     * This param specifies the packet size max/min in negotiation. Range is
     * from 64 bytes to 1024 bytes in increments power of 2: ie: 64, 128, 256,
     * 512, 1024, 2048, 4096
     *
     *  PKT_MSZ_64
     *
     *  PKT_MSZ_128
     *
     *  PKT_MSZ_256
     *
     *  PKT_MSZ_512
     *
     *  PKT_MSZ_1024
     *
     *  PKT_MSZ_2048
     *
     *  PKT_MSZ_4096
     */
typedef enum PktSizeNegoEnum {
#line 64 "mibx25.mdf"
    PKT_MSZ_64 = 6,
#line 65 "mibx25.mdf"
    PKT_MSZ_128,
#line 66 "mibx25.mdf"
    PKT_MSZ_256,
#line 67 "mibx25.mdf"
    PKT_MSZ_512,
#line 68 "mibx25.mdf"
    PKT_MSZ_1024,
#line 69 "mibx25.mdf"
    PKT_MSZ_2048,
#line 70 "mibx25.mdf"
    PKT_MSZ_4096
} PktSizeNegoEnum;


static __inline__ Bool
validPktSizeNegoEnum (int x)
{
    switch (x) {
#line 64 "mibx25.mdf"
    case PKT_MSZ_64:
#line 65 "mibx25.mdf"
    case PKT_MSZ_128:
#line 66 "mibx25.mdf"
    case PKT_MSZ_256:
#line 67 "mibx25.mdf"
    case PKT_MSZ_512:
#line 68 "mibx25.mdf"
    case PKT_MSZ_1024:
#line 69 "mibx25.mdf"
    case PKT_MSZ_2048:
#line 70 "mibx25.mdf"
    case PKT_MSZ_4096:
        return TRUE;
    default:
        return FALSE;
    }
}

    /*
     * PktDteFlagEnum:
     *
     * This param specifies whether we want to behave like a DTE or a DCE
     *
     *  PKT_DCE
     *
     *  PKT_DTE
     */
typedef enum PktDteFlagEnum {
#line 78 "mibx25.mdf"
    PKT_DCE,
#line 79 "mibx25.mdf"
    PKT_DTE
} PktDteFlagEnum;


static __inline__ Bool
validPktDteFlagEnum (int x)
{
    switch (x) {
#line 78 "mibx25.mdf"
    case PKT_DCE:
#line 79 "mibx25.mdf"
    case PKT_DTE:
        return TRUE;
    default:
        return FALSE;
    }
}

    /*
     * PktNetTypeEnum:
     *
     * This param specifies the network type
     *
     *  PKT_CCITT
     *
     *  PKT_DDN
     */
typedef enum PktNetTypeEnum {
#line 86 "mibx25.mdf"
    PKT_CCITT,
#line 87 "mibx25.mdf"
    PKT_DDN
} PktNetTypeEnum;


static __inline__ Bool
validPktNetTypeEnum (int x)
{
    switch (x) {
#line 86 "mibx25.mdf"
    case PKT_CCITT:
#line 87 "mibx25.mdf"
    case PKT_DDN:
        return TRUE;
    default:
        return FALSE;
    }
}

    /*
     * FrmDiscModeEnum:
     *
     * This param specifies the Disconnect mode: PASSIVE: link layer come up
     * sending SABM. ACTIVE: link layer come up sending DISC.
     *
     *  FRM_PASSIVE
     *
     *  FRM_ACTIVE
     */
typedef enum FrmDiscModeEnum {
#line 97 "mibx25.mdf"
    FRM_PASSIVE,
#line 98 "mibx25.mdf"
    FRM_ACTIVE
} FrmDiscModeEnum;


static __inline__ Bool
validFrmDiscModeEnum (int x)
{
    switch (x) {
#line 97 "mibx25.mdf"
    case FRM_PASSIVE:
#line 98 "mibx25.mdf"
    case FRM_ACTIVE:
        return TRUE;
    default:
        return FALSE;
    }
}

    /*
     * FrmSeqNumberEnum:
     *
     * This param specifies the Sequence Number mode format: NORMAL: link layer
     * uses normal (modulo 8) sequence numbers. EXTENDED: link layer uses
     * extended (modulo 128)sequence numbers.
     *
     *  FRM_NORMAL
     *
     *  FRM_EXTENDED
     */
typedef enum FrmSeqNumberEnum {
#line 107 "mibx25.mdf"
    FRM_NORMAL,
#line 108 "mibx25.mdf"
    FRM_EXTENDED
} FrmSeqNumberEnum;


static __inline__ Bool
validFrmSeqNumberEnum (int x)
{
    switch (x) {
#line 107 "mibx25.mdf"
    case FRM_NORMAL:
#line 108 "mibx25.mdf"
    case FRM_EXTENDED:
        return TRUE;
    default:
        return FALSE;
    }
}

    /*
     * X25Profile:
     *
     * The X.25 information:
     *
     *  x25Name Name of the X.25 profile.
     *
     *  active Indicates whether this profile is to be included in the X.25
     *                                  table.
     *
     *  kludge This is a kludge to indicate that the physical line is to be
     *                                  brought down before connecting. It is
     *                                  also used for outsequence on a reset.
     *                                  This byte formally a fill.
     *
     *  nailedUpGroup Specifies the nailed group number.
     *
     *  nailedMode Specifies whether it is a nailed or switched.
     *
     *  calledNumberType Indication of whether national national number,
     *                                  international number, etc. is
     *                                  specified.
     *
     *  switchedCallType Type of bearer channel capability to set up for each
     *                                  switched call in the session.
     *
     *  phoneNumber The phonenumber of the named host.
     *
     *  billingNumber A number used for billing purposes.
     *
     *  transitNumber The string for use in the 'transit network ie' for PRI
     *                                  calling when going through a LEC.
     *
     *  callByCallID Id for the call-by-call signalling for PRI.
     *
     *  T1Val LAPB T1 Timer.
     *
     *  T2Val LAPB T2 Timer.
     *
     *  N2Val LAPB N2 Val.
     *
     *  kVal LAPB Wibdow size.
     *
     *  pktWindow X.25 Packet Window size.
     *
     *  pktSize X.25 default Packet size.
     *
     *  minPktSize X.25 log base 2 of min packet size in negotiation.
     *
     *  maxPktSize X.25 log base 2 of max packet size in negotiation.
     *
     *  lowestPVC X.25 lowest PVC.
     *
     *  highestPVC X.25 highestPVC.
     *
     *  lowestSVC X.25 lowest SVC.
     *
     *  highestSVC X.25 highestSVC.
     *
     *  clearDiag X.25 Clear request has DIAG.
     *
     *  resetDiag X.25 reset request has DIAG.
     *
     *  restartDiag X.25 restart request has DIAG.
     *
     *  pktOptions X.25 packet level options.
     *
     *  pktT20 X.25 timer for retransmitting a restart request.
     *
     *  pktR20 X.25 number of restart request retries.
     *
     *  pktT21 X.25 call request timer.
     *
     *  pktT22 X.25 reset request timer.
     *
     *  pktR22 X.25 number of reset request retries.
     *
     *  pktT23 X.25 timer for retransmitting a clear request.
     *
     *  pktR23 X.25 number of clear request retries.
     *
     *  pktX121SrcAddr X.121 source address
     *
     *  pktDteFlag DTE Flag Enum
     *
     *  pktNetType Net Type Enum
     *
     *  frmDiscMode Disc Mode: Active or passive
     *
     *  frmSeqNumber Sequence numbers mode: normal or extended
     *
     *  pktRevChargeAccept Reverse Charge Acceptance
     *
     *  padVceTmrVal Virtual Call Establishment Timer Interval: number of
     *                                  seconds to maintain a connection to a
     *                                  character oriented device that has not
     *                                  established a virtual call. A value of
     *                                  0 disables the timer box-wide
     *
     *  tei TEI to be used when D-channel X.25
     */

#if ( MDF_X25B == FYES )

typedef struct x25Profile {
#line 136 "mibx25.mdf"
    char                                x25Name[ MAX_X25_NAME_LEN + 1 ];
#line 140 "mibx25.mdf"
    Boolean                             active;
#line 145 "mibx25.mdf"
    Boolean                             kludge;
#line 151 "mibx25.mdf"
    Uint16                              nailedUpGroup;
#line 155 "mibx25.mdf"
    NailedMode                          nailedMode;
#line 159 "mibx25.mdf"
    int                                 calledNumberType;
#line 164 "mibx25.mdf"
    SwitchedCallType                    switchedCallType;
#line 169 "mibx25.mdf"
    char                                phoneNumber[ MAX_PHONE_NUMBER_LENGTH + 1 ];
#line 173 "mibx25.mdf"
    char                                billingNumber[ MAX_BILLING_NUMBER_LENGTH + 1 ];
#line 177 "mibx25.mdf"
    char                                transitNumber[ MAX_TRANSIT_NUMBER_LENGTH + 2 ];
#line 182 "mibx25.mdf"
    Word                                callByCallID;
#line 186 "mibx25.mdf"
    Word                                T1Val;
#line 190 "mibx25.mdf"
    Word                                T2Val;
#line 194 "mibx25.mdf"
    Word                                N2Val;
#line 198 "mibx25.mdf"
    Word                                kVal;
#line 203 "mibx25.mdf"
    Word                                pktWindow;
#line 207 "mibx25.mdf"
    Word                                pktSize;
#line 211 "mibx25.mdf"
    PktSizeNegoEnum                     minPktSize;
#line 215 "mibx25.mdf"
    PktSizeNegoEnum                     maxPktSize;
#line 219 "mibx25.mdf"
    Word                                lowestPVC;
#line 223 "mibx25.mdf"
    Word                                highestPVC;
#line 227 "mibx25.mdf"
    Word                                lowestSVC;
#line 231 "mibx25.mdf"
    Word                                highestSVC;
#line 235 "mibx25.mdf"
    PktYesNoEnum                        clearDiag;
#line 239 "mibx25.mdf"
    PktYesNoEnum                        resetDiag;
#line 243 "mibx25.mdf"
    PktYesNoEnum                        restartDiag;
#line 247 "mibx25.mdf"
    PktOptionsEnum                      pktOptions;
#line 251 "mibx25.mdf"
    Word                                pktT20;
#line 255 "mibx25.mdf"
    Word                                pktR20;
#line 259 "mibx25.mdf"
    Word                                pktT21;
#line 263 "mibx25.mdf"
    Word                                pktT22;
#line 267 "mibx25.mdf"
    Word                                pktR22;
#line 271 "mibx25.mdf"
    Word                                pktT23;
#line 275 "mibx25.mdf"
    Word                                pktR23;
#line 279 "mibx25.mdf"
    char                                pktX121SrcAddr[ MAX_PHONE_NUMBER_LENGTH + 1 ];
#line 283 "mibx25.mdf"
    PktDteFlagEnum                      pktDteFlag;
#line 287 "mibx25.mdf"
    PktNetTypeEnum                      pktNetType;
#line 291 "mibx25.mdf"
    FrmDiscModeEnum                     frmDiscMode;
#line 295 "mibx25.mdf"
    FrmSeqNumberEnum                    frmSeqNumber;
#line 299 "mibx25.mdf"
    PktYesNoEnum                        pktRevChargeAccept;
#line 303 "mibx25.mdf"
    Word                                padVceTmrVal;
#line 309 "mibx25.mdf"
#if ( X25_DCHAN == FYES )
    Word                                tei;
#endif /* ( X25_DCHAN == FYES ) */
}
#if ( USERIF & CLI )
__PACK__
#endif
X25Profile;

#endif /* ( MDF_X25B == FYES ) */
#line 339 "mibx25.mdf"

#endif /* MIBX25_H */

