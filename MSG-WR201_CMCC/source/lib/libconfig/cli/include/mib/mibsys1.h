    /*
     * Notice: file generated by MIBMAKE from mibsys1.mdf
     * DO NOT EDIT THIS FILE!!!  Edit mibsys1.mdf
     */
/*
 * $Id: mibsys1.h,v 1.1.1.1 2011/08/17 11:11:56 brwang Exp $
 *
 *      Copyright (c) 1995 UTT Technologies, Inc.
 *      All rights reserved.
 *      Use of copyright notice does not imply publication.
 *
 *
 *                      CONFIDENTIAL INFORMATION
 *                      ------------------------
 *      This Document contains Confidential Information or Trade Secrets,
 *      or both, which are the property of UTT Technologies, Inc.
 *      This document may not be copied, reproduced, reduced to any
 *      electronic medium or machine readable form or otherwise duplicated
 *      and the information herein may not be used, disseminated or
 *      otherwise disclosed, except with the prior written consent of
 *      UTT Technologies, Inc.
 */


#if ! defined( MIBSYS1_H )
# define MIBSYS1_H

    /* This file contains the internal representation of the system profile
     * (MIB_PROF_SYSTEM). The name of this profile is stored in the global
     * variable mibProfSystem.
     */

extern const char* const		mibProfSystem;

    /*
     * Size of the bootSrVersion char array used to store the version
     * of tntsrb.
     */
# define MAX_VER_STR_LEN	20

/*
 * add by brwang
 */
#ifndef  MAX_CBT_TIMERANGE_NUM
#define MAX_CBT_TIMERANGE_NUM   3
#endif


#include "mibpdb.h"                       /* add for enhance pdb numbers*/
#include "mibfiltr.h"

# define STATUS_NUMBER_LEN	7
# define NUMBER_STATUS_SCREEN	8

typedef enum languageSelection_enum {
	LANGUAGE_CHN 	= 0,
	LANGUAGE_ENG 	= 1,
	LANGUAGE_SPAN 	= 2,
	LANGUAGE_JPN 	= 3,
	LANGUAGE_RUS 	= 4,
	LANGUAGE_FRE 	= 5,
	LANGUAGE_MAX 
}  LanguageSelection;

typedef enum sanity_check_enum {
	SANITY_CHECK_NONE 	= 0x0,
	SANITY_CHECK_IMG 	= 0x1,
	SANITY_CHECK_FLASH 	= 0x2,
	SANITY_CHECK_NVRAM 	= 0x4,
	SANITY_CHECK_DATA 	= 0x8,
	SANITY_CHECK_TASK 	= 0x10,
	SANITY_BACKUP_IMG 	= 0x20,
	SANITY_BACKUP_WEB 	= 0x40,
	SANITY_CHECK_MAX 	= 0xFFFFFFFF
}  sanityCheckType;

typedef enum p2p_policy_type {
        P2P_TYPE,
        VIRUS_TYPE,
        IM_TYPE,
        APP_TYPE,
        P2P_CLASS_MAX
} p2pClassType;

typedef enum p2p_check_enum {
	P2P_CHECK_EDC 		= 0x0,
	P2P_CHECK_BT 		= 0x1,
	P2P_CHECK_XUNLEI 	= 0x2,
	P2P_CHECK_KAZAA 	= 0x4,
	P2P_CHECK_EMUL 		= 0x8,
	P2P_CHECK_TASK 		= 0x10,
	P2P_CHECK_IMG	 	= 0x20,
	P2P_CHECK__WEB	 	= 0x40,
	P2P_CHECK_MAX 	= 0xFFFFFFFF
}  p2pCheckType;

typedef enum virus_check_enum {
	VIRUS_CHECK_NONE 	= 0x0,
	VIRUS_CHECK_ARPS 	= 0x1,
	VIRUS_CHECK_IPSS 	= 0x2,
	VIRUS_CHECK_BLASTER 	= 0x4,
	VIRUS_CHECK_SLAMMER 	= 0x8,
	VIRUS_CHECK_SASSER 	= 0x10,
	VIRUS_BACKUP_IMG 	= 0x20,
	VIRUS_BACKUP_WEB 	= 0x40,
	VIRUS_CHECK_MAX 	= 0xFFFFFFFF
}  virusCheckType;

typedef enum im_check_enum {
	IM_CHECK_NONE 	= 0x0,
	IM_CHECK_QQ 	= 0x1,
	IM_CHECK_MSN 	= 0x2,
	IM_CHECK_NVRAM 	= 0x4,
	IM_CHECK_DATA 	= 0x8,
	IM_CHECK_TASK 	= 0x10,
	IM_BACKUP_IMG 	= 0x20,
	IM_BACKUP_WEB 	= 0x40,
	IM_CHECK_MAX 	= 0xFFFFFFFF
}  IMCheckType;

    /*
     * Status screens are "saved" by status menu number.  The menu is
     * stored as a text field in the form sp-n00.  Functions
     * exist in lcdmenu.c to convert textual menu numbers to slots,
     * ports, and menus.
     */
typedef char	StatusNumber[ STATUS_NUMBER_LEN + 1 ];


    /*
     * CallRouteSortMethod:
     *
     * Ways to sort the call-routing database.
     *
     *  SORT_ITEM_FIRST Sort by item number, then shelf and slot number. Tends
     *                                  to distribute incoming calls evenly
     *                                  across multiple host cards.
     *
     *  SORT_SLOT_FIRST Sort by shelf and slot number, then item number. Tends
     *                                  to concentrate incoming calls on one
     *                                  host card at a time.
     */

#if ( PLATFORM & TNT )

typedef enum CallRouteSortMethod {
    SORT_ITEM_FIRST = 0,
    SORT_SLOT_FIRST = 1
} CallRouteSortMethod;

#endif /* ( PLATFORM & TNT ) */

#if ( PLATFORM & TNT )



static __inline__ Bool
validCallRouteSortMethod (int x)
{
    switch (x) {
    case SORT_ITEM_FIRST:
    case SORT_SLOT_FIRST:
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* ( PLATFORM & TNT ) */

    /*
     * ShelfControllerType:
     *
     * Temporarily used until the Master Shelf Election is implemented
     *
     *  STANDALONE
     *
     *  MASTER
     *
     *  SLAVE
     */

#if ( PLATFORM & TNT )

typedef enum ShelfControllerType {
    STANDALONE = 0,
    MASTER,
    SLAVE
} ShelfControllerType;

#endif /* ( PLATFORM & TNT ) */

#if ( PLATFORM & TNT )



static __inline__ Bool
validShelfControllerType (int x)
{
    switch (x) {
    case STANDALONE:
    case MASTER:
    case SLAVE:
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* ( PLATFORM & TNT ) */

    /*
     * P50SwitchUsage:
     *
     * Possible usages for the little switch on the back of the 264 and above
     * P50 jobbies.
     *
     *  SWITCH_UNUSED The switch position means nothing.
     *
     *  SWITCH_SERIAL_WAN The switch enables serial wan operation.
     *
     *  SWITCH_NUMBER_OF_USES
     */

#if ( PLATFORM & (P50 | PDSL) )

typedef enum P50SwitchUsage {
    SWITCH_UNUSED,
    SWITCH_SERIAL_WAN,
    SWITCH_NUMBER_OF_USES
} P50SwitchUsage;

#endif /* ( PLATFORM & (P50 | PDSL) ) */

#if ( PLATFORM & (P50 | PDSL) )



static __inline__ Bool
validP50SwitchUsage (int x)
{
    switch (x) {
    case SWITCH_UNUSED:
    case SWITCH_SERIAL_WAN:
    case SWITCH_NUMBER_OF_USES:
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* ( PLATFORM & (P50 | PDSL) ) */

    /*
     * HighBER:
     *
     * The following high bit error rate are used to determine when to set the
     * relay alarm.
     *
     *  HIGH_BER_3 10 ** -3 (one error in 10 ** 3 bits ).
     *
     *  HIGH_BER_4 10 ** -4 (one error in 10 ** 4 bits ).
     *
     *  HIGH_BER_5 10 ** -5 (one error in 10 ** 5 bits ).
     */
typedef enum HighBER {
    HIGH_BER_3,
    HIGH_BER_4,
    HIGH_BER_5
} HighBER;


static __inline__ Bool
validHighBER (int x)
{
    switch (x) {
    case HIGH_BER_3:
    case HIGH_BER_4:
    case HIGH_BER_5:
        return TRUE;
    default:
        return FALSE;
    }
}

    /*
     * AnalogEncoding:
     *
     * The following values are used to program the codecs associated with
     * digital modems to the companding algorithm selected by the user.
     *
     *  MU_LAW u-Law (actually MU-Law) encoding of analog data.
     *
     *  A_LAW A-Law encoding of analog data.
     */

#if ( MDF_LMODEM == FYES ) && ( ( ( PLATFORM & MPORT ) && ( NETIF & ( T1 | E1 | DPNSS ) ) ) || ( PLATFORM & TNT ) )

typedef enum AnalogEncoding {
    MU_LAW,
    A_LAW
} AnalogEncoding;

#endif /* ( MDF_LMODEM == FYES ) && ( ( ( PLATFORM & MPORT ) && ( NETIF & ( T1 | E1 | DPNSS ) ) ) || ( PLATFORM & TNT ) ) */

#if ( MDF_LMODEM == FYES ) && ( ( ( PLATFORM & MPORT ) && ( NETIF & ( T1 | E1 | DPNSS ) ) ) || ( PLATFORM & TNT ) )



static __inline__ Bool
validAnalogEncoding (int x)
{
    switch (x) {
    case MU_LAW:
    case A_LAW:
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* ( MDF_LMODEM == FYES ) && ( ( ( PLATFORM & MPORT ) && ( NETIF & ( T1 | E1 | DPNSS ) ) ) || ( PLATFORM & TNT ) ) */

    /*
     * WanInterface:
     *
     * The following values are used to select the type of WAN Interface
     * selected.
     *
     *  WAN_T1 T1-CSU Serial Port WAN interface.
     *
     *  WAN_SWAN Serial WAN interface.
     */

#if defined( LCD_CHANGE_NET_IF )

typedef enum WanInterface {
    WAN_T1,
    WAN_SWAN
} WanInterface;

#endif /* defined( LCD_CHANGE_NET_IF ) */

#if defined( LCD_CHANGE_NET_IF )



static __inline__ Bool
validWanInterface (int x)
{
    switch (x) {
    case WAN_T1:
    case WAN_SWAN:
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* defined( LCD_CHANGE_NET_IF ) */

    /*
     * PermConnMode:
     *
     * The following values are used to specify the mode for remote permanent
     * connections' configurations update
     *
     *  PERM_CONN_ALL All permanent connections reestablished
     *
     *  PERM_CONN_CHANGED Only changed permanent connections reestablished
     */

#if ( RADIUS == FYES )

typedef enum PermConnMode {
    PERM_CONN_ALL,
    PERM_CONN_CHANGED
} PermConnMode;

#endif /* ( RADIUS == FYES ) */

#if ( RADIUS == FYES )



static __inline__ Bool
validPermConnMode (int x)
{
    switch (x) {
    case PERM_CONN_ALL:
    case PERM_CONN_CHANGED:
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* ( RADIUS == FYES ) */

    /*
     * ControlBusType:
     *
     * How to send control bus messages.
     *
     *  DPRAM
     *
     *  PBUS
     */

#if ( PLATFORM & TNT )

typedef enum ControlBusType {
    DPRAM = 0,
    PBUS
} ControlBusType;

#endif /* ( PLATFORM & TNT ) */

#if ( PLATFORM & TNT )



static __inline__ Bool
validControlBusType (int x)
{
    switch (x) {
    case DPRAM:
    case PBUS:
        return TRUE;
    default:
        return FALSE;
    }
}

#endif /* ( PLATFORM & TNT ) */

    /*
     * The maximum number of channels that may be dialed in parallel, and
     * the default value, are defined below.
     */

     /*
      * I hate the lowest common denominator effect here, but;
      * If DPNSS supports a more modest parallel dialing value we'll
      * try to live with it.  This is a system wide parameter.  That
      * means we have a hard time making distinctions on a DSL by DSL
      * basis for this value.  The side effect is that E1 on a MAX will
      * be limited to the smaller parallel dialing value.
      */
# if (NETIF & DPNSS )
#  define MAX_PARALLEL_DIALING	3
#  define DEF_PARALLEL_DIALING	2
# elif ( NETIF & ( T1 | E1 | BRI | S56_2 | IFDSL | S56_4 | S56_4A | AT ))
#  define MAX_PARALLEL_DIALING	12
#  if ( MDF_DPNSS_SIGNALING == FYES )
#   define DEF_PARALLEL_DIALING	10
#  else
#   define DEF_PARALLEL_DIALING	10
#  endif
# elif ( PLATFORM == TNT )
#  define DEF_PARALLEL_DIALING	12
# elif
#  error Unknown NETIF
# endif

     /*
      * The default maximum timeout for dialout calls
      */
#  define     DEF_MAX_DIAL_TIMEOUT	13

# if ( ENCRYPT_PASSWD == FYES )

typedef enum passwdCrtpt {
	CLEAR_TEXT 	= 0x0,
	CRYPT_BASE64	= 0x1,
	CRYPT_MD5	= 0x2,
	CRYPT_SHA	= 0x4,
	CRYPT_XOR	= 0x8,
	CRYPT_MODE_MAX  = 0x1000
} pwCryptMode;

typedef struct st_sysPassworProfile {
   pwCryptMode encryptLevel;
} SysPasswordProfile;

# endif /* ENCRYPT_PASSWD */

    /*
     * SysModemProfile:
     *
     * This sub-profile is defined for adding modem specific parameters to the
     * MAX system profile.
     *
     *  atAnsStr Allows the user to enter any additional AT commands in the
     *                                  modem answer string.
     */
typedef struct sysModemProfile {
#if ( PLATFORM & MPORT )
    char                                atAnsStr[ MAX_AT_ANSWER_STRING_LEN ];
#endif /* ( PLATFORM & MPORT ) */
}
#if ( USERIF & CLI )
__PACK__
#endif
SysModemProfile;

    /*
     * SystemProfile:
     *
     * The following structure defines the system profile, which is the basic
     * description of the box, independent of any dba or network profiles. Note
     * that there are a few things which are outside the scope of the NVRAM,
     * such as the time and date which are always magic...
     *
     *  installationComplete Indicates whether the first-time installation menu
     *                                  has been run. Set to FALSE when NVRAM
     *                                  is first initialized.
     *
     *  name The name of the system given by the user, a standard null
     *                                  terminated ASCII string.
     *
     *  contact The name of the contact for this device. SNMP readable.
     *
     *  location The location of this device. SNMP readable.
     *
     *  controlPortBitRate The bit rate of the management terminal port, as
     *                                  given above.
     *
     *  menus A MenuType specifying the type of interface to use on the console
     *                                  port.
     *
     *  systemRmtMgmt Set true if this system allows remote management.
     *
     *                                  for details.
     *
     *  serialSubaddress sub-address assigned to serial port connections.
     *
     *  lanSubaddress sub-address assigned to sync lan connections.
     *
     *  dmSubaddress sub-address assigned to digital modem connections.
     *
     *  v110Subaddress sub-address assigned to V.110 rate adaption connections
     *
     *  useTrunkGroups Enables TrunkGroups for all network lines.
     *
     *  numDigsTnkGrp Specify number of digits TrunkGroups support.
     *
     *  autoLogout When TRUE select the default security profile on loss of
     *                                  CD/DTR from the main console port.
     *
     *  idleLogout When non-zero select the default security profile after this
     *                                  value of minutes with no keyboard
     *                                  activity.
     *
     *  p50SwitchUsage What the P50 switch does.
     *
     *  systemDS0MinReset Has three choices: Off, 24Hr or Monthly. When
     *                                  enabled, the following maxSystemDS0Mins
     *                                  is the high water mark at which all
     *                                  switched connections originating on the
     *                                  system will be taken down.
     *
     *  maxSystemDS0Mins Sets the high water billing mark at which all
     *                                  originating switched connections are
     *                                  brought down.
     *
     *  maxDialoutTime The max time in Sec, system will wait for Call Setup
     *                                  Complete
     *
     *  parallelDialing The number of simultaneous calls that can be placed at
     *                                  the same time.
     *
     *  singleFileIncoming Should the calls be treated as a single-file list,
     *                                  or in parallel. PictureTel wants
     *                                  parallel others want single-file.
     *
     *  exclusivePortRouting route only to port/number specified, not to
     *                                  'other' if that port is in use.
     *
     *  highBER Indicates the high bit error rate. When the bit error rate
     *                                  exceeds the threshold, relay alarm will
     *                                  be set if it is so configured.
     *
     *  highBERAlarm Indicates whether we should set relay alarm when BER
     *                                  exceeds high BER threshold.
     *
     *  noTrunkAlarm Indicates whether we should set relay alarm when no trunk
     *                                  is available.
     *
     *  delayDualPortDialing TRUE if we should delay between dual port calls,
     *                                  FALSE if they should be placed at the
     *                                  same time.
     *
     *  editNumber The menu number of the default edit screen.
     *
     *  statusNumber An array of status screen number entries used to specify
     *                                  the default status screen layout.
     *
     *  analogEncoding Sets the encoding standard for digitized analog data to
     *                                  either u-Law or A-Law. Universally sets
     *                                  all codecs on the unit to the value
     *                                  selected. Defaults to u-Law for T1,
     *                                  A-Law for E1 interfaces.
     *
     *  sessionIdBase The base session ID value
     *
     *  tOnline TRUE if we should route calls to T-Online, FALSE if not.
     *
     *  tMostAvailBchan TRUE if T-Online calls are to be routed to NT line with
     *                                  the most available B-channels FALSE if
     *                                  it is based on circular basis.
     *
     *  t302Timer Number of milliseconds to wait for additional called number
     *                                  information elements for an incoming
     *                                  T-Online call. Defaults to 1500.
     *
     *  callRouteSort How to sort the Call Routing table for analog calls.
     *
     *  digitalCallRouteSort How to sort the Call Routing table for digital
     *                                  calls.
     *
     *  shelfController Temporarily used until the Master Shelf Election is
     *                                  implemented.
     *
     *  masterShelf Master shelf controller number. This attribute exists only
     *                                  when the shelf-controller-type is
     *                                  SLAVE.
     *
     *  echoSuppressorToneDisable Disable echo suppressor tone, which is
     *                                  generated at the beginning of an
     *                                  Outgoing Call
     *
     *  newNASPortIDFormat TRUE if new NAS port ID format is used, FALSE if old
     *                                  NAS Port ID is used. On the TNT product
     *                                  family the new NAS port ID format is
     *                                  used by default. The old format cannot
     *                                  be used for multi-shelf systems or if
     *                                  any line cards are in a slot greater
     *                                  than the twelfth position.
     *
     *  modemPRI_TypeOfNumber PRI Called Party element's Type-Of-Number value
     *                                  for outgoing modem calls.
     *
     *  modemPRI_NumberingPlanID PRI Called Party element's Numbering-Plan-ID
     *                                  value for outgoing modem calls.
     *
     *  wanInterface Sets the type of WAN interface supported: T1-CSU or Serial
     *                                  WAN.
     *
     *  permConnMode Enables nonintrusive remote update of permanent
     *                                  connections' configurations. 'Changed'
     *                                  means that only changed connections
     *                                  will be torn down and reestablished,
     *                                  'All' means all existing permanent
     *                                  connections will be turn down and then
     *                                  reestablished only if they are fetched
     *                                  from the RADIUS server again
     *
     *  userstatFormat Defines the output format of the session listing command
     *                                  'userstat' and the remote user
     *                                  information protocol 'finger'. The
     *                                  following special characters will be
     *                                  converted to their values for each
     *                                  listed session. The width of each field
     *                                  is indicated in []. %i [10] SessionID,
     *                                  Unique ID assigned to the session. %l
     *                                  [10] Line/Chan, Physical address
     *                                  (shelf.slot.line/chan). %s [11]
     *                                  Slot:Item, shelf:slot:item/logical-item
     *                                  of the host port. %r [11] Tx/Rx Rate,
     *                                  Transmit and receive rates. %d [ 3]
     *                                  Svc, A three-letter code showing the
     *                                  type of service. %a [15] Address, IP
     *                                  address. %u [14] Username, Connection
     *                                  profile name. %c [10] ConnTime, Ammount
     *                                  of time connected in
     *                                  hours:minutes:seconds. %t [10]
     *                                  IdleTime, Ammount of time idle in
     *                                  hours:minutes:seconds. %n [24] Dialed#,
     *                                  Number dialed if known. For example set
     *                                  userstat-format = '%i %l %s %r %d %a %u
     *                                  %c %t %n' would set the format to the
     *                                  factory default value.
     *
     *  controlBus How to send control bus messages. This attribute exists only
     *                                  when the shelf-controller-type is not
     *                                  SLAVE.
     *
     *  bootSrVersion Place for tntsrb, the shelf controller boot loader, to
     *                                  provide its version. Boot loader
     *                                  updates the field with its version on
     *                                  every system reset
     *
     *  modem New sub-profile, where modem parameters should be added.
     */
typedef struct st_systemProfile {
    char                                hostName[MAX_PROFILE_NAME_LENGTH+1];
    Boolean                             active;
    Boolean                             installationComplete;
    Byte                                name[ MAX_UNIT_NAME_LEN + 1 ];
#if ( !( PLATFORM & TNT ) && ( MDF_SNMP == FYES ) )
    Byte                                contact[ MAX_SNMP_INFO_LEN + 1 ];
#endif /* ( !( PLATFORM & TNT ) && ( MDF_SNMP == FYES ) ) */
#if ( !( PLATFORM & TNT ) && ( MDF_SNMP == FYES ) )
    Byte                                location[ MAX_SNMP_INFO_LEN + 1 ];
#endif /* ( !( PLATFORM & TNT ) && ( MDF_SNMP == FYES ) ) */
#if ( ! ( PLATFORM & TNT ) )
    ControlPortBitRate                  controlPortBitRate;
#endif /* ( ! ( PLATFORM & TNT ) ) */
#if ( ! ( PLATFORM & TNT ) )
    MenuType                            menus;
#endif /* ( ! ( PLATFORM & TNT ) ) */
    Boolean                             systemRmtMgmt;
#if PLATFORM & ( MPORT | P50 | PDSL | P25 | P15 | M200 )
    SubAddressMode                      subAddressMode;
#endif /* PLATFORM & ( MPORT | P50 | PDSL | P25 | P15 | M200 ) */
#if PLATFORM & ( MPORT )
    Word                                serialSubaddress;
#endif /* PLATFORM & ( MPORT ) */
#if PLATFORM & ( MPORT )
    Word                                lanSubaddress;
#endif /* PLATFORM & ( MPORT ) */
#if PLATFORM & ( MPORT )
    Word                                dmSubaddress;
#endif /* PLATFORM & ( MPORT ) */
#if ( MDF_V110 == FYES )
    Word                                v110Subaddress;
#endif /* ( MDF_V110 == FYES ) */
    Boolean                             useTrunkGroups;
    Word                                numDigsTnkGrp;
#if ( ! ( PLATFORM & TNT ))
    Boolean                             autoLogout;
#endif /* ( ! ( PLATFORM & TNT )) */
    Word                                idleLogout;
#if ( PLATFORM & (P50 | PDSL) )
    P50SwitchUsage                      p50SwitchUsage;
#endif /* ( PLATFORM & (P50 | PDSL) ) */
#if ( ! ( PLATFORM & TNT ))
    DS0MinReset                         systemDS0MinReset;
#endif /* ( ! ( PLATFORM & TNT )) */
#if ( ! ( PLATFORM & TNT ))
    DS0Minutes                          maxSystemDS0Mins;
#endif /* ( ! ( PLATFORM & TNT )) */
    Uint8                               maxDialoutTime;
    Word                                parallelDialing;
    Boolean                             singleFileIncoming;
    Boolean                             exclusivePortRouting;
    HighBER                             highBER;
    Boolean                             highBERAlarm;
    Boolean                             noTrunkAlarm;
#if (! ( PLATFORM & TNT ))
    Boolean                             delayDualPortDialing;
#endif /* (! ( PLATFORM & TNT )) */
#if ( ! (USERIF & CLI) )
    StatusNumber                        editNumber;
#endif /* ( ! (USERIF & CLI) ) */
#if ( ! (USERIF & CLI) )
    StatusNumber                        statusNumber[ NUMBER_STATUS_SCREEN ];
#endif /* ( ! (USERIF & CLI) ) */
#if ( MDF_LMODEM == FYES ) && ( ( ( PLATFORM & MPORT ) && ( NETIF & ( T1 | E1 | DPNSS ) ) ) || ( PLATFORM & TNT ) )
    AnalogEncoding                      analogEncoding;
#endif /* ( MDF_LMODEM == FYES ) && ( ( ( PLATFORM & MPORT ) && ( NETIF & ( T1 | E1 | DPNSS ) ) ) || ( PLATFORM & TNT ) ) */
    Uint32                              sessionIdBase;
#if ( MDF_T_ONLINE == FYES )
    Boolean                             tOnline;
#endif /* ( MDF_T_ONLINE == FYES ) */
#if ( MDF_T_ONLINE == FYES )
    Boolean                             tMostAvailBchan;
#endif /* ( MDF_T_ONLINE == FYES ) */
#if ( PLATFORM & MPORT ) && ( NETIF & E1 ) && ( MDF_T_ONLINE == FYES )
    Uint16                              t302Timer;
#endif /* ( PLATFORM & MPORT ) && ( NETIF & E1 ) && ( MDF_T_ONLINE == FYES ) */
#if ( PLATFORM & TNT )
    CallRouteSortMethod                 callRouteSort;
#endif /* ( PLATFORM & TNT ) */
#if ( PLATFORM & TNT )
    CallRouteSortMethod                 digitalCallRouteSort;
#endif /* ( PLATFORM & TNT ) */
#if ( PLATFORM & TNT )
    ShelfControllerType                 shelfController;
#endif /* ( PLATFORM & TNT ) */
#if ( PLATFORM & TNT )
    Uint16                              masterShelf;
#endif /* ( PLATFORM & TNT ) */
    Boolean                             echoSuppressorToneDisable;
#if (( PLATFORM & MPORT ) || ( PLATFORM & TNT ))
    Boolean                             newNASPortIDFormat;
#endif /* (( PLATFORM & MPORT ) || ( PLATFORM & TNT )) */
#if ( ( PLATFORM & MPORT ) && ( NETIF & T1 ) && ( ( MDF_LMODEM == FYES ) || ( MDF_V110 == FYES ) ) )
    int                                 modemPRI_TypeOfNumber;
#endif /* ( ( PLATFORM & MPORT ) && ( NETIF & T1 ) && ( ( MDF_LMODEM == FYES ) || ( MDF_V110 == FYES ) ) ) */
#if ( ( PLATFORM & MPORT ) && ( NETIF & T1 ) && ( ( MDF_LMODEM == FYES ) || ( MDF_V110 == FYES ) ) )
    int                                 modemPRI_NumberingPlanID;
#endif /* ( ( PLATFORM & MPORT ) && ( NETIF & T1 ) && ( ( MDF_LMODEM == FYES ) || ( MDF_V110 == FYES ) ) ) */
#if defined( LCD_CHANGE_NET_IF )
    WanInterface                        wanInterface;
#endif /* defined( LCD_CHANGE_NET_IF ) */
#if ( RADIUS == FYES )
    PermConnMode                        permConnMode;
#endif /* ( RADIUS == FYES ) */
#if (( PLATFORM & TNT ) && ( USERIF & CLI ))
    Byte                                userstatFormat[ MAX_USERSTAT_FORMAT_LEN + 1 ];
#endif /* (( PLATFORM & TNT ) && ( USERIF & CLI )) */
#if ( PLATFORM & TNT )
    ControlBusType                      controlBus;
#endif /* ( PLATFORM & TNT ) */
#if (( PLATFORM & TNT ) && ( USERIF & CLI ))
    Char                                bootSrVersion[ MAX_VER_STR_LEN + 1 ];
#endif /* (( PLATFORM & TNT ) && ( USERIF & CLI )) */
#if ( PLATFORM & MPORT )
    SysModemProfile                     modem;
#endif /* ( PLATFORM & MPORT ) */
    Boolean                             ipHotelEnabled;
    Boolean                             ipArpSpoofEnabled;
    Boolean                             ipForwardEnabled;
    Boolean                             ipHelperEnabled;
    Boolean                             ipSpfTreeEnabled;
    Boolean                             ipWebPortalEnabled;
    Boolean                             ipDnsPortalEnabled;
    Boolean                             ipAppPortalEnabled;
    Boolean                             ipPortalEnabled;
    Boolean                             ipArpKeepaliveEnabled;
    Boolean                             sysREDEnabled;
    Boolean                             ipMacREDEnabled;
    Boolean                             ipNATREDEnabled;
/* auto paged term output */
    Uint32				tsPage;
/* enable/disable l3forwarding */
# if ( L3SWITCH == FYES )
    Boolean				l3switchEnabled;
    int					l3discard;
# endif
# if ( SNIFFER_PORT == FYES )
    Boolean				snifferEnabled;
# endif
/* interval of heartbeat msg send to syslog */
    Uint32				logInterval;
# if ( ENCRYPT_PASSWD == FYES )
    SysPasswordProfile                  passwordProfile;
# endif /* ENCRYPT_PASSWD */
    LanguageSelection 			language;
#if (WATCHDOG == FYES)
    int					watchdog;
# endif /* WATCHDOG == FYES */
    Boolean				hardwareCrypt;
    Boolean				syncRTC;
    Uint32                              segStart;
    Uint32                              segEnd;
    /*
     * llliu change int => Uint32
     */
    ///int				blockSize;
    Uint32                              blockSize;
    sanityCheckType			sanityCheck;
//
// zhz@20031202, reload interval;
//
    Uint32                              reloadInterval;
    char                                reloadTmrgProfile[MAX_PROFILE_NAME_LENGTH+1];
    /* edit by brwang 080520*/
    Uint8                                ipMacRateTmrgProfile[MAX_CBT_TIMERANGE_NUM][MAX_PROFILE_NAME_LENGTH+1];
# if ( IPP2P == FYES )
/* virus */
    virusCheckType			antiVirus;
    Boolean				antiIpSpoofEnabled;
    Boolean				antiArpSpoofEnabled;
    Boolean				antiBlasterEnabled;
    Boolean				antiSlammerEnabled;
    Boolean				antiSasserEnabled;
/* p2p */
    p2pCheckType			antiP2p;
    Boolean				antiP2pEnabled;
    Uint8                                p2pTime[MAX_PROFILE_NAME_LENGTH+1];
/* im */
    IMCheckType				antiIM;
    Boolean				antiQQEnabled;
    Uint8                                QQTime[MAX_PROFILE_NAME_LENGTH+1];
    Boolean				antiMsnEnabled;
    Uint8                                msnTime[MAX_PROFILE_NAME_LENGTH+1];
    //Uint32                              pdbPolicy;//added by brwang for pdb can auto show in web
    Byte                              pdbPolicy[MAX_PDB_BIT_COUNT];    //enhance the pdb to 50 items
    Uint8                                pdbPolicyTime[MAX_PROFILE_NAME_LENGTH+1];
# endif	//IPP2P
    Boolean				httpGetUnrar;   /* add by brwang */
    Boolean				antiGameUrl;
    Boolean				antiStockUrl;
IpAddress                           allowAccessing;	//add by jyshen 061206
IpAddress                           allowAccessingEnd;	//add by jyshen 070123

#if (POLICY_ROUTE == FYES)
    Boolean				policyRouteActive;
#endif
#if (NETKEEPER == FYES)
    Uint32				netKeeperTime;
#endif

#if ((SK2 == FYES) && (SK2_WATCHDOG == FYES))
    Boolean				watchDog;
    Uint32				watchTimer;
#endif

}
#if ( USERIF & CLI )
__PACK__
#endif
SystemProfile;
    /*
     * Return a pointer to "the" factory system profile.  This will be used
     * as a read-only copy outside of this module.
     *
     * Note that the profile is built with "installationComplete" FALSE,
     * so it must be changed if loaded into the active profile on an already
     * installed system.
     */
# if ( MIBMGR == FYES )
extern ConstPtr
mibFactorySystemProfile( MibProfileType	mibType,
			 ConstPtr	mibIndex,
			 Int		mibIndexLen );
# else
extern const SystemProfile *
buildFactorySystemProfile( void );
# endif


#endif /* MIBSYS1_H */

